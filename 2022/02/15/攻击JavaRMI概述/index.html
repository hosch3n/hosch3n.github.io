<!DOCTYPE html>
<html lang="zh-cn">
  <head><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="description" content="攻击JavaRMI概述"/><meta name="keywords" content="research,analyze" /><link rel="alternate" href="/atom.xml" title="Blog" type="application/atom+xml"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.11.0" />
<link rel="canonical" href="https://hosch3n.github.io/2022/02/15/攻击JavaRMI概述/"/>

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />
<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.11.0" />

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-180953397-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-180953397-1');
</script><script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"pjax":"","latex":false};
</script>

    <title>攻击JavaRMI概述 - Blog</title>
  <meta name="generator" content="Hexo 5.4.0"></head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><a href="/">
        <li class="mobile-menu-item">首页
          </li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签
          </li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">分类
          </li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于
          </li>
      </a></ul>
</nav>
<div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Blog</a>
</div>

<nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item">
          <a class="menu-item-link" href="/">
            首页
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/tags/">
            标签
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/categories/">
            分类
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/about/">
            关于
            </a>
        </li>
      </ul></nav>
</header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content"><article class="post">
    <header class="post-header">
      <h1 class="post-title">攻击JavaRMI概述
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2022-02-15
        </span><span class="post-category">
            <a href="/categories/Web%E5%AE%89%E5%85%A8/">Web安全</a>
            </span>
        </div>
    </header>

    <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E4%B8%9A%E5%8A%A1%E5%8D%B1%E9%99%A9%E6%96%B9%E6%B3%95"><span class="toc-text">攻击业务危险方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E8%BF%9C%E7%A8%8B%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0"><span class="toc-text">攻击远程方法参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%94%BB%E5%87%BBRMI%E6%B3%A8%E5%86%8C%E7%AB%AF"><span class="toc-text">攻击RMI注册端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%94%BB%E5%87%BBDGC%E6%9C%8D%E5%8A%A1"><span class="toc-text">攻击DGC服务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%94%BB%E5%87%BBJRMP%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-text">攻击JRMP客户端</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BB%E6%89%BEGadgets"><span class="toc-text">寻找Gadgets</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-text">触发反序列化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%88%B6%E6%94%BB%E5%87%BB%E6%96%B9"><span class="toc-text">反制攻击方</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="toc-text">参考链接</span></a></li></ol>
    </div>
  </div><div class="post-content"><p>可能师傅们也遇到过这种情况：因为问题A跟进某个类方法，调试期间遇到一个更纠结的问题B，在费尽周折终于搞清楚后，暮然回首却忘了自己在干什么（问题A）。。。QAQ</p>
<p>JavaRMI与相关攻击面错综复杂，因此本文仅以时间线梳理各种绕过方法与缓解措施的主要逻辑，而不会详述具体调用栈（但会指出关键类方法）。大家可以自行跟进加深印象，也可以参考其它师傅的文章云调试。</p>
<hr>
<p>RMI全称是<code>Remote Method Invocation</code>（远程方法调用），可以理解为远程过程调用（RPC）的Java实现版本。它使得应用程序员可以像调用本地方法一样（<code>stub.func(arg)</code>），调用远程主机上提供的方法，方法实际最终在远程主机上执行（<code>serv.func(arg)</code>），原因是本地类封装了与远程类基于<strong>序列化</strong>的网络通信（<code>socket</code>）</p>
<p>我们将上述提供业务方法的远程主机称为服务端，将发起方法调用的本地主机称为客户端。服务端会监听在一个随机端口上，将自己的通信地址等信息封装后（<code>stub</code>）由某种途径交给客户端。这种途径就是默认监听在1099端口上的注册端。</p>
<p><img src="/img/rmisum_a.png" alt="https://github.com/jasonGeng88/blog/blob/master/201704/assets/rmi_01.png"></p>
<h2 id="攻击业务危险方法"><a href="#攻击业务危险方法" class="headerlink" title="攻击业务危险方法"></a>攻击业务危险方法</h2><p>如果远程方法实现中存在输入流可控的危险方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">clazz &#123;</span><br><span class="line">    func(arg) &#123;</span><br><span class="line">        exec(arg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>理论上就跟利用Web应用漏洞一样，RMI此时就是一个毫无存在感的中间层。实际情况是基本没有能直接调用到的危险方法，而且也不知道危险方法的调用接口（<code>clazz.func(arg)</code>）</p>
<blockquote>
<p><code>java.rmi.server.useCodebaseOnly</code>在7u21|6u45时由默认false改为true，下文均需要被攻击端存在gadgets。另外为了行文流畅，8u241对String类型反序列化作的变动放在文末统一说明。</p>
</blockquote>
<h2 id="攻击远程方法参数"><a href="#攻击远程方法参数" class="headerlink" title="攻击远程方法参数"></a>攻击远程方法参数</h2><p>当服务端并不存在危险业务方法，但我们可以拿到远程方法接口类（比如开源应用）。发现它接收一个Object类型参数（<code>func(Object arg, ...)</code>），在此处传入恶意payload对象，服务端从网络接收数据并试图反序列化还原对象时，就会触发gadgets。</p>
<p>相比Object类型，远程方法入参更有可能是int、boolean等基本数据类型，或是String以及其它封装类。客户端会根据方法名及参数类型生成哈希，服务端收到这个哈希就能知道调用的是哪一个方法（<code>sun.rmi.server.UnicastServerRef#hashToMethod_Map</code>）</p>
<p>那么把恶意对象强行塞给非Object参数能否触发反序列化执行呢？当远程方法参数为非基本数据类型时，<code>sun.rmi.server.UnicastRef#unmarshalValue</code>就会进入readObject所在分支。通过 修改网络数据、修改字节码、修改内存对象、修改RMI客户端实现 任意一种方法，将方法哈希修改为服务端存在且符合类型要求的远程方法哈希，即可触发强行塞入的恶意对象。</p>
<p><img src="/img/rmisum_b.png"></p>
<h2 id="攻击RMI注册端"><a href="#攻击RMI注册端" class="headerlink" title="攻击RMI注册端"></a>攻击RMI注册端</h2><p>抛开具体业务远程方法，Registry也提供了基本方法：</p>
<ul>
<li>bind(String, Remote)</li>
<li>list()</li>
<li>lookup(String)</li>
<li>rebind(String, Remote)</li>
<li>unbind(String)</li>
</ul>
<p>除了list方法不会向<strong>注册端</strong>传递参数，其余四个方法的任意参数都会被注册端接收并readObject（<code>sun.rmi.registry.RegistryImpl_Skel#dispatch</code>），要解决的问题是如何让恶意对象符合类型要求。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/NickstaDB/BaRMIe/blob/master/src/nb/barmie/net/proxy/thread/BindPayloadInjectingProxyThread.java">BaRMIe</a>采用代理注册端，通过<code>handleData</code>方法替换字节流数据，最终形成<code>bind(payload, null)</code></p>
<p><a target="_blank" rel="noopener" href="https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/exploit/RMIRegistryExploit.java#L75">ysoserial.exploit.RMIRegistryExploit</a>采用动态代理，通过<code>createMemoitizedProxy</code>方法封装为Remote，最终形成<code>bind(&quot;pwnedXXX&quot;, payload)</code></p>
<p>我们也可以自己创建一个类并实现<code>Remote, Serializable</code>，将payload对象赋值放入任意类属性。虽然注册端递归反序列化后最终会找不到自定义类报错，但在此之前会先触发gadgets。</p>
<p><img src="/img/rmisum_c.png"></p>
<p>在JEP290（8u121，7u131，6u141）加入的<code>sun.rmi.registry.RegistryImpl#registryFilter</code>会限制递归深度、数组长度，并基于白名单递归检查类型，会拦截payload的最终执行。</p>
<p><img src="/img/rmisum_d.png"></p>
<p>此外在8u141将<code>dispatch</code>中原来的先readObject再RegistryImpl.checkAccess（默认仅允许注册端与服务端同地址），修正为了先作检查。会使攻击者伪装成服务端向注册端发起bind/rebind/unbind的攻击失效，但不会影响攻击者作为客户端发起lookup。</p>
<h2 id="攻击DGC服务"><a href="#攻击DGC服务" class="headerlink" title="攻击DGC服务"></a>攻击DGC服务</h2><p>DGC全称是<code>Distributed Garbage Collection</code>，顾名思义其实就是GC（垃圾回收）的分布式方案。与Registry类似，DGC服务也提供了基本方法<code>dirty()</code>和<code>clean()</code>。客户端需要用到<strong>注册端</strong>或<strong>服务端</strong>的远程对象时，会通过dirty申请。相应的，当客户端不再需要时则会通过clean注销。</p>
<p>而同样与Registry类似，<strong>注册端</strong>或<strong>服务端</strong>上的<code>sun.rmi.transport.DGCImpl_Skel#dispatch</code>，会接收DGC客户端经由dirty或clean传过来的部分数据并readObject，要解决的问题是<code>sun.rmi.transport.DGCImpl_Stub#dirty</code>并没有一个参数接口用于传递对象。</p>
<p>对此，<a target="_blank" rel="noopener" href="https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/exploit/JRMPClient.java#L55">ysoserial.exploit.JRMPClient</a>按照DGC通信的固定格式直接走socket通信在相应位置写入了payload，最终形成<code>[0x4a524d49, 2, 0x4c, 0x50| 2, 0, 0, 0, 1, -669196253586618813L, payload]</code>的数据流。</p>
<p><img src="/img/rmisum_e.png"></p>
<p>在JEP290加入的<code>sun.rmi.transport.DGCImpl#checkInput</code>逻辑也与之前相同，会拦截payload的最终执行。</p>
<h2 id="攻击JRMP客户端"><a href="#攻击JRMP客户端" class="headerlink" title="攻击JRMP客户端"></a>攻击JRMP客户端</h2><p>RMI和DGC服务都是基于JRMP协议通信，就像HTTP应用与TCP之间会有Web服务器处理HTTP协议一样，JRMP也有相应的处理模块。我们将主动发起JRMP请求的一方称为JRMP客户端，将监听JRMP请求的一方成为JRMP服务端。</p>
<p>JEP290主要通过白名单限制了RMI服务端与DGC服务（注册端或服务端）readObject时能使用的类，却没有限制JRMP客户端处理JRMP服务端返回的异常信息readObject（<code>sun.rmi.transport.StreamRemoteCall#executeCall</code>）</p>
<p>同上文所述，JRMP服务端的<code>sun.rmi.transport.Transport#serviceCall</code>等位置都是直接<code>writeObject(Exception)</code>，所以需要实现恶意JRMP服务端在JRMP客户端发起连接时，将payload走异常接口给抛回去。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/frohoff/ysoserial/blob/8eb5cbfbf6c47a23682f6186bea9baf6439e57b9/src/main/java/ysoserial/exploit/JRMPListener.java#L244">ysoserial.exploit.JRMPListener</a>就是这种实现，构造为<code>[81, 2, payload]</code>的数据返回给JRMP客户端，使其进入异常处理触发payload。</p>
<h3 id="寻找Gadgets"><a href="#寻找Gadgets" class="headerlink" title="寻找Gadgets"></a>寻找Gadgets</h3><blockquote>
<p>DGCClient implements the client side of the RMI distributed garbage collection system. The external interface to DGCClient is the registerRefs() method. When a LiveRef to a remote object enters the JVM, it must be registered with the DGCClient to participate in distributed garbage collection. When the first LiveRef to a particular remote object is registered, a dirty() call is made to the server-side DGC for the remote object.</p>
</blockquote>
<p>可以知道当LiveRef加载进JVM后，会通过<code>registerRefs</code>注册并发起<code>dirty</code>请求。<a target="_blank" rel="noopener" href="https://github.com/frohoff/ysoserial/blob/8eb5cbfbf6c47a23682f6186bea9baf6439e57b9/src/main/java/ysoserial/payloads/JRMPClient.java#L71">ysoserial.payloads.JRMPClient</a>以<code>sun.rmi.server.UnicastRef#readExternal</code>充当反序列化入口，在其中装填了<code>sun.rmi.transport.LiveRef</code>，借由DGC机制便可主动发起JRMP请求。</p>
<p>如果有地方能够触发这个反序列化入口，就可以让它成为JRMP客户端向恶意JRMP服务端发起请求，进而走没被限制的异常readObject触发最终payload。刚好<code>UnicastRef</code>是<code>RegistryImpl#registryFilter</code>的白名单类，原汤化原食了属于是。</p>
<h3 id="触发反序列化"><a href="#触发反序列化" class="headerlink" title="触发反序列化"></a>触发反序列化</h3><p><a target="_blank" rel="noopener" href="https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/exploit/RMIRegistryExploit.java#L77">ysoserial.exploit.RMIRegistryExploit</a>利用的<code>registry.bind(name, remote)</code>在8u141后失效了，<a target="_blank" rel="noopener" href="https://github.com/wh1t3p1g/ysomap/blob/master/core/src/main/java/ysomap/exploits/rmi/RMIRegistryExploit.java#L76">ysomap.exploits.rmi.RMIRegistryExploit</a>使用的<code>Naming.lookup(registry, remote)</code>则依然有效。</p>
<p>同样要解决让第一步的payload符合类型要求的问题。要么依托原RMI客户端发起lookup，找一个实现了Remote且能存放LiveRef的类（比如<code>RemoteObjectInvocationHandler</code>），或者利用递归反序列化特性自己构造类；要么重新实现RMI客户端强行发送数据。</p>
<ul>
<li>前者找类并测试会遇到一个与类型相关很有意思的问题</li>
</ul>
<p><img src="/img/rmisum_f.png"></p>
<p><a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/commit/55fc1fb794937091c11b40f674cc52b3560c3300">8u231</a>捕获了在加载Ref（第一步的payload）后会触发的异常，在发起JRMP请求（<code>releaseInputStream</code>）之前清除了Ref。</p>
<p><img src="/img/rmisum_g.png"></p>
<p>并且将dirty和clean中的<code>setObjectInputFilter(DGCImpl_Stub::leaseFilter)</code>过滤器提到了JRMP请求发起之后、恶意JRMP服务端最终gadgets触发之前（<code>ref.invoke(call)</code>)的位置。</p>
<p>细看可以发现缓解措施针对的都是加载Ref（第一步的payload）之后的过程，当有一个gadgets能在加载自身就触发JRMP请求，就能绕过这些过滤，An Trinhs找到了一条这样的链：</p>
<ol>
<li><p>UnicastRemoteObject#readObject</p>
</li>
<li><p>RMIServerSocketFactory#createServerSocket</p>
</li>
<li><p>RemoteObjectInvocationHandler#invoke</p>
</li>
</ol>
<p>利用动态代理机制封装了类，同时gank了本来的方法调用，将其引入invoke。</p>
<p><img src="/img/rmisum_h.png"></p>
<p>从OracleJDK-8u241/<a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk8u/commit/9fb68f29a5fc2bf5407e72f96ca6cd81be1af6e8#diff-9071564785e3fe39d109f0bb6b72a651">OpenJDK-8u242</a>开始将多处readObject再转型String的地方修改为了<code>SharedSecrets.getJavaObjectInputStreamReadString().readString</code>，修复了lookup时的反序列化入口，并且影响上文<strong>攻击远程方法参数</strong>和<strong>攻击RMI注册端</strong>中涉及String类型参数的地方。</p>
<h2 id="反制攻击方"><a href="#反制攻击方" class="headerlink" title="反制攻击方"></a>反制攻击方</h2><p>最后稍微聊一下喜闻乐见的反制问题，ysoserial在<a target="_blank" rel="noopener" href="https://github.com/frohoff/ysoserial/commit/477ecb8f05f42b0195a67d9712e97f2c6d31e1da">477ecb8</a>更新了一个无限制的<code>registry.list()</code>，哪怕在8u261中依然是写着赤果果的readObject：</p>
<p><img src="/img/rmisum_i.png"></p>
<p>而在那个commit之前，也许作者是想借由原生的<code>registry.bind(name, remote)</code>得到注册端回显，方便攻击时判断gadgets环境，为此其戴了<code>ExecCheckingSecurityManage</code>作为安全措施（/doge），但还是可以通过CC链读写文件等方式间接溯源或者RCE。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a target="_blank" rel="noopener" href="https://mogwailabs.de/en/blog/2019/03/attacking-java-rmi-services-after-jep-290/">Attacking Java RMI services after JEP 290</a></p>
<p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/7932">针对RMI服务的九重攻击 - 下</a></p>
<p><a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/290">JEP 290: Filter Incoming Serialization Data</a></p>
<p><a target="_blank" rel="noopener" href="https://www.ibm.com/docs/en/sdk-java-technology/8?topic=iiop-understanding-distributed-garbage-collection">Understanding distributed garbage collection</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV17Z4y1s7cG">30行代码透彻解析RPC</a></p>

      </div>
      
      <footer class="post-footer">
        <div class="post-tags">
            <a href="/tags/RMI/">RMI</a>
            <a href="/tags/DGC/">DGC</a>
            <a href="/tags/JRMP/">JRMP</a>
            <a href="/tags/useCodebaseOnly/">useCodebaseOnly</a>
            <a href="/tags/registry/">registry</a>
            <a href="/tags/BaRMIe/">BaRMIe</a>
            <a href="/tags/ysoserial/">ysoserial</a>
            <a href="/tags/ysomap/">ysomap</a>
            </div>
        
        <nav class="post-nav"><a class="prev" href="/2022/03/24/Fastjson-autoType%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">Fastjson-autoType漏洞总结</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    <a class="next" href="/2021/12/10/Log4j2%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/">
        <span class="next-text nav-default">Log4j2漏洞浅析</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    </nav></footer>
    </article></div><div class="comments" id="comments"></div></div>
      </main>

      <footer id="footer" class="footer"><div class="social-links"><a href="mailto:hosch3n@protonmail.com" class="iconfont icon-email" title="email"></a>
        <a target="_blank" rel="noopener" href="https://github.com/hosch3n" class="iconfont icon-github" title="github"></a>
        <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    </div><div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">&copy;2021 - 2022<span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">hosch3n</span>
  </span>
</div>
</footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div><script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/src/even.js?v=2.11.0"></script>
</body>
</html>
